/* automatically generated by rust-bindgen 0.58.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub const __GNUCLIKE_ASM: u32 = 3;
pub const __GNUCLIKE___TYPEOF: u32 = 1;
pub const __GNUCLIKE___OFFSETOF: u32 = 1;
pub const __GNUCLIKE___SECTION: u32 = 1;
pub const __GNUCLIKE_CTOR_SECTION_HANDLING: u32 = 1;
pub const __GNUCLIKE_BUILTIN_CONSTANT_P: u32 = 1;
pub const __GNUCLIKE_BUILTIN_VARARGS: u32 = 1;
pub const __GNUCLIKE_BUILTIN_STDARG: u32 = 1;
pub const __GNUCLIKE_BUILTIN_VAALIST: u32 = 1;
pub const __GNUC_VA_LIST_COMPATIBILITY: u32 = 1;
pub const __GNUCLIKE_BUILTIN_NEXT_ARG: u32 = 1;
pub const __GNUCLIKE_BUILTIN_MEMCPY: u32 = 1;
pub const __CC_SUPPORTS_INLINE: u32 = 1;
pub const __CC_SUPPORTS___INLINE: u32 = 1;
pub const __CC_SUPPORTS___INLINE__: u32 = 1;
pub const __CC_SUPPORTS___FUNC__: u32 = 1;
pub const __CC_SUPPORTS_WARNING: u32 = 1;
pub const __CC_SUPPORTS_VARADIC_XXX: u32 = 1;
pub const __CC_SUPPORTS_DYNAMIC_ARRAY_INIT: u32 = 1;
pub const __POSIX_VISIBLE: u32 = 200809;
pub const __XSI_VISIBLE: u32 = 700;
pub const __BSD_VISIBLE: u32 = 1;
pub const __ISO_C_VISIBLE: u32 = 2011;
pub const __NO_TLS: u32 = 1;
pub const __WCHAR_MIN: u32 = 0;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT64_MIN: i64 = -9223372036854775808;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const INT64_MAX: u64 = 9223372036854775807;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const UINT64_MAX: i32 = -1;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const INT_LEAST64_MAX: u64 = 9223372036854775807;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const UINT_LEAST64_MAX: i32 = -1;
pub const INT_FAST8_MIN: i32 = -2147483648;
pub const INT_FAST16_MIN: i32 = -2147483648;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST64_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 2147483647;
pub const INT_FAST16_MAX: u32 = 2147483647;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const INT_FAST64_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 4294967295;
pub const UINT_FAST16_MAX: u32 = 4294967295;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const UINT_FAST64_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const INTMAX_MIN: i64 = -9223372036854775808;
pub const INTMAX_MAX: u64 = 9223372036854775807;
pub const UINTMAX_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: i32 = -2147483648;
pub const WINT_MAX: u32 = 2147483647;
pub const __WORDSIZE: u32 = 64;
pub const WCHAR_MIN: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const false_: u32 = 0;
pub const true_: u32 = 1;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const RAND_MAX: u32 = 2147483645;
pub const BSD: u32 = 199506;
pub const BSD4_3: u32 = 1;
pub const BSD4_4: u32 = 1;
pub const __FreeBSD_version: u32 = 1200007;
pub const _LITTLE_ENDIAN: u32 = 1234;
pub const _BIG_ENDIAN: u32 = 4321;
pub const _PDP_ENDIAN: u32 = 3412;
pub const _BYTE_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _QUAD_HIGHWORD: u32 = 1;
pub const _QUAD_LOWWORD: u32 = 0;
pub const _SIG_WORDS: u32 = 4;
pub const _SIG_MAXSIG: u32 = 128;
pub const FD_SETSIZE: u32 = 1024;
pub const ARG_MAX: u32 = 262144;
pub const CHILD_MAX: u32 = 40;
pub const LINK_MAX: u32 = 32767;
pub const MAX_CANON: u32 = 255;
pub const MAX_INPUT: u32 = 255;
pub const NAME_MAX: u32 = 255;
pub const NGROUPS_MAX: u32 = 1023;
pub const OPEN_MAX: u32 = 64;
pub const PATH_MAX: u32 = 1024;
pub const PIPE_BUF: u32 = 512;
pub const IOV_MAX: u32 = 1024;
pub const MAXCOMLEN: u32 = 19;
pub const MAXINTERP: u32 = 1024;
pub const MAXLOGNAME: u32 = 33;
pub const MAXUPRC: u32 = 40;
pub const NCARGS: u32 = 262144;
pub const NGROUPS: u32 = 1024;
pub const NOFILE: u32 = 64;
pub const NOGROUP: u32 = 65535;
pub const MAXHOSTNAMELEN: u32 = 256;
pub const SPECNAMELEN: u32 = 63;
pub const STACKALIGNBYTES: u32 = 15;
pub const MACHINE: &'static [u8; 6usize] = b"arm64\0";
pub const MACHINE_ARCH: &'static [u8; 8usize] = b"aarch64\0";
pub const MAXCPU: u32 = 1;
pub const MAXMEMDOM: u32 = 1;
pub const CACHE_LINE_SHIFT: u32 = 6;
pub const CACHE_LINE_SIZE: u32 = 64;
pub const PAGE_SHIFT: u32 = 12;
pub const PAGE_SIZE: u32 = 4096;
pub const PAGE_MASK: u32 = 4095;
pub const PAGE_SHIFT_16K: u32 = 14;
pub const PAGE_SIZE_16K: u32 = 16384;
pub const PAGE_MASK_16K: u32 = 16383;
pub const PAGE_SHIFT_64K: u32 = 16;
pub const PAGE_SIZE_64K: u32 = 65536;
pub const PAGE_MASK_64K: u32 = 65535;
pub const MAXPAGESIZES: u32 = 1;
pub const KSTACK_PAGES: u32 = 4;
pub const KSTACK_GUARD_PAGES: u32 = 1;
pub const PCPU_PAGES: u32 = 1;
pub const VM_BCACHE_SIZE_MAX: u32 = 419430400;
pub const __CHAR_BIT: u32 = 8;
pub const __SCHAR_MAX: u32 = 127;
pub const __SCHAR_MIN: i32 = -128;
pub const __UCHAR_MAX: u32 = 255;
pub const __USHRT_MAX: u32 = 65535;
pub const __SHRT_MAX: u32 = 32767;
pub const __SHRT_MIN: i32 = -32768;
pub const __UINT_MAX: u32 = 4294967295;
pub const __INT_MAX: u32 = 2147483647;
pub const __INT_MIN: i32 = -2147483648;
pub const __ULONG_MAX: i32 = -1;
pub const __LONG_MAX: u64 = 9223372036854775807;
pub const __LONG_MIN: i64 = -9223372036854775808;
pub const __ULLONG_MAX: i32 = -1;
pub const __LLONG_MAX: u64 = 9223372036854775807;
pub const __LLONG_MIN: i64 = -9223372036854775808;
pub const __SSIZE_MAX: u64 = 9223372036854775807;
pub const __SIZE_T_MAX: i32 = -1;
pub const __OFF_MAX: u64 = 9223372036854775807;
pub const __OFF_MIN: i64 = -9223372036854775808;
pub const __UQUAD_MAX: i32 = -1;
pub const __QUAD_MAX: u64 = 9223372036854775807;
pub const __QUAD_MIN: i64 = -9223372036854775808;
pub const __LONG_BIT: u32 = 64;
pub const __WORD_BIT: u32 = 32;
pub const __MINSIGSTKSZ: u32 = 4096;
pub const CHAR_BIT: u32 = 8;
pub const SCHAR_MAX: u32 = 127;
pub const SCHAR_MIN: i32 = -128;
pub const UCHAR_MAX: u32 = 255;
pub const CHAR_MAX: u32 = 127;
pub const CHAR_MIN: i32 = -128;
pub const USHRT_MAX: u32 = 65535;
pub const SHRT_MAX: u32 = 32767;
pub const SHRT_MIN: i32 = -32768;
pub const UINT_MAX: u32 = 4294967295;
pub const INT_MAX: u32 = 2147483647;
pub const INT_MIN: i32 = -2147483648;
pub const ULONG_MAX: i32 = -1;
pub const LONG_MAX: u64 = 9223372036854775807;
pub const LONG_MIN: i64 = -9223372036854775808;
pub const ULLONG_MAX: i32 = -1;
pub const LLONG_MAX: u64 = 9223372036854775807;
pub const LLONG_MIN: i64 = -9223372036854775808;
pub const SSIZE_MAX: u64 = 9223372036854775807;
pub const SIZE_T_MAX: i32 = -1;
pub const OFF_MAX: u64 = 9223372036854775807;
pub const OFF_MIN: i64 = -9223372036854775808;
pub const GID_MAX: u32 = 4294967295;
pub const UID_MAX: u32 = 4294967295;
pub const UQUAD_MAX: i32 = -1;
pub const QUAD_MAX: u64 = 9223372036854775807;
pub const QUAD_MIN: i64 = -9223372036854775808;
pub const LONG_BIT: u32 = 64;
pub const WORD_BIT: u32 = 32;
pub const MQ_PRIO_MAX: u32 = 64;
pub const DEV_BSHIFT: u32 = 9;
pub const DEV_BSIZE: u32 = 512;
pub const BLKDEV_IOSIZE: u32 = 4096;
pub const DFLTPHYS: u32 = 65536;
pub const MAXPHYS: u32 = 131072;
pub const MAXDUMPPGS: u32 = 16;
pub const MSIZE: u32 = 256;
pub const MCLSHIFT: u32 = 11;
pub const MCLBYTES: u32 = 2048;
pub const MJUMPAGESIZE: u32 = 4096;
pub const MJUM9BYTES: u32 = 9216;
pub const MJUM16BYTES: u32 = 16384;
pub const PRIMASK: u32 = 255;
pub const PCATCH: u32 = 256;
pub const PDROP: u32 = 512;
pub const NZERO: u32 = 0;
pub const NBBY: u32 = 8;
pub const CMASK: u32 = 18;
pub const MAXBSIZE: u32 = 65536;
pub const MAXBCACHEBUF: u32 = 65536;
pub const BKVASIZE: u32 = 16384;
pub const BKVAMASK: u32 = 16383;
pub const MAXPATHLEN: u32 = 1024;
pub const MAXSYMLINKS: u32 = 32;
pub const FSHIFT: u32 = 11;
pub const FSCALE: u32 = 2048;
pub const PRId8: &'static [u8; 2usize] = b"d\0";
pub const PRId16: &'static [u8; 2usize] = b"d\0";
pub const PRId32: &'static [u8; 2usize] = b"d\0";
pub const PRId64: &'static [u8; 3usize] = b"ld\0";
pub const PRIdLEAST8: &'static [u8; 2usize] = b"d\0";
pub const PRIdLEAST16: &'static [u8; 2usize] = b"d\0";
pub const PRIdLEAST32: &'static [u8; 2usize] = b"d\0";
pub const PRIdLEAST64: &'static [u8; 3usize] = b"ld\0";
pub const PRIdFAST8: &'static [u8; 2usize] = b"d\0";
pub const PRIdFAST16: &'static [u8; 2usize] = b"d\0";
pub const PRIdFAST32: &'static [u8; 2usize] = b"d\0";
pub const PRIdFAST64: &'static [u8; 3usize] = b"ld\0";
pub const PRIdMAX: &'static [u8; 3usize] = b"jd\0";
pub const PRIdPTR: &'static [u8; 3usize] = b"ld\0";
pub const PRIi8: &'static [u8; 2usize] = b"i\0";
pub const PRIi16: &'static [u8; 2usize] = b"i\0";
pub const PRIi32: &'static [u8; 2usize] = b"i\0";
pub const PRIi64: &'static [u8; 3usize] = b"li\0";
pub const PRIiLEAST8: &'static [u8; 2usize] = b"i\0";
pub const PRIiLEAST16: &'static [u8; 2usize] = b"i\0";
pub const PRIiLEAST32: &'static [u8; 2usize] = b"i\0";
pub const PRIiLEAST64: &'static [u8; 3usize] = b"li\0";
pub const PRIiFAST8: &'static [u8; 2usize] = b"i\0";
pub const PRIiFAST16: &'static [u8; 2usize] = b"i\0";
pub const PRIiFAST32: &'static [u8; 2usize] = b"i\0";
pub const PRIiFAST64: &'static [u8; 3usize] = b"li\0";
pub const PRIiMAX: &'static [u8; 3usize] = b"ji\0";
pub const PRIiPTR: &'static [u8; 3usize] = b"li\0";
pub const PRIo8: &'static [u8; 2usize] = b"o\0";
pub const PRIo16: &'static [u8; 2usize] = b"o\0";
pub const PRIo32: &'static [u8; 2usize] = b"o\0";
pub const PRIo64: &'static [u8; 3usize] = b"lo\0";
pub const PRIoLEAST8: &'static [u8; 2usize] = b"o\0";
pub const PRIoLEAST16: &'static [u8; 2usize] = b"o\0";
pub const PRIoLEAST32: &'static [u8; 2usize] = b"o\0";
pub const PRIoLEAST64: &'static [u8; 3usize] = b"lo\0";
pub const PRIoFAST8: &'static [u8; 2usize] = b"o\0";
pub const PRIoFAST16: &'static [u8; 2usize] = b"o\0";
pub const PRIoFAST32: &'static [u8; 2usize] = b"o\0";
pub const PRIoFAST64: &'static [u8; 3usize] = b"lo\0";
pub const PRIoMAX: &'static [u8; 3usize] = b"jo\0";
pub const PRIoPTR: &'static [u8; 3usize] = b"lo\0";
pub const PRIu8: &'static [u8; 2usize] = b"u\0";
pub const PRIu16: &'static [u8; 2usize] = b"u\0";
pub const PRIu32: &'static [u8; 2usize] = b"u\0";
pub const PRIu64: &'static [u8; 3usize] = b"lu\0";
pub const PRIuLEAST8: &'static [u8; 2usize] = b"u\0";
pub const PRIuLEAST16: &'static [u8; 2usize] = b"u\0";
pub const PRIuLEAST32: &'static [u8; 2usize] = b"u\0";
pub const PRIuLEAST64: &'static [u8; 3usize] = b"lu\0";
pub const PRIuFAST8: &'static [u8; 2usize] = b"u\0";
pub const PRIuFAST16: &'static [u8; 2usize] = b"u\0";
pub const PRIuFAST32: &'static [u8; 2usize] = b"u\0";
pub const PRIuFAST64: &'static [u8; 3usize] = b"lu\0";
pub const PRIuMAX: &'static [u8; 3usize] = b"ju\0";
pub const PRIuPTR: &'static [u8; 3usize] = b"lu\0";
pub const PRIx8: &'static [u8; 2usize] = b"x\0";
pub const PRIx16: &'static [u8; 2usize] = b"x\0";
pub const PRIx32: &'static [u8; 2usize] = b"x\0";
pub const PRIx64: &'static [u8; 3usize] = b"lx\0";
pub const PRIxLEAST8: &'static [u8; 2usize] = b"x\0";
pub const PRIxLEAST16: &'static [u8; 2usize] = b"x\0";
pub const PRIxLEAST32: &'static [u8; 2usize] = b"x\0";
pub const PRIxLEAST64: &'static [u8; 3usize] = b"lx\0";
pub const PRIxFAST8: &'static [u8; 2usize] = b"x\0";
pub const PRIxFAST16: &'static [u8; 2usize] = b"x\0";
pub const PRIxFAST32: &'static [u8; 2usize] = b"x\0";
pub const PRIxFAST64: &'static [u8; 3usize] = b"lx\0";
pub const PRIxMAX: &'static [u8; 3usize] = b"jx\0";
pub const PRIxPTR: &'static [u8; 3usize] = b"lx\0";
pub const PRIX8: &'static [u8; 2usize] = b"X\0";
pub const PRIX16: &'static [u8; 2usize] = b"X\0";
pub const PRIX32: &'static [u8; 2usize] = b"X\0";
pub const PRIX64: &'static [u8; 3usize] = b"lX\0";
pub const PRIXLEAST8: &'static [u8; 2usize] = b"X\0";
pub const PRIXLEAST16: &'static [u8; 2usize] = b"X\0";
pub const PRIXLEAST32: &'static [u8; 2usize] = b"X\0";
pub const PRIXLEAST64: &'static [u8; 3usize] = b"lX\0";
pub const PRIXFAST8: &'static [u8; 2usize] = b"X\0";
pub const PRIXFAST16: &'static [u8; 2usize] = b"X\0";
pub const PRIXFAST32: &'static [u8; 2usize] = b"X\0";
pub const PRIXFAST64: &'static [u8; 3usize] = b"lX\0";
pub const PRIXMAX: &'static [u8; 3usize] = b"jX\0";
pub const PRIXPTR: &'static [u8; 3usize] = b"lX\0";
pub const SCNd8: &'static [u8; 4usize] = b"hhd\0";
pub const SCNd16: &'static [u8; 3usize] = b"hd\0";
pub const SCNd32: &'static [u8; 2usize] = b"d\0";
pub const SCNd64: &'static [u8; 3usize] = b"ld\0";
pub const SCNdLEAST8: &'static [u8; 4usize] = b"hhd\0";
pub const SCNdLEAST16: &'static [u8; 3usize] = b"hd\0";
pub const SCNdLEAST32: &'static [u8; 2usize] = b"d\0";
pub const SCNdLEAST64: &'static [u8; 3usize] = b"ld\0";
pub const SCNdFAST8: &'static [u8; 2usize] = b"d\0";
pub const SCNdFAST16: &'static [u8; 2usize] = b"d\0";
pub const SCNdFAST32: &'static [u8; 2usize] = b"d\0";
pub const SCNdFAST64: &'static [u8; 3usize] = b"ld\0";
pub const SCNdMAX: &'static [u8; 3usize] = b"jd\0";
pub const SCNdPTR: &'static [u8; 3usize] = b"ld\0";
pub const SCNi8: &'static [u8; 4usize] = b"hhi\0";
pub const SCNi16: &'static [u8; 3usize] = b"hi\0";
pub const SCNi32: &'static [u8; 2usize] = b"i\0";
pub const SCNi64: &'static [u8; 3usize] = b"li\0";
pub const SCNiLEAST8: &'static [u8; 4usize] = b"hhi\0";
pub const SCNiLEAST16: &'static [u8; 3usize] = b"hi\0";
pub const SCNiLEAST32: &'static [u8; 2usize] = b"i\0";
pub const SCNiLEAST64: &'static [u8; 3usize] = b"li\0";
pub const SCNiFAST8: &'static [u8; 2usize] = b"i\0";
pub const SCNiFAST16: &'static [u8; 2usize] = b"i\0";
pub const SCNiFAST32: &'static [u8; 2usize] = b"i\0";
pub const SCNiFAST64: &'static [u8; 3usize] = b"li\0";
pub const SCNiMAX: &'static [u8; 3usize] = b"ji\0";
pub const SCNiPTR: &'static [u8; 3usize] = b"li\0";
pub const SCNo8: &'static [u8; 4usize] = b"hho\0";
pub const SCNo16: &'static [u8; 3usize] = b"ho\0";
pub const SCNo32: &'static [u8; 2usize] = b"o\0";
pub const SCNo64: &'static [u8; 3usize] = b"lo\0";
pub const SCNoLEAST8: &'static [u8; 4usize] = b"hho\0";
pub const SCNoLEAST16: &'static [u8; 3usize] = b"ho\0";
pub const SCNoLEAST32: &'static [u8; 2usize] = b"o\0";
pub const SCNoLEAST64: &'static [u8; 3usize] = b"lo\0";
pub const SCNoFAST8: &'static [u8; 2usize] = b"o\0";
pub const SCNoFAST16: &'static [u8; 2usize] = b"o\0";
pub const SCNoFAST32: &'static [u8; 2usize] = b"o\0";
pub const SCNoFAST64: &'static [u8; 3usize] = b"lo\0";
pub const SCNoMAX: &'static [u8; 3usize] = b"jo\0";
pub const SCNoPTR: &'static [u8; 3usize] = b"lo\0";
pub const SCNu8: &'static [u8; 4usize] = b"hhu\0";
pub const SCNu16: &'static [u8; 3usize] = b"hu\0";
pub const SCNu32: &'static [u8; 2usize] = b"u\0";
pub const SCNu64: &'static [u8; 3usize] = b"lu\0";
pub const SCNuLEAST8: &'static [u8; 4usize] = b"hhu\0";
pub const SCNuLEAST16: &'static [u8; 3usize] = b"hu\0";
pub const SCNuLEAST32: &'static [u8; 2usize] = b"u\0";
pub const SCNuLEAST64: &'static [u8; 3usize] = b"lu\0";
pub const SCNuFAST8: &'static [u8; 2usize] = b"u\0";
pub const SCNuFAST16: &'static [u8; 2usize] = b"u\0";
pub const SCNuFAST32: &'static [u8; 2usize] = b"u\0";
pub const SCNuFAST64: &'static [u8; 3usize] = b"lu\0";
pub const SCNuMAX: &'static [u8; 3usize] = b"ju\0";
pub const SCNuPTR: &'static [u8; 3usize] = b"lu\0";
pub const SCNx8: &'static [u8; 4usize] = b"hhx\0";
pub const SCNx16: &'static [u8; 3usize] = b"hx\0";
pub const SCNx32: &'static [u8; 2usize] = b"x\0";
pub const SCNx64: &'static [u8; 3usize] = b"lx\0";
pub const SCNxLEAST8: &'static [u8; 4usize] = b"hhx\0";
pub const SCNxLEAST16: &'static [u8; 3usize] = b"hx\0";
pub const SCNxLEAST32: &'static [u8; 2usize] = b"x\0";
pub const SCNxLEAST64: &'static [u8; 3usize] = b"lx\0";
pub const SCNxFAST8: &'static [u8; 2usize] = b"x\0";
pub const SCNxFAST16: &'static [u8; 2usize] = b"x\0";
pub const SCNxFAST32: &'static [u8; 2usize] = b"x\0";
pub const SCNxFAST64: &'static [u8; 3usize] = b"lx\0";
pub const SCNxMAX: &'static [u8; 3usize] = b"jx\0";
pub const SCNxPTR: &'static [u8; 3usize] = b"lx\0";
pub const PRIuLPADDR: &'static [u8; 3usize] = b"lu\0";
pub const PRIxLPADDR: &'static [u8; 3usize] = b"lx\0";
pub const SCNuLPADDR: &'static [u8; 3usize] = b"lu\0";
pub const PRIuGENPADDR: &'static [u8; 3usize] = b"lu\0";
pub const PRIxGENPADDR: &'static [u8; 3usize] = b"lx\0";
pub const PRIuGENSIZE: &'static [u8; 3usize] = b"lu\0";
pub const PRIxGENSIZE: &'static [u8; 3usize] = b"lx\0";
pub const PRIuLVADDR: &'static [u8; 3usize] = b"lu\0";
pub const PRIxLVADDR: &'static [u8; 3usize] = b"lx\0";
pub const PRIuGENVADDR: &'static [u8; 3usize] = b"lu\0";
pub const PRIxGENVADDR: &'static [u8; 3usize] = b"lx\0";
pub const PRIuFORVADDR: &'static [u8; 3usize] = b"lu\0";
pub const PRIxFORVADDR: &'static [u8; 3usize] = b"lx\0";
pub const PRIuCADDR: &'static [u8; 2usize] = b"u\0";
pub const PRIxCADDR: &'static [u8; 2usize] = b"x\0";
pub const PRIuPASID: &'static [u8; 2usize] = b"u\0";
pub const PRIxPASID: &'static [u8; 2usize] = b"x\0";
pub const PRIuCSLOT: &'static [u8; 2usize] = b"u\0";
pub const PRIxCSLOT: &'static [u8; 2usize] = b"x\0";
pub const PRIuCOREID: &'static [u8; 2usize] = b"u\0";
pub const PRIxCOREID: &'static [u8; 2usize] = b"x\0";
pub const MAX_COREID: u32 = 254;
pub const PRIuNODEID: &'static [u8; 2usize] = b"u\0";
pub const SCNuNODEID: &'static [u8; 4usize] = b"hhu\0";
pub const PRIxNODEID: &'static [u8; 2usize] = b"x\0";
pub const MAX_NODEID: u32 = 255;
pub const PRIuHWID: &'static [u8; 3usize] = b"lu\0";
pub const PRIxHWID: &'static [u8; 3usize] = b"lx\0";
pub const PRIuIDCAPID: &'static [u8; 3usize] = b"lu\0";
pub const PRIxIDCAPID: &'static [u8; 3usize] = b"lx\0";
pub const PRIuRSRCID: &'static [u8; 2usize] = b"u\0";
pub const PRIxRSRCID: &'static [u8; 2usize] = b"x\0";
pub const MAX_DOMAINID: u32 = 4294967295;
pub const PRIuDOMAINID: &'static [u8; 2usize] = b"u\0";
pub const PRIxDOMAINID: &'static [u8; 2usize] = b"x\0";
pub const PRIuSYSTIME: &'static [u8; 3usize] = b"lu\0";
pub const PRIxSYSTIME: &'static [u8; 3usize] = b"lx\0";
pub const PRIXSYSTIME: &'static [u8; 3usize] = b"lX\0";
pub const PRIxERRV: &'static [u8; 3usize] = b"lx\0";
pub const PRIuERRV: &'static [u8; 3usize] = b"lu\0";
pub const OBJBITS_CTE: u32 = 6;
pub const OBJSIZE_CTE: u32 = 64;
pub const L2_CNODE_BITS: u32 = 8;
pub const L2_CNODE_SLOTS: u32 = 256;
pub const CAPRIGHTS_READ: u32 = 1;
pub const CAPRIGHTS_WRITE: u32 = 2;
pub const CAPRIGHTS_EXECUTE: u32 = 4;
pub const CAPRIGHTS_GRANT: u32 = 8;
pub const CAPRIGHTS_IDENTIFY: u32 = 16;
pub const CAPRIGHTS_NUM: u32 = 5;
pub const CAPRIGHTS_ALLRIGHTS: u32 = 31;
pub const CAPRIGHTS_READ_WRITE: u32 = 3;
pub const CAPRIGHTS_NORIGHTS: u32 = 0;
pub const PRIuCAPRIGHTS: &'static [u8; 2usize] = b"u\0";
pub const PRIxCAPRIGHTS: &'static [u8; 2usize] = b"x\0";
pub const AARCH64_MODE_EL0T: u32 = 0;
pub const AARCH64_MODE_EL1T: u32 = 4;
pub const AARCH64_MODE_EL1H: u32 = 5;
pub const AARCH64_MODE_USR: u32 = 0;
pub const AARCH64_MODE_FIQ: u32 = 17;
pub const AARCH64_MODE_IRQ: u32 = 18;
pub const AARCH64_MODE_SVC: u32 = 19;
pub const AARCH64_MODE_ABT: u32 = 23;
pub const AARCH64_MODE_UND: u32 = 27;
pub const AARCH64_MODE_SYS: u32 = 31;
pub const AARCH64_MODE_MASK: u32 = 31;
pub const AARCH64_MODE_PRIV: u32 = 15;
pub const CPSR_IF_MASK: u32 = 192;
pub const CPSR_I_MASK: u32 = 128;
pub const CPSR_F_MASK: u32 = 64;
pub const VMSAv8_64_BASE_PAGE_BITS: u32 = 12;
pub const VMSAv8_64_L2_BLOCK_BITS: u32 = 21;
pub const VMSAv8_64_L1_BLOCK_BITS: u32 = 30;
pub const VMSAv8_64_L0_BITS: u32 = 39;
pub const VMSAv8_64_PTABLE_ENTRY_BITS: u32 = 3;
pub const VMSAv8_64_PTABLE_BITS: u32 = 9;
pub const VMSAv8_64_PTABLE_CLEAR: u32 = 0;
pub const VMSAv8_64_L3_CACHEABLE: u32 = 768;
pub const VMSAv8_64_L3_BUFFERABLE: u32 = 0;
pub const VMSAv8_64_L3_USR_RO: u32 = 192;
pub const VMSAv8_64_L3_USR_RW: u32 = 64;
pub const VMSAv8_64_L3_USR_NONE: u32 = 128;
pub const VMSAv8_64_L2_CACHEABLE: u32 = 8;
pub const VMSAv8_64_L2_BUFFERABLE: u32 = 4;
pub const VMSAv8_64_L2_USR_RO: u32 = 32;
pub const VMSAv8_64_L2_USR_RW: u32 = 48;
pub const VMSAv8_64_L2_USR_NONE: u32 = 16;
pub const KPI_PAGING_FLAGS_READ: u32 = 1;
pub const KPI_PAGING_FLAGS_WRITE: u32 = 2;
pub const KPI_PAGING_FLAGS_EXECUTE: u32 = 4;
pub const KPI_PAGING_FLAGS_NOCACHE: u32 = 8;
pub const KPI_PAGING_FLAGS_MASK: u32 = 15;
pub const BASE_PAGE_BITS: u32 = 12;
pub const LARGE_PAGE_BITS: u32 = 21;
pub const HUGE_PAGE_BITS: u32 = 30;
pub const PTABLE_EXECUTE_DISABLE: u32 = 0;
pub const PTABLE_GLOBAL_PAGE: u32 = 0;
pub const PTABLE_ATTR_INDEX: u32 = 0;
pub const PTABLE_DIRTY: u32 = 0;
pub const PTABLE_ACCESSED: u32 = 0;
pub const PTABLE_CACHE_DISABLED: u32 = 0;
pub const PTABLE_WRITE_THROUGH: u32 = 0;
pub const PTABLE_USER_SUPERVISOR: u32 = 0;
pub const PTABLE_READ_WRITE: u32 = 0;
pub const PTABLE_PRESENT: u32 = 0;
pub const PTABLE_CLEAR: u32 = 0;
pub const PTABLE_ACCESS_DEFAULT: u32 = 3;
pub const PTABLE_ACCESS_READONLY: u32 = 1;
pub const SYSCALL_INVOKE: u32 = 0;
pub const SYSCALL_YIELD: u32 = 1;
pub const SYSCALL_LRPC: u32 = 2;
pub const SYSCALL_DEBUG: u32 = 3;
pub const SYSCALL_REBOOT: u32 = 4;
pub const SYSCALL_NOP: u32 = 5;
pub const SYSCALL_PRINT: u32 = 6;
pub const SYSCALL_GETCHAR: u32 = 7;
pub const SYSCALL_X86_RELOAD_LDT: u32 = 9;
pub const SYSCALL_SUSPEND: u32 = 10;
pub const SYSCALL_ARMv7_CACHE_CLEAN: u32 = 8;
pub const SYSCALL_ARMv7_CACHE_INVAL: u32 = 9;
pub const SYSCALL_COUNT: u32 = 10;
pub const BOOTINFO_SIZEBITS: u32 = 14;
pub const BOOTINFO_SIZE: u32 = 16384;
pub const ARGS_FRAME_BITS: u32 = 17;
pub const MAX_CMDLINE_ARGS: u32 = 128;
pub const MAX_ENVIRON_VARS: u32 = 128;
pub const FDS_SIZE: u32 = 32768;
pub const ROOTCN_SLOT_TASKCN: u32 = 0;
pub const ROOTCN_SLOT_PAGECN: u32 = 1;
pub const ROOTCN_SLOT_BASE_PAGE_CN: u32 = 2;
pub const ROOTCN_SLOT_SUPERCN: u32 = 3;
pub const ROOTCN_SLOT_SEGCN: u32 = 4;
pub const ROOTCN_SLOT_PACN: u32 = 5;
pub const ROOTCN_SLOT_MODULECN: u32 = 6;
pub const ROOTCN_SLOT_SLOT_ALLOC0: u32 = 7;
pub const ROOTCN_SLOT_SLOT_ALLOC1: u32 = 8;
pub const ROOTCN_SLOT_SLOT_ALLOC2: u32 = 9;
pub const ROOTCN_SLOT_ROOT_MAPPING: u32 = 10;
pub const ROOTCN_SLOT_ARGCN: u32 = 11;
pub const ROOTCN_SLOT_BSPKCB: u32 = 12;
pub const ROOTCN_SLOT_EARLY_CN_CN: u32 = 13;
pub const ROOTCN_SLOTS_USER: u32 = 14;
pub const SLOT_ALLOC_CNODE_BITS: u32 = 8;
pub const SLOT_ALLOC_CNODE_SLOTS: u32 = 256;
pub const EARLY_CNODE_ALLOCATED_BITS: u32 = 6;
pub const EARLY_CNODE_ALLOCATED_SLOTS: u32 = 64;
pub const TASKCN_SLOT_TASKCN: u32 = 0;
pub const TASKCN_SLOT_DISPATCHER: u32 = 1;
pub const TASKCN_SLOT_ROOTCN: u32 = 2;
pub const TASKCN_SLOT_DISPFRAME: u32 = 4;
pub const TASKCN_SLOT_IRQ: u32 = 5;
pub const TASKCN_SLOT_DEV: u32 = 6;
pub const TASKCN_SLOT_BOOTINFO: u32 = 7;
pub const TASKCN_SLOT_KERNELCAP: u32 = 8;
pub const TASKCN_SLOT_TRACEBUF: u32 = 9;
pub const TASKCN_SLOT_ARGSPAGE: u32 = 10;
pub const TASKCN_SLOT_MON_URPC: u32 = 11;
pub const TASKCN_SLOT_SESSIONID: u32 = 12;
pub const TASKCN_SLOT_FDSPAGE: u32 = 13;
pub const TASKCN_SLOT_PERF_MON: u32 = 14;
pub const TASKCN_SLOT_SYSMEM: u32 = 15;
pub const TASKCN_SLOT_COREBOOT: u32 = 16;
pub const TASKCN_SLOT_IPI: u32 = 17;
pub const TASKCN_SLOT_PROC_MNG: u32 = 18;
pub const TASKCN_SLOT_DOMAINID: u32 = 19;
pub const TASKCN_SLOT_DEVMAN: u32 = 20;
pub const TASKCN_SLOTS_USER: u32 = 21;
pub const PAGECN_SLOT_VROOT: u32 = 0;
pub const X0_REG: u32 = 0;
pub const X1_REG: u32 = 1;
pub const X2_REG: u32 = 2;
pub const X3_REG: u32 = 3;
pub const X4_REG: u32 = 4;
pub const X5_REG: u32 = 5;
pub const X6_REG: u32 = 6;
pub const X7_REG: u32 = 7;
pub const X8_REG: u32 = 8;
pub const X9_REG: u32 = 9;
pub const X10_REG: u32 = 10;
pub const X11_REG: u32 = 11;
pub const X12_REG: u32 = 12;
pub const X13_REG: u32 = 13;
pub const X14_REG: u32 = 14;
pub const X15_REG: u32 = 15;
pub const X16_REG: u32 = 16;
pub const X17_REG: u32 = 17;
pub const X18_REG: u32 = 18;
pub const X19_REG: u32 = 19;
pub const X20_REG: u32 = 20;
pub const X21_REG: u32 = 21;
pub const X22_REG: u32 = 22;
pub const X23_REG: u32 = 23;
pub const X24_REG: u32 = 24;
pub const X25_REG: u32 = 25;
pub const X26_REG: u32 = 26;
pub const X27_REG: u32 = 27;
pub const X28_REG: u32 = 28;
pub const FP_REG: u32 = 29;
pub const LR_REG: u32 = 30;
pub const SP_REG: u32 = 31;
pub const PC_REG: u32 = 32;
pub const SPSR_REG: u32 = 33;
pub const NUM_REGS: u32 = 98;
pub const NUM_FPU_REGS: u32 = 0;
pub const ARCH_NUMREGS: u32 = 98;
pub const SYSCALL_REG: u32 = 0;
pub const PRIuCYCLES: &'static [u8; 3usize] = b"zu\0";
pub const PRIxCYCLES: &'static [u8; 3usize] = b"zx\0";
pub const PRIXCYCLES: &'static [u8; 3usize] = b"zX\0";
pub const NULL_IREF: u32 = 0;
pub const PRIxIREF: &'static [u8; 2usize] = b"x\0";
pub const PRIuIREF: &'static [u8; 2usize] = b"u\0";
pub const PRIuDELAYUS: &'static [u8; 3usize] = b"lu\0";
pub const PRIxDELAYUS: &'static [u8; 3usize] = b"lx\0";
pub const PRIXDELAYUS: &'static [u8; 3usize] = b"lX\0";
pub const PRIxPCIADDR: &'static [u8; 3usize] = b"lx\0";
pub const PRIuPCIADDR: &'static [u8; 3usize] = b"lu\0";
pub const PRIxPCISIZE: &'static [u8; 3usize] = b"lx\0";
pub const PRIuPCISIZE: &'static [u8; 3usize] = b"lu\0";
pub const MAX_CPUS: u32 = 254;
pub const DISP_NAME_LEN: u32 = 16;
pub const __SLBF: u32 = 1;
pub const __SNBF: u32 = 2;
pub const __SRD: u32 = 4;
pub const __SWR: u32 = 8;
pub const __SRW: u32 = 16;
pub const __SEOF: u32 = 32;
pub const __SERR: u32 = 64;
pub const __SMBF: u32 = 128;
pub const __SAPP: u32 = 256;
pub const __SSTR: u32 = 512;
pub const __SOPT: u32 = 1024;
pub const __SNPT: u32 = 2048;
pub const __SOFF: u32 = 4096;
pub const __SMOD: u32 = 8192;
pub const __SALC: u32 = 16384;
pub const __SIGN: u32 = 32768;
pub const __S2OAP: u32 = 1;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 1024;
pub const EOF: i32 = -1;
pub const FOPEN_MAX: u32 = 20;
pub const FILENAME_MAX: u32 = 1024;
pub const P_tmpdir: &'static [u8; 6usize] = b"/tmp/\0";
pub const L_tmpnam: u32 = 1024;
pub const TMP_MAX: u32 = 308915776;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const L_cuserid: u32 = 17;
pub const L_ctermid: u32 = 1024;
pub const DISTCAP_STATE_FOREIGN: u32 = 1;
pub const DISTCAP_STATE_BUSY: u32 = 2;
pub const RRELS_COPY_BIT: u32 = 1;
pub const RRELS_ANCS_BIT: u32 = 2;
pub const RRELS_DESC_BIT: u32 = 4;
pub const ROOTCN_FREE_SLOTS: u32 = 14;
pub const TASKCN_SLOT_SELFEP: u32 = 21;
pub const TASKCN_SLOT_INITEP: u32 = 22;
pub const TASKCN_SLOT_MONITOREP: u32 = 22;
pub const TASKCN_SLOTS_FREE: u32 = 23;
pub const CPTR_ROOTCN: u32 = 2;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const CHARCLASS_NAME_MAX: u32 = 14;
pub const COLL_WEIGHTS_MAX: u32 = 10;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 255;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX2_EQUIV_CLASS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_SS_REPL_MAX: u32 = 4;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_TRACE_EVENT_NAME_MAX: u32 = 30;
pub const _POSIX_TRACE_NAME_MAX: u32 = 8;
pub const _POSIX_TRACE_SYS_MAX: u32 = 8;
pub const _POSIX_TRACE_USER_EVENT_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const NL_ARGMAX: u32 = 99;
pub const NL_MSGMAX: u32 = 32767;
pub const NL_SETMAX: u32 = 255;
pub const NL_TEXTMAX: u32 = 2048;
pub const _XOPEN_IOV_MAX: u32 = 16;
pub const _XOPEN_NAME_MAX: u32 = 255;
pub const _XOPEN_PATH_MAX: u32 = 1024;
pub const PASS_MAX: u32 = 128;
pub const NL_LANGMAX: u32 = 31;
pub const NL_NMAX: u32 = 1;
pub const MB_LEN_MAX: u32 = 6;
pub const THREAD_ONCE_INIT: u32 = 2147483647;
pub const DISPATCHER_STACK_BYTES: u32 = 8192;
pub const THREADS_DEFAULT_STACK_BYTES: u32 = 65536;
pub const PAGING_TYPES_H_: u32 = 1;
pub const VREGION_FLAGS_READ: u32 = 1;
pub const VREGION_FLAGS_WRITE: u32 = 2;
pub const VREGION_FLAGS_EXECUTE: u32 = 4;
pub const VREGION_FLAGS_NOCACHE: u32 = 8;
pub const VREGION_FLAGS_MPB: u32 = 16;
pub const VREGION_FLAGS_GUARD: u32 = 32;
pub const VREGION_FLAGS_MASK: u32 = 47;
pub const VREGION_FLAGS_READ_WRITE: u32 = 3;
pub const VREGION_FLAGS_READ_EXECUTE: u32 = 5;
pub const VREGION_FLAGS_READ_WRITE_NOCACHE: u32 = 11;
pub const VREGION_FLAGS_READ_WRITE_MPB: u32 = 19;
pub const LMP_MSG_LENGTH: u32 = 4;
pub const LRPC_MSG_LENGTH: u32 = 0;
pub const LMP_RECV_HEADER_LENGTH: u32 = 1;
pub const LMP_RECV_LENGTH: u32 = 5;
pub const DEFAULT_LMP_BUF_WORDS: u32 = 10;
pub const AOS_RPC_MAX_FUNCTION_ARGUMENTS: u32 = 8;
pub const UMP_MSG_SIZE: u32 = 64;
pub const UMP_FLAG_SENT: u32 = 1;
pub const UMP_FLAG_RECEIVED: u32 = 0;
pub const AOS_RPC_RETURN_BIT: u32 = 16777216;
pub const AOS_RPC_SHORTSTR_LENGTH: u32 = 32;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __clock_t = __int32_t;
pub type __critical_t = __int64_t;
pub type __double_t = f64;
pub type __float_t = f32;
pub type __intfptr_t = __int64_t;
pub type __intmax_t = __int64_t;
pub type __intptr_t = __int64_t;
pub type __int_fast8_t = __int32_t;
pub type __int_fast16_t = __int32_t;
pub type __int_fast32_t = __int32_t;
pub type __int_fast64_t = __int64_t;
pub type __int_least8_t = __int8_t;
pub type __int_least16_t = __int16_t;
pub type __int_least32_t = __int32_t;
pub type __int_least64_t = __int64_t;
pub type __ptrdiff_t = __int64_t;
pub type __register_t = __int64_t;
pub type __segsz_t = __int64_t;
pub type __size_t = __uint64_t;
pub type __ssize_t = __int64_t;
pub type __time_t = __int64_t;
pub type __uintfptr_t = __uint64_t;
pub type __uintmax_t = __uint64_t;
pub type __uintptr_t = __uint64_t;
pub type __uint_fast8_t = __uint32_t;
pub type __uint_fast16_t = __uint32_t;
pub type __uint_fast32_t = __uint32_t;
pub type __uint_fast64_t = __uint64_t;
pub type __uint_least8_t = __uint8_t;
pub type __uint_least16_t = __uint16_t;
pub type __uint_least32_t = __uint32_t;
pub type __uint_least64_t = __uint64_t;
pub type __u_register_t = __uint64_t;
pub type __vm_offset_t = __uint64_t;
pub type __vm_ooffset_t = __int64_t;
pub type __vm_paddr_t = __uint64_t;
pub type __vm_pindex_t = __uint64_t;
pub type __vm_size_t = __uint64_t;
pub type ___wchar_t = ::std::os::raw::c_uint;
pub type __va_list = __builtin_va_list;
pub type __gnuc_va_list = __va_list;
pub type __blksize_t = __int32_t;
pub type __blkcnt_t = __int64_t;
pub type __clockid_t = __int32_t;
pub type __fflags_t = __uint32_t;
pub type __fsblkcnt_t = __uint64_t;
pub type __fsfilcnt_t = __uint64_t;
pub type __gid_t = __uint32_t;
pub type __id_t = __int64_t;
pub type __ino_t = __uint32_t;
pub type __key_t = ::std::os::raw::c_long;
pub type __lwpid_t = __int32_t;
pub type __mode_t = __uint16_t;
pub type __accmode_t = ::std::os::raw::c_int;
pub type __nl_item = ::std::os::raw::c_int;
pub type __nlink_t = __uint16_t;
pub type __off_t = __int64_t;
pub type __off64_t = __int64_t;
pub type __pid_t = __int32_t;
pub type __rlim_t = __int64_t;
pub type __sa_family_t = __uint8_t;
pub type __socklen_t = __uint32_t;
pub type __suseconds_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __timer {
    _unused: [u8; 0],
}
pub type __timer_t = *mut __timer;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __mq {
    _unused: [u8; 0],
}
pub type __mqd_t = *mut __mq;
pub type __uid_t = __uint32_t;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __cpuwhich_t = ::std::os::raw::c_int;
pub type __cpulevel_t = ::std::os::raw::c_int;
pub type __cpusetid_t = ::std::os::raw::c_int;
pub type __ct_rune_t = ::std::os::raw::c_int;
pub type __rune_t = __ct_rune_t;
pub type __wint_t = __ct_rune_t;
pub type __char16_t = __uint_least16_t;
pub type __char32_t = __uint_least32_t;
pub type __dev_t = __uint32_t;
pub type __fixpt_t = __uint32_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t {
    pub __mbstate8: [::std::os::raw::c_char; 128usize],
    pub _mbstateL: __int64_t,
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        128usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__mbstate8 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__mbstate8)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>()))._mbstateL as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(_mbstateL)
        )
    );
}
pub type __rman_res_t = __uintmax_t;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = __int_fast8_t;
pub type int_fast16_t = __int_fast16_t;
pub type int_fast32_t = __int_fast32_t;
pub type int_fast64_t = __int_fast64_t;
pub type uint_fast8_t = __uint_fast8_t;
pub type uint_fast16_t = __uint_fast16_t;
pub type uint_fast32_t = __uint_fast32_t;
pub type uint_fast64_t = __uint_fast64_t;
pub type rune_t = __rune_t;
pub type size_t = __size_t;
pub type wchar_t = ___wchar_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    assert_eq!(
        ::std::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        ::std::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<div_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<div_t>())).rem as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<ldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(ldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ldiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub static mut __mb_cur_max: ::std::os::raw::c_int;
}
extern "C" {
    pub fn ___mb_cur_max() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn abort();
}
extern "C" {
    pub fn abs(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atexit(arg1: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atof(arg1: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn bsearch(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
        arg3: size_t,
        arg4: size_t,
        arg5: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(
        arg1: ::std::os::raw::c_ulong,
        arg2: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn div(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    pub fn exit(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn free(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn getenv(arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn labs(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn ldiv(arg1: ::std::os::raw::c_long, arg2: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    pub fn malloc(arg1: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn mblen(arg1: *const ::std::os::raw::c_char, arg2: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(
        arg1: *mut wchar_t,
        arg2: *const ::std::os::raw::c_char,
        arg3: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn mbtowc(
        arg1: *mut wchar_t,
        arg2: *const ::std::os::raw::c_char,
        arg3: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qsort(
        arg1: *mut ::std::os::raw::c_void,
        arg2: size_t,
        arg3: size_t,
        arg4: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn realloc(
        arg1: *mut ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn srand(arg1: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn strtod(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtof(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    pub fn strtol(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtold(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> u128;
}
extern "C" {
    pub fn strtoul(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn system(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctomb(arg1: *mut ::std::os::raw::c_char, arg2: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcstombs(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const wchar_t,
        arg3: size_t,
    ) -> size_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lldiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn atoll(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn llabs(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lldiv(arg1: ::std::os::raw::c_longlong, arg2: ::std::os::raw::c_longlong) -> lldiv_t;
}
extern "C" {
    pub fn strtoll(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoull(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _Exit(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn aligned_alloc(arg1: size_t, arg2: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn at_quick_exit(
        arg1: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn quick_exit(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn realpath(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rand_r(arg1: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn posix_memalign(
        arg1: *mut *mut ::std::os::raw::c_void,
        arg2: size_t,
        arg3: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setenv(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unsetenv(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsubopt(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const *mut ::std::os::raw::c_char,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdtemp(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstemp(arg1: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn a64l(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn erand48(arg1: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn grantpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initstate(
        arg1: ::std::os::raw::c_uint,
        arg2: *mut ::std::os::raw::c_char,
        arg3: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn jrand48(arg1: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn l64a(arg1: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn lcong48(arg1: *mut ::std::os::raw::c_ushort);
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mktemp(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(arg1: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn posix_openpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ptsname(arg1: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(arg1: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn seed48(arg1: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn setkey(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setstate(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn srand48(arg1: ::std::os::raw::c_long);
}
extern "C" {
    pub fn srandom(arg1: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn unlockpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut malloc_conf: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut malloc_message: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: *const ::std::os::raw::c_char,
        ),
    >;
}
extern "C" {
    pub fn abort2(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *mut *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn arc4random() -> __uint32_t;
}
extern "C" {
    pub fn arc4random_addrandom(arg1: *mut ::std::os::raw::c_uchar, arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn arc4random_buf(arg1: *mut ::std::os::raw::c_void, arg2: size_t);
}
extern "C" {
    pub fn arc4random_stir();
}
extern "C" {
    pub fn arc4random_uniform(arg1: __uint32_t) -> __uint32_t;
}
extern "C" {
    pub fn getbsize(
        arg1: *mut ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_long,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn cgetcap(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn cgetclose() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetent(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetfirst(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetmatch(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetnext(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetnum(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetset(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetstr(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetustr(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn daemon(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn devname(arg1: __dev_t, arg2: __mode_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn devname_r(
        arg1: __dev_t,
        arg2: __mode_t,
        arg3: *mut ::std::os::raw::c_char,
        arg4: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fdevname(arg1: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fdevname_r(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getloadavg(arg1: *mut f64, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getprogname() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn heapsort(
        arg1: *mut ::std::os::raw::c_void,
        arg2: size_t,
        arg3: size_t,
        arg4: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn l64a_r(
        arg1: ::std::os::raw::c_long,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mergesort(
        arg1: *mut ::std::os::raw::c_void,
        arg2: size_t,
        arg3: size_t,
        arg4: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkostemp(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkostemps(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qsort_r(
        arg1: *mut ::std::os::raw::c_void,
        arg2: size_t,
        arg3: size_t,
        arg4: *mut ::std::os::raw::c_void,
        arg5: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
                arg3: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn radixsort(
        arg1: *mut *const ::std::os::raw::c_uchar,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_uchar,
        arg4: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn reallocarray(
        arg1: *mut ::std::os::raw::c_void,
        arg2: size_t,
        arg3: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn reallocf(arg1: *mut ::std::os::raw::c_void, arg2: size_t)
        -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn rpmatch(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setprogname(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn sradixsort(
        arg1: *mut *const ::std::os::raw::c_uchar,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_uchar,
        arg4: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sranddev();
}
extern "C" {
    pub fn srandomdev();
}
extern "C" {
    pub fn strtonum(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_longlong,
        arg3: ::std::os::raw::c_longlong,
        arg4: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoq(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> __int64_t;
}
extern "C" {
    pub fn strtouq(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> __uint64_t;
}
extern "C" {
    pub static mut suboptarg: *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __assert(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_attr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_cond {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_cond_attr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_mutex {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_mutex_attr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_rwlock {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_rwlockattr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_barrier {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_barrier_attr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_spinlock {
    _unused: [u8; 0],
}
pub type pthread_t = *mut pthread;
pub type pthread_attr_t = *mut pthread_attr;
pub type pthread_mutex_t = *mut pthread_mutex;
pub type pthread_mutexattr_t = *mut pthread_mutex_attr;
pub type pthread_cond_t = *mut pthread_cond;
pub type pthread_condattr_t = *mut pthread_cond_attr;
pub type pthread_key_t = ::std::os::raw::c_int;
pub type pthread_once_t = pthread_once;
pub type pthread_rwlock_t = *mut pthread_rwlock;
pub type pthread_rwlockattr_t = *mut pthread_rwlockattr;
pub type pthread_barrier_t = pthread_barrier;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_barrierattr {
    _unused: [u8; 0],
}
pub type pthread_barrierattr_t = *mut pthread_barrierattr;
pub type pthread_spinlock_t = *mut pthread_spinlock;
pub type pthread_addr_t = *mut ::std::os::raw::c_void;
pub type pthread_startroutine_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_once {
    pub state: ::std::os::raw::c_int,
    pub mutex: pthread_mutex_t,
}
#[test]
fn bindgen_test_layout_pthread_once() {
    assert_eq!(
        ::std::mem::size_of::<pthread_once>(),
        16usize,
        concat!("Size of: ", stringify!(pthread_once))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_once>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_once))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_once>())).state as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_once),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_once>())).mutex as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_once),
            "::",
            stringify!(mutex)
        )
    );
}
pub type u_char = ::std::os::raw::c_uchar;
pub type u_short = ::std::os::raw::c_ushort;
pub type u_int = ::std::os::raw::c_uint;
pub type u_long = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type u_quad_t = __uint64_t;
pub type quad_t = __int64_t;
pub type qaddr_t = *mut quad_t;
pub type caddr_t = *mut ::std::os::raw::c_char;
pub type c_caddr_t = *const ::std::os::raw::c_char;
pub type blksize_t = __blksize_t;
pub type cpuwhich_t = __cpuwhich_t;
pub type cpulevel_t = __cpulevel_t;
pub type cpusetid_t = __cpusetid_t;
pub type blkcnt_t = __blkcnt_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type critical_t = __critical_t;
pub type daddr_t = __int64_t;
pub type dev_t = __dev_t;
pub type fflags_t = __fflags_t;
pub type fixpt_t = __fixpt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
pub type gid_t = __gid_t;
pub type in_addr_t = __uint32_t;
pub type in_port_t = __uint16_t;
pub type id_t = __id_t;
pub type ino_t = __ino_t;
pub type key_t = __key_t;
pub type lwpid_t = __lwpid_t;
pub type mode_t = __mode_t;
pub type accmode_t = __accmode_t;
pub type nlink_t = __nlink_t;
pub type off_t = __off_t;
pub type off64_t = __off64_t;
pub type pid_t = __pid_t;
pub type register_t = __register_t;
pub type rlim_t = __rlim_t;
pub type sbintime_t = __int64_t;
pub type segsz_t = __segsz_t;
pub type ssize_t = __ssize_t;
pub type suseconds_t = __suseconds_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type mqd_t = __mqd_t;
pub type u_register_t = __u_register_t;
pub type uid_t = __uid_t;
pub type useconds_t = __useconds_t;
pub type cap_ioctl_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cap_rights {
    _unused: [u8; 0],
}
pub type cap_rights_t = cap_rights;
pub type vm_offset_t = __vm_offset_t;
pub type vm_ooffset_t = __vm_ooffset_t;
pub type vm_paddr_t = __vm_paddr_t;
pub type vm_pindex_t = __vm_pindex_t;
pub type vm_size_t = __vm_size_t;
pub type rman_res_t = __rman_res_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset {
    pub __bits: [__uint32_t; 4usize],
}
#[test]
fn bindgen_test_layout___sigset() {
    assert_eq!(
        ::std::mem::size_of::<__sigset>(),
        16usize,
        concat!("Size of: ", stringify!(__sigset))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigset>(),
        4usize,
        concat!("Alignment of ", stringify!(__sigset))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sigset>())).__bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigset),
            "::",
            stringify!(__bits)
        )
    );
}
pub type __sigset_t = __sigset;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: time_t,
    pub tv_usec: suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_usec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: time_t,
    pub tv_nsec: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[test]
fn bindgen_test_layout_itimerspec() {
    assert_eq!(
        ::std::mem::size_of::<itimerspec>(),
        32usize,
        concat!("Size of: ", stringify!(itimerspec))
    );
    assert_eq!(
        ::std::mem::align_of::<itimerspec>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerspec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<itimerspec>())).it_interval as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<itimerspec>())).it_value as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_value)
        )
    );
}
pub type __fd_mask = ::std::os::raw::c_ulong;
pub type fd_mask = __fd_mask;
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fd_set>())).__fds_bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(__fds_bits)
        )
    );
}
extern "C" {
    pub fn pselect(
        arg1: ::std::os::raw::c_int,
        arg2: *mut fd_set,
        arg3: *mut fd_set,
        arg4: *mut fd_set,
        arg5: *const timespec,
        arg6: *const sigset_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn select(
        arg1: ::std::os::raw::c_int,
        arg2: *mut fd_set,
        arg3: *mut fd_set,
        arg4: *mut fd_set,
        arg5: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftruncate(arg1: ::std::os::raw::c_int, arg2: off_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lseek(arg1: ::std::os::raw::c_int, arg2: off_t, arg3: ::std::os::raw::c_int) -> off_t;
}
extern "C" {
    pub fn mmap(
        arg1: *mut ::std::os::raw::c_void,
        arg2: size_t,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_int,
        arg6: off_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn truncate(arg1: *const ::std::os::raw::c_char, arg2: off_t) -> ::std::os::raw::c_int;
}
pub type errval_t = usize;
pub const err_code_SYS_ERR_OK: err_code = 0;
pub const err_code_SYS_ERR_NOT_IMPLEMENTED: err_code = 5;
pub const err_code_SYS_ERR_ILLEGAL_SYSCALL: err_code = 6;
pub const err_code_SYS_ERR_INVARGS_SYSCALL: err_code = 7;
pub const err_code_SYS_ERR_CALLER_ENABLED: err_code = 8;
pub const err_code_SYS_ERR_CALLER_DISABLED: err_code = 9;
pub const err_code_SYS_ERR_ILLEGAL_INVOCATION: err_code = 10;
pub const err_code_SYS_ERR_INVALID_USER_BUFFER: err_code = 11;
pub const err_code_SYS_ERR_LMP_NO_TARGET: err_code = 12;
pub const err_code_SYS_ERR_LMP_TARGET_DISABLED: err_code = 13;
pub const err_code_SYS_ERR_LMP_BUF_OVERFLOW: err_code = 14;
pub const err_code_SYS_ERR_LMP_EP_STATE_INVALID: err_code = 15;
pub const err_code_SYS_ERR_LMP_CAPTRANSFER_SRC_LOOKUP: err_code = 16;
pub const err_code_SYS_ERR_LMP_CAPTRANSFER_DST_CNODE_LOOKUP: err_code = 17;
pub const err_code_SYS_ERR_LMP_CAPTRANSFER_DST_CNODE_INVALID: err_code = 18;
pub const err_code_SYS_ERR_LMP_CAPTRANSFER_DST_SLOT_OCCUPIED: err_code = 19;
pub const err_code_SYS_ERR_LRPC_SLOT_INVALID: err_code = 20;
pub const err_code_SYS_ERR_LRPC_NOT_L1: err_code = 21;
pub const err_code_SYS_ERR_LRPC_NOT_L2: err_code = 22;
pub const err_code_SYS_ERR_LRPC_NOT_ENDPOINT: err_code = 23;
pub const err_code_SYS_ERR_INVALID_EPLEN: err_code = 24;
pub const err_code_SYS_ERR_IDC_MSG_BOUNDS: err_code = 25;
pub const err_code_SYS_ERR_CNODE_NOT_FOUND: err_code = 26;
pub const err_code_SYS_ERR_CNODE_TYPE: err_code = 27;
pub const err_code_SYS_ERR_CNODE_RIGHTS: err_code = 28;
pub const err_code_SYS_ERR_DEPTH_EXCEEDED: err_code = 29;
pub const err_code_SYS_ERR_GUARD_MISMATCH: err_code = 30;
pub const err_code_SYS_ERR_CAP_NOT_FOUND: err_code = 31;
pub const err_code_SYS_ERR_IDENTIFY_LOOKUP: err_code = 32;
pub const err_code_SYS_ERR_L1_CNODE_INDEX: err_code = 33;
pub const err_code_SYS_ERR_CAP_LOOKUP_DEPTH: err_code = 34;
pub const err_code_SYS_ERR_RESIZE_NOT_L1: err_code = 35;
pub const err_code_SYS_ERR_SLOT_IN_USE: err_code = 36;
pub const err_code_SYS_ERR_SLOT_LOOKUP_FAIL: err_code = 37;
pub const err_code_SYS_ERR_CNODE_NOT_ROOT: err_code = 38;
pub const err_code_SYS_ERR_GUARD_SIZE_OVERFLOW: err_code = 39;
pub const err_code_SYS_ERR_INVALID_SOURCE_TYPE: err_code = 40;
pub const err_code_SYS_ERR_ILLEGAL_DEST_TYPE: err_code = 41;
pub const err_code_SYS_ERR_SOURCE_CAP_LOOKUP: err_code = 42;
pub const err_code_SYS_ERR_SOURCE_ROOTCN_LOOKUP: err_code = 43;
pub const err_code_SYS_ERR_DEST_CNODE_LOOKUP: err_code = 44;
pub const err_code_SYS_ERR_DEST_ROOTCN_LOOKUP: err_code = 45;
pub const err_code_SYS_ERR_DEST_CNODE_INVALID: err_code = 46;
pub const err_code_SYS_ERR_ROOT_CAP_LOOKUP: err_code = 47;
pub const err_code_SYS_ERR_DEST_TYPE_INVALID: err_code = 48;
pub const err_code_SYS_ERR_INVALID_RETYPE: err_code = 49;
pub const err_code_SYS_ERR_RETYPE_MAPPING_EXPLICIT: err_code = 50;
pub const err_code_SYS_ERR_RETYPE_INVALID_COUNT: err_code = 51;
pub const err_code_SYS_ERR_REVOKE_FIRST: err_code = 52;
pub const err_code_SYS_ERR_INVALID_SIZE_BITS: err_code = 53;
pub const err_code_SYS_ERR_INVALID_SIZE: err_code = 54;
pub const err_code_SYS_ERR_SLOTS_INVALID: err_code = 55;
pub const err_code_SYS_ERR_SLOTS_IN_USE: err_code = 56;
pub const err_code_SYS_ERR_RETYPE_CREATE: err_code = 57;
pub const err_code_SYS_ERR_RETYPE_INVALID_OFFSET: err_code = 58;
pub const err_code_SYS_ERR_RETYPE_INVALID_OBJSIZE: err_code = 59;
pub const err_code_SYS_ERR_NO_LOCAL_COPIES: err_code = 60;
pub const err_code_SYS_ERR_RETRY_THROUGH_MONITOR: err_code = 61;
pub const err_code_SYS_ERR_TYPE_NOT_CREATABLE: err_code = 62;
pub const err_code_SYS_ERR_DEST_CAP_RIGHTS: err_code = 63;
pub const err_code_SYS_ERR_DELETE_LAST_OWNED: err_code = 64;
pub const err_code_SYS_ERR_DELETE_REMOTE_LOCAL: err_code = 65;
pub const err_code_SYS_ERR_CAP_LOCKED: err_code = 66;
pub const err_code_SYS_ERR_RAM_CAP_CREATED: err_code = 1;
pub const err_code_SYS_ERR_VNODE_SLOT_INVALID: err_code = 67;
pub const err_code_SYS_ERR_WRONG_MAPPING: err_code = 68;
pub const err_code_SYS_ERR_FRAME_OFFSET_INVALID: err_code = 69;
pub const err_code_SYS_ERR_VNODE_SLOT_RESERVED: err_code = 70;
pub const err_code_SYS_ERR_VNODE_SLOT_INUSE: err_code = 71;
pub const err_code_SYS_ERR_VNODE_TYPE: err_code = 72;
pub const err_code_SYS_ERR_VNODE_LOOKUP_NEXT: err_code = 73;
pub const err_code_SYS_ERR_VNODE_NOT_INSTALLED: err_code = 74;
pub const err_code_SYS_ERR_VM_ALREADY_MAPPED: err_code = 75;
pub const err_code_SYS_ERR_VM_MAP_SIZE: err_code = 76;
pub const err_code_SYS_ERR_VM_MAP_OFFSET: err_code = 77;
pub const err_code_SYS_ERR_VM_MAP_RIGHTS: err_code = 78;
pub const err_code_SYS_ERR_VM_RETRY_SINGLE: err_code = 79;
pub const err_code_SYS_ERR_VM_FRAME_UNALIGNED: err_code = 80;
pub const err_code_SYS_ERR_VM_FRAME_TOO_SMALL: err_code = 81;
pub const err_code_SYS_ERR_IRQ_LOOKUP: err_code = 82;
pub const err_code_SYS_ERR_IRQ_NOT_ENDPOINT: err_code = 83;
pub const err_code_SYS_ERR_IRQ_NO_LISTENER: err_code = 84;
pub const err_code_SYS_ERR_IRQ_INVALID: err_code = 85;
pub const err_code_SYS_ERR_IRQ_NO_FREE_VECTOR: err_code = 86;
pub const err_code_SYS_ERR_IRQ_LOOKUP_DEST: err_code = 87;
pub const err_code_SYS_ERR_IRQ_LOOKUP_EP: err_code = 88;
pub const err_code_SYS_ERR_IRQ_NOT_IRQ_TYPE: err_code = 89;
pub const err_code_SYS_ERR_IRQ_WRONG_CONTROLLER: err_code = 90;
pub const err_code_SYS_ERR_IRQ_NO_ARG: err_code = 91;
pub const err_code_SYS_ERR_IO_PORT_INVALID: err_code = 92;
pub const err_code_SYS_ERR_DISP_CSPACE_ROOT: err_code = 93;
pub const err_code_SYS_ERR_DISP_CSPACE_INVALID: err_code = 94;
pub const err_code_SYS_ERR_DISP_VSPACE_ROOT: err_code = 95;
pub const err_code_SYS_ERR_DISP_VSPACE_INVALID: err_code = 96;
pub const err_code_SYS_ERR_DISP_FRAME: err_code = 97;
pub const err_code_SYS_ERR_DISP_FRAME_INVALID: err_code = 98;
pub const err_code_SYS_ERR_DISP_FRAME_SIZE: err_code = 99;
pub const err_code_SYS_ERR_DISP_NOT_RUNNABLE: err_code = 100;
pub const err_code_SYS_ERR_DISP_CAP_LOOKUP: err_code = 101;
pub const err_code_SYS_ERR_DISP_CAP_INVALID: err_code = 102;
pub const err_code_SYS_ERR_KERNEL_MEM_LOOKUP: err_code = 103;
pub const err_code_SYS_ERR_KERNEL_MEM_INVALID: err_code = 104;
pub const err_code_SYS_ERR_CORE_NOT_FOUND: err_code = 105;
pub const err_code_SYS_ERR_ARCHITECTURE_NOT_SUPPORTED: err_code = 106;
pub const err_code_SYS_ERR_INVALID_YIELD_TARGET: err_code = 107;
pub const err_code_SYS_ERR_DISP_OCAP_LOOKUP: err_code = 108;
pub const err_code_SYS_ERR_DISP_OCAP_TYPE: err_code = 109;
pub const err_code_SYS_ERR_VMKIT_UNAVAIL: err_code = 110;
pub const err_code_SYS_ERR_VMKIT_VMCB: err_code = 111;
pub const err_code_SYS_ERR_VMKIT_VMCB_INVALID: err_code = 112;
pub const err_code_SYS_ERR_VMKIT_CTRL: err_code = 113;
pub const err_code_SYS_ERR_VMKIT_CTRL_INVALID: err_code = 114;
pub const err_code_SYS_ERR_VMKIT_ENDPOINT: err_code = 115;
pub const err_code_SYS_ERR_VMKIT_ENDPOINT_INVALID: err_code = 116;
pub const err_code_SYS_ERR_VMKIT_VMX_VMFAIL_INVALID: err_code = 117;
pub const err_code_SYS_ERR_VMKIT_VMX_VMFAIL_VALID: err_code = 118;
pub const err_code_SYS_ERR_SERIAL_PORT_INVALID: err_code = 119;
pub const err_code_SYS_ERR_SERIAL_PORT_UNAVAILABLE: err_code = 120;
pub const err_code_SYS_ERR_PERFMON_NOT_AVAILABLE: err_code = 121;
pub const err_code_SYS_ERR_SYNC_MISS: err_code = 122;
pub const err_code_SYS_ERR_ID_SPACE_EXHAUSTED: err_code = 123;
pub const err_code_SYS_ERR_DOMAIN_SPACE_EXHAUSTED: err_code = 124;
pub const err_code_SYS_ERR_I2C_UNINITIALIZED: err_code = 125;
pub const err_code_SYS_ERR_I2C_ZERO_LENGTH_MSG: err_code = 126;
pub const err_code_SYS_ERR_I2C_WAIT_FOR_BUS: err_code = 127;
pub const err_code_SYS_ERR_I2C_FAILURE: err_code = 128;
pub const err_code_SYS_ERR_KCB_NOT_FOUND: err_code = 129;
pub const err_code_CAPS_ERR_INVALID_ARGS: err_code = 130;
pub const err_code_CAPS_ERR_MDB_ALREADY_INITIALIZED: err_code = 131;
pub const err_code_CAPS_ERR_MDB_INVALID_STATE: err_code = 132;
pub const err_code_CAPS_ERR_MDB_INVARIANT_VIOLATION: err_code = 133;
pub const err_code_CAPS_ERR_MDB_DUPLICATE_ENTRY: err_code = 134;
pub const err_code_CAPS_ERR_MDB_ENTRY_NOTFOUND: err_code = 135;
pub const err_code_CAPS_ERR_CAP_NOT_FOUND: err_code = 136;
pub const err_code_LIB_ERR_WHILE_DELETING: err_code = 137;
pub const err_code_LIB_ERR_WHILE_FREEING_SLOT: err_code = 138;
pub const err_code_LIB_ERR_MALLOC_FAIL: err_code = 139;
pub const err_code_LIB_ERR_SLAB_ALLOC_FAIL: err_code = 140;
pub const err_code_LIB_ERR_SLAB_REFILL: err_code = 141;
pub const err_code_LIB_ERR_NOT_IMPLEMENTED: err_code = 142;
pub const err_code_LIB_ERR_SHOULD_NOT_GET_HERE: err_code = 143;
pub const err_code_LIB_ERR_NOT_CNODE: err_code = 144;
pub const err_code_LIB_ERR_STRING_TOO_LONG: err_code = 145;
pub const err_code_LIB_ERR_CNODE_TYPE: err_code = 146;
pub const err_code_LIB_ERR_CNODE_SLOTS: err_code = 147;
pub const err_code_LIB_ERR_CROOT_NULL: err_code = 148;
pub const err_code_LIB_ERR_FRAME_ALLOC: err_code = 149;
pub const err_code_LIB_ERR_FRAME_CREATE: err_code = 150;
pub const err_code_LIB_ERR_FRAME_CREATE_MS_CONSTRAINTS: err_code = 151;
pub const err_code_LIB_ERR_VNODE_CREATE: err_code = 152;
pub const err_code_LIB_ERR_CNODE_CREATE: err_code = 153;
pub const err_code_LIB_ERR_CNODE_CREATE_FROM_MEM: err_code = 154;
pub const err_code_LIB_ERR_CNODE_CREATE_FOREIGN_L2: err_code = 155;
pub const err_code_LIB_ERR_RAM_ALLOC: err_code = 156;
pub const err_code_LIB_ERR_RAM_ALLOC_WRONG_SIZE: err_code = 157;
pub const err_code_LIB_ERR_RAM_ALLOC_MS_CONSTRAINTS: err_code = 158;
pub const err_code_LIB_ERR_RAM_ALLOC_FIXED_EXHAUSTED: err_code = 159;
pub const err_code_LIB_ERR_CAP_MINT: err_code = 160;
pub const err_code_LIB_ERR_CAP_COPY: err_code = 161;
pub const err_code_LIB_ERR_CAP_RETYPE: err_code = 162;
pub const err_code_LIB_ERR_DEVFRAME_TYPE: err_code = 163;
pub const err_code_LIB_ERR_CAP_DELETE: err_code = 164;
pub const err_code_LIB_ERR_CAP_DESTROY: err_code = 165;
pub const err_code_LIB_ERR_CAP_INVOKE: err_code = 166;
pub const err_code_LIB_ERR_CAP_IDENTIFY: err_code = 167;
pub const err_code_LIB_ERR_CAP_NOT_MAPPABLE: err_code = 168;
pub const err_code_LIB_ERR_ENDPOINT_CREATE: err_code = 169;
pub const err_code_LIB_ERR_FRAME_IDENTIFY: err_code = 170;
pub const err_code_LIB_ERR_VNODE_MAP: err_code = 171;
pub const err_code_LIB_ERR_VNODE_UNMAP: err_code = 172;
pub const err_code_LIB_ERR_IDC_ENDPOINT_ALLOC: err_code = 173;
pub const err_code_LIB_ERR_REMOTE_REVOKE: err_code = 174;
pub const err_code_LIB_ERR_REMOTE_RETYPE: err_code = 175;
pub const err_code_LIB_ERR_REMOTE_DELETE: err_code = 176;
pub const err_code_LIB_ERR_SLOT_ALLOC_INIT: err_code = 177;
pub const err_code_LIB_ERR_SLOT_ALLOC_NO_SPACE: err_code = 178;
pub const err_code_LIB_ERR_SLOT_ALLOC_WRONG_CNODE: err_code = 179;
pub const err_code_LIB_ERR_SINGLE_SLOT_ALLOC_INIT_RAW: err_code = 180;
pub const err_code_LIB_ERR_SINGLE_SLOT_ALLOC_INIT: err_code = 181;
pub const err_code_LIB_ERR_MULTI_SLOT_ALLOC_INIT: err_code = 182;
pub const err_code_LIB_ERR_MULTI_SLOT_ALLOC_INIT_RAW: err_code = 183;
pub const err_code_LIB_ERR_SINGLE_SLOT_ALLOC: err_code = 184;
pub const err_code_LIB_ERR_RANGE_ALLOC_NOT_HEAD: err_code = 185;
pub const err_code_LIB_ERR_SLOT_ALLOC: err_code = 186;
pub const err_code_LIB_ERR_SLOT_FREE: err_code = 187;
pub const err_code_LIB_ERR_SLOT_UNALLOCATED: err_code = 188;
pub const err_code_LIB_ERR_ROOTSA_RESIZE: err_code = 189;
pub const err_code_LIB_ERR_VSPACE_CURRENT_INIT: err_code = 190;
pub const err_code_LIB_ERR_VSPACE_INIT: err_code = 191;
pub const err_code_LIB_ERR_VSPACE_LAYOUT_INIT: err_code = 192;
pub const err_code_LIB_ERR_VSPACE_DESTROY: err_code = 193;
pub const err_code_LIB_ERR_VSPACE_REGION_OVERLAP: err_code = 194;
pub const err_code_LIB_ERR_VSPACE_ADD_REGION: err_code = 195;
pub const err_code_LIB_ERR_VSPACE_REMOVE_REGION: err_code = 196;
pub const err_code_LIB_ERR_VSPACE_PAGEFAULT_HANDER: err_code = 197;
pub const err_code_LIB_ERR_VSPACE_VREGION_NOT_FOUND: err_code = 198;
pub const err_code_LIB_ERR_VSPACE_PAGEFAULT_ADDR_NOT_FOUND: err_code = 199;
pub const err_code_LIB_ERR_VSPACE_PINNED_INIT: err_code = 200;
pub const err_code_LIB_ERR_VSPACE_PINNED_ALLOC: err_code = 201;
pub const err_code_LIB_ERR_VSPACE_PINNED_INVALID_TYPE: err_code = 202;
pub const err_code_LIB_ERR_VREGION_MAP: err_code = 203;
pub const err_code_LIB_ERR_VREGION_MAP_FIXED: err_code = 204;
pub const err_code_LIB_ERR_VREGION_NOT_FOUND: err_code = 205;
pub const err_code_LIB_ERR_VREGION_DESTROY: err_code = 206;
pub const err_code_LIB_ERR_VREGION_PAGEFAULT_HANDLER: err_code = 207;
pub const err_code_LIB_ERR_VREGION_BAD_ALIGNMENT: err_code = 208;
pub const err_code_LIB_ERR_MEMOBJ_CREATE_ANON: err_code = 209;
pub const err_code_LIB_ERR_MEMOBJ_CREATE_ONE_FRAME: err_code = 210;
pub const err_code_LIB_ERR_MEMOBJ_CREATE_ONE_FRAME_ONE_MAP: err_code = 211;
pub const err_code_LIB_ERR_MEMOBJ_CREATE_PINNED: err_code = 212;
pub const err_code_LIB_ERR_MEMOBJ_CREATE_VFS: err_code = 213;
pub const err_code_LIB_ERR_MEMOBJ_MAP_REGION: err_code = 214;
pub const err_code_LIB_ERR_MEMOBJ_UNMAP_REGION: err_code = 215;
pub const err_code_LIB_ERR_MEMOBJ_PIN_REGION: err_code = 216;
pub const err_code_LIB_ERR_MEMOBJ_UNPIN_REGION: err_code = 217;
pub const err_code_LIB_ERR_MEMOBJ_FILL: err_code = 218;
pub const err_code_LIB_ERR_MEMOBJ_PAGEFAULT_HANDLER: err_code = 219;
pub const err_code_LIB_ERR_MEMOBJ_PAGER_FREE: err_code = 220;
pub const err_code_LIB_ERR_MEMOBJ_WRONG_OFFSET: err_code = 221;
pub const err_code_LIB_ERR_MEMOBJ_FRAME_ALLOC: err_code = 222;
pub const err_code_LIB_ERR_MEMOBJ_VREGION_ALREADY_MAPPED: err_code = 223;
pub const err_code_LIB_ERR_MEMOBJ_UNFILL_TOO_HIGH_OFFSET: err_code = 224;
pub const err_code_LIB_ERR_MEMOBJ_PROTECT: err_code = 225;
pub const err_code_LIB_ERR_MEMOBJ_DUPLICATE_FILL: err_code = 226;
pub const err_code_LIB_ERR_PMAP_INIT: err_code = 227;
pub const err_code_LIB_ERR_PMAP_CURRENT_INIT: err_code = 228;
pub const err_code_LIB_ERR_PMAP_DETERMINE_ADDR: err_code = 229;
pub const err_code_LIB_ERR_PMAP_DO_MAP: err_code = 230;
pub const err_code_LIB_ERR_PMAP_MAP: err_code = 231;
pub const err_code_LIB_ERR_PMAP_DO_SINGLE_MAP: err_code = 232;
pub const err_code_LIB_ERR_PMAP_UNMAP: err_code = 233;
pub const err_code_LIB_ERR_PMAP_DO_SINGLE_UNMAP: err_code = 234;
pub const err_code_LIB_ERR_PMAP_MODIFY_FLAGS: err_code = 235;
pub const err_code_LIB_ERR_PMAP_GET_PTABLE: err_code = 236;
pub const err_code_LIB_ERR_PMAP_ALLOC_VNODE: err_code = 237;
pub const err_code_LIB_ERR_PMAP_CLONE_VNODE: err_code = 238;
pub const err_code_LIB_ERR_PMAP_ADDR_NOT_FREE: err_code = 239;
pub const err_code_LIB_ERR_PMAP_FIND_VNODE: err_code = 240;
pub const err_code_LIB_ERR_PMAP_NO_VNODE_BUT_SUPERPAGE: err_code = 241;
pub const err_code_LIB_ERR_PMAP_SHADOWPT_LOOKUP: err_code = 242;
pub const err_code_LIB_ERR_PMAP_EXISTING_MAPPING: err_code = 243;
pub const err_code_LIB_ERR_PMAP_FRAME_SIZE: err_code = 244;
pub const err_code_LIB_ERR_PMAP_FRAME_IDENTIFY: err_code = 245;
pub const err_code_LIB_ERR_PMAP_NOT_MAPPED: err_code = 246;
pub const err_code_LIB_ERR_PMAP_ALLOC_CNODE: err_code = 247;
pub const err_code_LIB_ERR_OUT_OF_VIRTUAL_ADDR: err_code = 248;
pub const err_code_LIB_ERR_SERIALISE_BUFOVERFLOW: err_code = 249;
pub const err_code_LIB_ERR_VSPACE_MAP: err_code = 250;
pub const err_code_LIB_ERR_VSPACE_MMU_AWARE_INIT: err_code = 251;
pub const err_code_LIB_ERR_VSPACE_MMU_AWARE_MAP: err_code = 252;
pub const err_code_LIB_ERR_VSPACE_MMU_AWARE_NO_SPACE: err_code = 253;
pub const err_code_LIB_ERR_INVOKE_PERFMON_SETUP: err_code = 254;
pub const err_code_LIB_ERR_INVOKE_PERFMON_WRITE: err_code = 255;
pub const err_code_LIB_ERR_CORESET_NEW: err_code = 256;
pub const err_code_LIB_ERR_CORESET_GET_NEXT_DONE: err_code = 257;
pub const err_code_LIB_ERR_NO_LMP_MSG: err_code = 258;
pub const err_code_LIB_ERR_LMP_RECV_BUF_OVERFLOW: err_code = 259;
pub const err_code_LIB_ERR_NO_UMP_MSG: err_code = 260;
pub const err_code_LIB_ERR_UMP_CHAN_FULL: err_code = 261;
pub const err_code_LIB_ERR_LMP_BUFLEN_INVALID: err_code = 262;
pub const err_code_LIB_ERR_NO_ENDPOINT_SPACE: err_code = 263;
pub const err_code_LIB_ERR_UMP_BUFSIZE_INVALID: err_code = 264;
pub const err_code_LIB_ERR_UMP_BUFADDR_INVALID: err_code = 265;
pub const err_code_LIB_ERR_UMP_FRAME_OVERFLOW: err_code = 266;
pub const err_code_LIB_ERR_LMP_ENDPOINT_REGISTER: err_code = 267;
pub const err_code_LIB_ERR_CHAN_REGISTER_SEND: err_code = 268;
pub const err_code_LIB_ERR_CHAN_DEREGISTER_SEND: err_code = 269;
pub const err_code_LIB_ERR_CHAN_REGISTER_RECV: err_code = 270;
pub const err_code_LIB_ERR_CHAN_DEREGISTER_RECV: err_code = 271;
pub const err_code_LIB_ERR_LMP_CHAN_INIT: err_code = 272;
pub const err_code_LIB_ERR_UMP_CHAN_INIT: err_code = 273;
pub const err_code_LIB_ERR_LMP_CHAN_RECV: err_code = 274;
pub const err_code_LIB_ERR_UMP_CHAN_RECV: err_code = 275;
pub const err_code_LIB_ERR_LMP_CHAN_SEND: err_code = 276;
pub const err_code_LIB_ERR_LMP_CHAN_BIND: err_code = 277;
pub const err_code_LIB_ERR_UMP_CHAN_BIND: err_code = 278;
pub const err_code_LIB_ERR_LMP_CHAN_ACCEPT: err_code = 279;
pub const err_code_LIB_ERR_UMP_CHAN_ACCEPT: err_code = 280;
pub const err_code_LIB_ERR_LMP_ALLOC_RECV_SLOT: err_code = 281;
pub const err_code_LIB_ERR_LMP_NOT_CONNECTED: err_code = 282;
pub const err_code_LIB_ERR_MSGBUF_OVERFLOW: err_code = 283;
pub const err_code_LIB_ERR_MSGBUF_CANNOT_GROW: err_code = 284;
pub const err_code_LIB_ERR_RCK_NOTIFY: err_code = 285;
pub const err_code_LIB_ERR_IPI_NOTIFY: err_code = 286;
pub const err_code_LIB_ERR_MONITOR_CLIENT_BIND: err_code = 287;
pub const err_code_LIB_ERR_MONITOR_CLIENT_ACCEPT: err_code = 288;
pub const err_code_LIB_ERR_NAMESERVICE_NOT_BOUND: err_code = 289;
pub const err_code_LIB_ERR_NAMESERVICE_UNKNOWN_NAME: err_code = 290;
pub const err_code_LIB_ERR_NAMESERVICE_INVALID_NAME: err_code = 291;
pub const err_code_LIB_ERR_BIND_LMP_REQ: err_code = 292;
pub const err_code_LIB_ERR_BIND_UMP_REQ: err_code = 293;
pub const err_code_LIB_ERR_BIND_LMP_REPLY: err_code = 294;
pub const err_code_LIB_ERR_BIND_UMP_REPLY: err_code = 295;
pub const err_code_LIB_ERR_NO_LMP_BIND_HANDLER: err_code = 296;
pub const err_code_LIB_ERR_NO_UMP_BIND_HANDLER: err_code = 297;
pub const err_code_LIB_ERR_MONITOR_CAP_SEND: err_code = 298;
pub const err_code_LIB_ERR_MONITOR_RPC_BIND: err_code = 299;
pub const err_code_LIB_ERR_MONITOR_RPC_NULL: err_code = 300;
pub const err_code_LIB_ERR_BIND_MULTIHOP_REQ: err_code = 301;
pub const err_code_LIB_ERR_NO_MULTIHOP_BIND_HANDLER: err_code = 302;
pub const err_code_LIB_ERR_BIND_MULTIHOP_SAME_CORE: err_code = 303;
pub const err_code_LIB_ERR_BULK_UNKNOWN_ID: err_code = 304;
pub const err_code_LIB_ERR_NO_SPANNED_DISP: err_code = 305;
pub const err_code_LIB_ERR_SEND_RUN_FUNC_REQUEST: err_code = 306;
pub const err_code_LIB_ERR_SEND_CAP_REQUEST: err_code = 307;
pub const err_code_LIB_ERR_CAP_COPY_FAIL: err_code = 308;
pub const err_code_LIB_ERR_CAP_DELETE_FAIL: err_code = 309;
pub const err_code_LIB_ERR_RAM_ALLOC_SET: err_code = 310;
pub const err_code_LIB_ERR_MORECORE_INIT: err_code = 311;
pub const err_code_LIB_ERR_MONITOR_CLIENT_INIT: err_code = 312;
pub const err_code_LIB_ERR_MONITOR_CLIENT_CONNECT: err_code = 313;
pub const err_code_LIB_ERR_TERMINAL_INIT: err_code = 314;
pub const err_code_LIB_ERR_DOMAIN_INIT: err_code = 315;
pub const err_code_LIB_ERR_GET_MON_BLOCKING_IREF: err_code = 316;
pub const err_code_LIB_ERR_GET_MEM_IREF: err_code = 317;
pub const err_code_LIB_ERR_GET_NAME_IREF: err_code = 318;
pub const err_code_LIB_ERR_GET_RAMFS_IREF: err_code = 319;
pub const err_code_LIB_ERR_NAMESERVICE_CLIENT_INIT: err_code = 320;
pub const err_code_LIB_ERR_THREAD_CREATE: err_code = 321;
pub const err_code_LIB_ERR_THREAD_JOIN: err_code = 322;
pub const err_code_LIB_ERR_THREAD_JOIN_DETACHED: err_code = 323;
pub const err_code_LIB_ERR_THREAD_DETACHED: err_code = 324;
pub const err_code_LIB_ERR_CHAN_ALREADY_REGISTERED: err_code = 325;
pub const err_code_LIB_ERR_CHAN_NOT_POLLED: err_code = 326;
pub const err_code_LIB_ERR_CHAN_NOT_REGISTERED: err_code = 327;
pub const err_code_LIB_ERR_WAITSET_IN_USE: err_code = 328;
pub const err_code_LIB_ERR_WAITSET_CHAN_CANCEL: err_code = 329;
pub const err_code_LIB_ERR_NO_EVENT: err_code = 330;
pub const err_code_LIB_ERR_EVENT_DISPATCH: err_code = 331;
pub const err_code_LIB_ERR_EVENT_ALREADY_RUN: err_code = 332;
pub const err_code_LIB_ERR_EVENT_QUEUE_EMPTY: err_code = 333;
pub const err_code_LIB_ERR_SEGBASE_OVER_4G_LIMIT: err_code = 334;
pub const err_code_LIB_ERR_LDT_FULL: err_code = 335;
pub const err_code_LIB_ERR_LDT_SELECTOR_INVALID: err_code = 336;
pub const err_code_LIB_ERR_PROC_MGMT_CLIENT_ACCEPT: err_code = 337;
pub const err_code_LIB_ERR_RPC_NO_HANDLER_SET: err_code = 338;
pub const err_code_LIB_ERR_RPC_INIT: err_code = 339;
pub const err_code_LIB_ERR_RPC_INITIATE: err_code = 340;
pub const err_code_LIB_ERR_RPC_SETUP_PAGE: err_code = 341;
pub const err_code_LIB_ERR_RPC_ARGUMENT_OVERFLOW: err_code = 342;
pub const err_code_FLOUNDER_ERR_INVALID_STATE: err_code = 343;
pub const err_code_FLOUNDER_ERR_TX_BUSY: err_code = 344;
pub const err_code_FLOUNDER_ERR_TX_MSG_SIZE: err_code = 345;
pub const err_code_FLOUNDER_ERR_RX_EMPTY_MSG: err_code = 346;
pub const err_code_FLOUNDER_ERR_RX_INVALID_MSGNUM: err_code = 347;
pub const err_code_FLOUNDER_ERR_RX_INVALID_LENGTH: err_code = 348;
pub const err_code_FLOUNDER_ERR_BUF_RECV_MORE: err_code = 349;
pub const err_code_FLOUNDER_ERR_BUF_SEND_MORE: err_code = 350;
pub const err_code_FLOUNDER_ERR_GENERIC_BIND_NO_MORE_DRIVERS: err_code = 351;
pub const err_code_FLOUNDER_ERR_CHANGE_WAITSET: err_code = 352;
pub const err_code_FLOUNDER_ERR_CHANGE_MONITOR_WAITSET: err_code = 353;
pub const err_code_FLOUNDER_ERR_UMP_ALLOC_NOTIFY: err_code = 354;
pub const err_code_FLOUNDER_ERR_UMP_STORE_NOTIFY: err_code = 355;
pub const err_code_FLOUNDER_ERR_BIND: err_code = 356;
pub const err_code_FLOUNDER_ERR_CREATE_MSG: err_code = 357;
pub const err_code_FLOUNDER_ERR_MARSHALLING: err_code = 358;
pub const err_code_FLOUNDER_ERR_DEMARSHALLING: err_code = 359;
pub const err_code_FLOUNDER_ERR_RPC_MISMATCH: err_code = 360;
pub const err_code_BCAST_ERR_SEND: err_code = 361;
pub const err_code_BCAST_ERR_SEND_SSF: err_code = 362;
pub const err_code_MON_CLIENT_ERR_SPAN_DOMAIN_REQUEST: err_code = 363;
pub const err_code_MON_CLIENT_ERR_URPC_BLOCK: err_code = 364;
pub const err_code_MON_ERR_IDC_BIND_NOT_SAME_CORE: err_code = 365;
pub const err_code_MON_ERR_IDC_BIND_LOCAL: err_code = 366;
pub const err_code_MON_ERR_INVALID_CORE_ID: err_code = 367;
pub const err_code_MON_ERR_INVALID_IREF: err_code = 368;
pub const err_code_MON_ERR_IREF_ALLOC: err_code = 369;
pub const err_code_MON_ERR_SPAN_STATE_ALLOC: err_code = 370;
pub const err_code_MON_ERR_SEND_REMOTE_MSG: err_code = 371;
pub const err_code_MON_ERR_INVALID_MON_ID: err_code = 372;
pub const err_code_MON_ERR_NO_MONITOR_FOR_CORE: err_code = 373;
pub const err_code_MON_ERR_CAP_IDENTIFY: err_code = 374;
pub const err_code_MON_ERR_CAP_CREATE: err_code = 375;
pub const err_code_MON_ERR_CAP_REMOTE: err_code = 376;
pub const err_code_MON_ERR_CAP_FOREIGN: err_code = 377;
pub const err_code_MON_ERR_CAP_MOVE: err_code = 378;
pub const err_code_MON_ERR_RCAP_DB_NOT_FOUND: err_code = 379;
pub const err_code_MON_ERR_RCAP_DB_LOCK: err_code = 380;
pub const err_code_MON_ERR_RCAP_DB_UNLOCK: err_code = 381;
pub const err_code_MON_ERR_RCAP_DB_ADD: err_code = 382;
pub const err_code_MON_ERR_SAME_CORE: err_code = 383;
pub const err_code_MON_ERR_REMOTE_CAP_NEED_REVOKE: err_code = 384;
pub const err_code_MON_ERR_REMOTE_CAP_RETRY: err_code = 385;
pub const err_code_MON_ERR_SPAWN_CORE: err_code = 386;
pub const err_code_MON_ERR_SPAWN_DOMAIN: err_code = 387;
pub const err_code_MON_ERR_INTERN_NEW_MONITOR: err_code = 388;
pub const err_code_MON_ERR_CAP_SEND: err_code = 389;
pub const err_code_MON_ERR_CAP_SEND_TRANSIENT: err_code = 390;
pub const err_code_MON_ERR_ROUTE_SET: err_code = 391;
pub const err_code_MON_ERR_SPAN_DOMAIN: err_code = 392;
pub const err_code_MON_ERR_MAP_URPC_CHAN: err_code = 393;
pub const err_code_MON_ERR_RAM_ALLOC_ERR: err_code = 394;
pub const err_code_MON_ERR_RAM_ALLOC_RETERR: err_code = 395;
pub const err_code_MON_ERR_MULTICAST_PAGE_MAP: err_code = 396;
pub const err_code_MON_ERR_WRONG_CAP_TYPE: err_code = 397;
pub const err_code_MON_ERR_INTERN_SET: err_code = 398;
pub const err_code_MON_ERR_ROUTE_RESET: err_code = 399;
pub const err_code_MON_ERR_MAP_MULTIBOOT: err_code = 400;
pub const err_code_MON_ERR_UNICAST_SET: err_code = 401;
pub const err_code_MON_ERR_MULTICAST_SET: err_code = 402;
pub const err_code_MON_ERR_BCAST_INIT: err_code = 403;
pub const err_code_MON_ERR_BCAST_CONNECT: err_code = 404;
pub const err_code_MON_ERR_CCAST_INIT: err_code = 405;
pub const err_code_MON_ERR_CCAST_CONNECT: err_code = 406;
pub const err_code_MON_ERR_UNICAST_CONNECT: err_code = 407;
pub const err_code_MON_ERR_MULTICAST_CONNECT: err_code = 408;
pub const err_code_MON_ERR_UNICAST_INIT: err_code = 409;
pub const err_code_MON_ERR_MULTICAST_INIT: err_code = 410;
pub const err_code_MON_ERR_SPAWN_XCORE_MONITOR: err_code = 411;
pub const err_code_MON_ERR_INCOMPLETE_ROUTE: err_code = 412;
pub const err_code_MON_ERR_RSRC_ALLOC: err_code = 413;
pub const err_code_MON_ERR_RSRC_MEMBER_LIMIT: err_code = 414;
pub const err_code_MON_ERR_RSRC_ILL_MANIFEST: err_code = 415;
pub const err_code_MON_ERR_RSRC_NOT_FOUND: err_code = 416;
pub const err_code_MON_ERR_CAPOPS_BUSY: err_code = 417;
pub const err_code_MON_ERR_INVOKE_IRQ_ALLOCATE: err_code = 418;
pub const err_code_MON_ERR_INVOKE_IRQ_SET: err_code = 419;
pub const err_code_ROUTE_ERR_NEW_ROUTE: err_code = 420;
pub const err_code_ROUTE_ERR_EXPORT: err_code = 421;
pub const err_code_ROUTE_ERR_LOOKUP: err_code = 422;
pub const err_code_ROUTE_ERR_BIND: err_code = 423;
pub const err_code_ROUTE_ERR_CORE_NOT_FOUND: err_code = 424;
pub const err_code_ROUTE_ERR_SET_EXPECTED: err_code = 425;
pub const err_code_ROUTE_ERR_SEND: err_code = 426;
pub const err_code_ROUTE_ERR_NO_SLOTS: err_code = 427;
pub const err_code_ROUTE_ERR_WRONG_GROUP_ID: err_code = 428;
pub const err_code_ROUTE_ERR_CALL_INIT: err_code = 429;
pub const err_code_ROUTE_ERR_CREATE_GROUP_RPC: err_code = 430;
pub const err_code_ROUTE_ERR_SET_GROUP_RPC: err_code = 431;
pub const err_code_ROUTE_ERR_GET_GROUP_RPC: err_code = 432;
pub const err_code_ROUTE_ERR_ALLOC_NID_RPC: err_code = 433;
pub const err_code_SPAWN_ERR_LOAD: err_code = 434;
pub const err_code_SPAWN_ERR_SPAN: err_code = 435;
pub const err_code_SPAWN_ERR_RUN: err_code = 436;
pub const err_code_SPAWN_ERR_VSPACE_MAP: err_code = 437;
pub const err_code_SPAWN_ERR_GET_CMDLINE_ARGS: err_code = 438;
pub const err_code_SPAWN_ERR_SETUP_ENV: err_code = 439;
pub const err_code_SPAWN_ERR_UNKNOWN_TARGET_ARCH: err_code = 440;
pub const err_code_SPAWN_ERR_UNSUPPORTED_TARGET_ARCH: err_code = 441;
pub const err_code_SPAWN_ERR_OUT_OF_PIDS: err_code = 442;
pub const err_code_SPAWN_ERR_SETUP_CSPACE: err_code = 443;
pub const err_code_SPAWN_ERR_DETERMINE_CPUTYPE: err_code = 444;
pub const err_code_SPAWN_ERR_VSPACE_INIT: err_code = 445;
pub const err_code_SPAWN_ERR_SETUP_DISPATCHER: err_code = 446;
pub const err_code_SPAWN_ERR_ELF_MAP: err_code = 447;
pub const err_code_SPAWN_ERR_SET_CAPS: err_code = 448;
pub const err_code_SPAWN_ERR_MONEP_SLOT_ALLOC: err_code = 449;
pub const err_code_SPAWN_ERR_MONITOR_CLIENT: err_code = 450;
pub const err_code_SPAWN_ERR_FREE: err_code = 451;
pub const err_code_SPAWN_ERR_CREATE_ROOTCN: err_code = 452;
pub const err_code_SPAWN_ERR_CREATE_TASKCN: err_code = 453;
pub const err_code_SPAWN_ERR_MINT_TASKCN: err_code = 454;
pub const err_code_SPAWN_ERR_CREATE_PAGECN: err_code = 455;
pub const err_code_SPAWN_ERR_CREATE_VNODE: err_code = 456;
pub const err_code_SPAWN_ERR_COPY_VNODE: err_code = 457;
pub const err_code_SPAWN_ERR_CREATE_DISPATCHER: err_code = 458;
pub const err_code_SPAWN_ERR_CREATE_DISPATCHER_FRAME: err_code = 459;
pub const err_code_SPAWN_ERR_CREATE_SELFEP: err_code = 460;
pub const err_code_SPAWN_ERR_CREATE_ARGSPG: err_code = 461;
pub const err_code_SPAWN_ERR_CREATE_FDSPG: err_code = 462;
pub const err_code_SPAWN_ERR_MINT_ROOTCN: err_code = 463;
pub const err_code_SPAWN_ERR_CREATE_SLOTALLOC_CNODE: err_code = 464;
pub const err_code_SPAWN_ERR_MINT_BASE_PAGE_CN: err_code = 465;
pub const err_code_SPAWN_ERR_MINT_SEGCN: err_code = 466;
pub const err_code_SPAWN_ERR_MINT_PAGECN: err_code = 467;
pub const err_code_SPAWN_ERR_MINT_INHERITCN: err_code = 468;
pub const err_code_SPAWN_ERR_MAP_DISPATCHER_TO_NEW: err_code = 469;
pub const err_code_SPAWN_ERR_MAP_DISPATCHER_TO_SELF: err_code = 470;
pub const err_code_SPAWN_ERR_MAP_ARGSPG_TO_NEW: err_code = 471;
pub const err_code_SPAWN_ERR_MAP_ARGSPG_TO_SELF: err_code = 472;
pub const err_code_SPAWN_ERR_MAP_FDSPG_TO_NEW: err_code = 473;
pub const err_code_SPAWN_ERR_MAP_FDSPG_TO_SELF: err_code = 474;
pub const err_code_SPAWN_ERR_FILL_SMALLCN: err_code = 475;
pub const err_code_SPAWN_ERR_MAP_BOOTINFO: err_code = 476;
pub const err_code_SPAWN_ERR_FIND_MODULE: err_code = 477;
pub const err_code_SPAWN_ERR_MAP_MODULE: err_code = 478;
pub const err_code_SPAWN_ERR_UNMAP_MODULE: err_code = 479;
pub const err_code_SPAWN_ERR_CREATE_SEGCN: err_code = 480;
pub const err_code_SPAWN_ERR_CREATE_SMALLCN: err_code = 481;
pub const err_code_SPAWN_ERR_ELF_FIND_SYMBOL: err_code = 482;
pub const err_code_SPAWN_ERR_ARGSPG_OVERFLOW: err_code = 483;
pub const err_code_SPAWN_ERR_SERIALISE_VSPACE: err_code = 484;
pub const err_code_SPAWN_ERR_SETUP_INHERITED_CAPS: err_code = 485;
pub const err_code_SPAWN_ERR_CREATE_ARGCN: err_code = 486;
pub const err_code_SPAWN_ERR_COPY_ARGCN: err_code = 487;
pub const err_code_SPAWN_ERR_SETUP_FDCAP: err_code = 488;
pub const err_code_SPAWN_ERR_FDSPG_OVERFLOW: err_code = 489;
pub const err_code_SPAWN_ERR_SETUP_SIDCAP: err_code = 490;
pub const err_code_SPAWN_ERR_SETUP_KERNEL_CAP: err_code = 491;
pub const err_code_SPAWN_ERR_DELETE_ROOTCN: err_code = 492;
pub const err_code_SPAWN_ERR_FREE_ROOTCN: err_code = 493;
pub const err_code_SPAWN_ERR_DELETE_TASKCN: err_code = 494;
pub const err_code_SPAWN_ERR_FREE_TASKCN: err_code = 495;
pub const err_code_SPAWN_ERR_COPY_PACN: err_code = 496;
pub const err_code_SPAWN_ERR_COPY_MODULECN: err_code = 497;
pub const err_code_SPAWN_ERR_COPY_IRQ_CAP: err_code = 498;
pub const err_code_SPAWN_ERR_COPY_IO_CAP: err_code = 499;
pub const err_code_SPAWN_ERR_COPY_PERF_MON: err_code = 500;
pub const err_code_SPAWN_ERR_COPY_KERNEL_CAP: err_code = 501;
pub const err_code_SPAWN_ERR_COPY_INHERITCN_CAP: err_code = 502;
pub const err_code_SPAWN_ERR_COPY_PROC_MNG_CAP: err_code = 503;
pub const err_code_SPAWN_ERR_COPY_DOMAIN_CAP: err_code = 504;
pub const err_code_SPAWN_ERR_COPY_DEVMAN_CAP: err_code = 505;
pub const err_code_SPAWN_ERR_DISPATCHER_SETUP: err_code = 506;
pub const err_code_SPAWN_ERR_DOMAIN_ALLOCATE: err_code = 507;
pub const err_code_SPAWN_ERR_DOMAIN_NOTFOUND: err_code = 508;
pub const err_code_SPAWN_ERR_DOMAIN_RUNNING: err_code = 509;
pub const err_code_SPAWN_ERR_IDENTIFY_PROC_MNGR_CAP: err_code = 510;
pub const err_code_SPAWN_ERR_NOT_PROC_MNGR: err_code = 511;
pub const err_code_SPAWN_ERR_CREATE_DOMAIN_TABLE: err_code = 512;
pub const err_code_SPAWN_ERR_DOMAIN_CAP_HASH: err_code = 513;
pub const err_code_SPAWN_ERR_DOMAIN_TABLE_FIND: err_code = 514;
pub const err_code_SPAWN_ERR_FIND_SPAWNDS: err_code = 515;
pub const err_code_SPAWN_ERR_MALFORMED_SPAWND_RECORD: err_code = 516;
pub const err_code_PROC_MGMT_ERR_NOT_MONITOR: err_code = 517;
pub const err_code_PROC_MGMT_ERR_SPAWND_EXISTS: err_code = 518;
pub const err_code_PROC_MGMT_ERR_INVALID_SPAWND: err_code = 519;
pub const err_code_PROC_MGMT_ERR_CREATE_DOMAIN_CAP: err_code = 520;
pub const err_code_PROC_MGMT_ERR_SPAWND_REQUEST: err_code = 521;
pub const err_code_PROC_MGMT_ERR_DOMAIN_CAP_HASH: err_code = 522;
pub const err_code_PROC_MGMT_ERR_CREATE_CLIENTS_TABLE: err_code = 523;
pub const err_code_PROC_MGMT_ERR_CLIENTS_TABLE_FIND: err_code = 524;
pub const err_code_PROC_MGMT_ERR_CREATE_DOMAIN_TABLE: err_code = 525;
pub const err_code_PROC_MGMT_ERR_DOMAIN_TABLE_FIND: err_code = 526;
pub const err_code_PROC_MGMT_ERR_DOMAIN_NOT_RUNNING: err_code = 527;
pub const err_code_PROC_MGMT_ERR_ALREADY_SPANNED: err_code = 528;
pub const err_code_PROC_MGMT_ERR_KILL: err_code = 529;
pub const err_code_ELF_ERR_FILESZ: err_code = 530;
pub const err_code_ELF_ERR_HEADER: err_code = 531;
pub const err_code_ELF_ERR_PROGHDR: err_code = 532;
pub const err_code_ELF_ERR_ALLOCATE: err_code = 533;
pub const err_code_ELF_ERR_NOT_PAGE_ALIGNED: err_code = 534;
pub const err_code_MM_ERR_FIND_NODE: err_code = 535;
pub const err_code_MM_ERR_CHUNK_NODE: err_code = 536;
pub const err_code_MM_ERR_SLOT_MM_ALLOC: err_code = 537;
pub const err_code_MM_ERR_SLOT_NOSLOTS: err_code = 538;
pub const err_code_MM_ERR_SLOT_ALLOC_INIT: err_code = 539;
pub const err_code_MM_ERR_MM_INIT: err_code = 540;
pub const err_code_MM_ERR_MM_ADD: err_code = 541;
pub const err_code_MM_ERR_MM_ADD_MULTI: err_code = 542;
pub const err_code_MM_ERR_MM_FREE: err_code = 543;
pub const err_code_MM_ERR_NEW_NODE: err_code = 544;
pub const err_code_MM_ERR_OUT_OF_BOUNDS: err_code = 545;
pub const err_code_MM_ERR_ALREADY_PRESENT: err_code = 546;
pub const err_code_MM_ERR_ALREADY_ALLOCATED: err_code = 547;
pub const err_code_MM_ERR_NOT_FOUND: err_code = 548;
pub const err_code_MM_ERR_MISSING_CAPS: err_code = 549;
pub const err_code_MM_ERR_CHUNK_SLOT_ALLOC: err_code = 550;
pub const err_code_MM_ERR_RESIZE_NODE: err_code = 551;
pub const err_code_MM_ERR_REALLOC_RANGE: err_code = 552;
pub const err_code_INIT_ERR_SPAWN_MEM_SERV: err_code = 553;
pub const err_code_INIT_ERR_INIT_MEM_SERV: err_code = 554;
pub const err_code_INIT_ERR_SPAWN_MONITOR: err_code = 555;
pub const err_code_INIT_ERR_INIT_MONITOR: err_code = 556;
pub const err_code_INIT_ERR_COPY_EP_TO_MEM_SERV: err_code = 557;
pub const err_code_INIT_ERR_COPY_EP_TO_MONITOR: err_code = 558;
pub const err_code_INIT_ERR_SETUP_MONITOR_CHAN: err_code = 559;
pub const err_code_INIT_ERR_SETUP_MEM_SERV_CHAN: err_code = 560;
pub const err_code_INIT_ERR_RUN_MONITOR: err_code = 561;
pub const err_code_INIT_ERR_RUN_MEM_SERV: err_code = 562;
pub const err_code_INIT_ERR_FREE_MONITOR: err_code = 563;
pub const err_code_INIT_ERR_FREE_MEM_SERV: err_code = 564;
pub const err_code_INIT_ERR_COPY_SUPERCN_CAP: err_code = 565;
pub const err_code_INIT_ERR_MAP_BOOTINFO: err_code = 566;
pub const err_code_INIT_ERR_COPY_KERNEL_CAP: err_code = 567;
pub const err_code_INIT_ERR_COPY_BSP_KCB: err_code = 568;
pub const err_code_INIT_ERR_COPY_IPI: err_code = 569;
pub const err_code_INIT_ERR_COPY_PROC_MNG_CAP: err_code = 570;
pub const err_code_INIT_ERR_COPY_PERF_MON: err_code = 571;
pub const err_code_INIT_ERR_COPY_MODULECN_CAP: err_code = 572;
pub const err_code_INIT_ERR_COPY_PACN_CAP: err_code = 573;
pub const err_code_INIT_ERR_COPY_IRQ_CAP: err_code = 574;
pub const err_code_INIT_ERR_COPY_IO_CAP: err_code = 575;
pub const err_code_INIT_ERR_COPY_UMP_CAP: err_code = 576;
pub const err_code_INIT_ERR_NO_MATCHING_RAM_CAP: err_code = 577;
pub const err_code_CONT_ERR_NO_MORE_SLOTS: err_code = 578;
pub const err_code_ETHERSRV_ERR_TOO_MANY_BUFFERS: err_code = 579;
pub const err_code_ETHERSRV_ERR_TOO_MANY_VNICS: err_code = 580;
pub const err_code_ETHERSRV_ERR_BUFFER_NOT_FOUND: err_code = 581;
pub const err_code_ETHERSRV_ERR_NOT_ENOUGH_MEM: err_code = 582;
pub const err_code_ETHERSRV_ERR_CANT_TRANSMIT: err_code = 583;
pub const err_code_ETHERSRV_ERR_INVALID_STATE: err_code = 584;
pub const err_code_ETHERSRV_ERR_FRAME_CAP_MAP: err_code = 585;
pub const err_code_PORT_ERR_NOT_ENOUGH_MEMORY: err_code = 586;
pub const err_code_PORT_ERR_NO_MORE_PORT: err_code = 587;
pub const err_code_PORT_ERR_IN_USE: err_code = 588;
pub const err_code_PORT_ERR_REDIRECT: err_code = 589;
pub const err_code_PORT_ERR_NOT_FOUND: err_code = 590;
pub const err_code_NET_FILTER_ERR_NOT_INITIALIZED: err_code = 591;
pub const err_code_NET_FILTER_ERR_NOT_FOUND: err_code = 592;
pub const err_code_NET_FILTER_ERR_ALREADY_EXISTS: err_code = 593;
pub const err_code_FILTER_ERR_NOT_ENOUGH_MEMORY: err_code = 594;
pub const err_code_FILTER_ERR_BUFF_NOT_FOUND: err_code = 595;
pub const err_code_FILTER_ERR_FILTER_BUSY: err_code = 596;
pub const err_code_FILTER_ERR_NO_NETD_MEM: err_code = 597;
pub const err_code_FILTER_ERR_FILTER_NOT_FOUND: err_code = 598;
pub const err_code_FILTER_ERR_BUFFER_NOT_FOUND: err_code = 599;
pub const err_code_TERM_ERR_TERMINAL_IN_USE: err_code = 600;
pub const err_code_TERM_ERR_NOT_PART_OF_SESSION: err_code = 601;
pub const err_code_TERM_ERR_EXPORT_SESSION_INTERFACE: err_code = 602;
pub const err_code_TERM_ERR_REGISTER_SESSION_INTERFACE: err_code = 603;
pub const err_code_TERM_ERR_EXPORT_OUT_INTERFACE: err_code = 604;
pub const err_code_TERM_ERR_EXPORT_IN_INTERFACE: err_code = 605;
pub const err_code_TERM_ERR_EXPORT_CONF_INTERFACE: err_code = 606;
pub const err_code_TERM_ERR_ASSOCIATE_WITH_TERM_REPLY: err_code = 607;
pub const err_code_TERM_ERR_RECV_CHARS: err_code = 608;
pub const err_code_TERM_ERR_SEND_CHARS: err_code = 609;
pub const err_code_TERM_ERR_RECV_CONFIGURATION: err_code = 610;
pub const err_code_TERM_ERR_FILTER_NOT_FOUND: err_code = 611;
pub const err_code_TERM_ERR_TRIGGER_NOT_FOUND: err_code = 612;
pub const err_code_TERM_ERR_LOOKUP_SESSION_RECORD: err_code = 613;
pub const err_code_TERM_ERR_PARSE_SESSION_RECORD: err_code = 614;
pub const err_code_TERM_ERR_BIND_IN_INTERFACE: err_code = 615;
pub const err_code_TERM_ERR_BIND_OUT_INTERFACE: err_code = 616;
pub const err_code_TERM_ERR_BIND_CONF_INTERFACE: err_code = 617;
pub const err_code_TERM_ERR_IO: err_code = 618;
pub const err_code_TERM_ERR_TX_BUSY: err_code = 619;
pub const err_code_TERM_ERR_UNKNOWN_CONFIG_OPT: err_code = 620;
pub const err_code_TERM_ERR_CHANGE_WAITSET: err_code = 621;
pub const err_code_ANGLER_ERR_LOOKUP_TERMINAL: err_code = 622;
pub const err_code_ANGLER_ERR_CREATE_SESSIONID: err_code = 623;
pub const err_code_ANGLER_ERR_BIND_TERMINAL: err_code = 624;
pub const err_code_ANGLER_ERR_INIT_RPCCLIENT: err_code = 625;
pub const err_code_ANGLER_ERR_ASSOCIATE_WITH_TERMINAL: err_code = 626;
pub const err_code_ANGLER_ERR_STORE_SESSION_STATE: err_code = 627;
pub const err_code_TRACE_ERR_SUBSYS_DISABLED: err_code = 2;
pub const err_code_TRACE_ERR_NO_BUFFER: err_code = 628;
pub const err_code_TRACE_ERR_MAP_BUF: err_code = 629;
pub const err_code_TRACE_ERR_CREATE_CAP: err_code = 630;
pub const err_code_TRACE_ERR_CAP_COPY: err_code = 631;
pub const err_code_TRACE_ERR_KERNEL_INVOKE: err_code = 632;
pub const err_code_TRACE_ERR_UNAVAIL: err_code = 633;
pub const err_code_DRIVERKIT_ERR_NO_CAP_FOUND: err_code = 634;
pub const err_code_DRIVERKIT_ERR_NO_DRIVER_FOUND: err_code = 635;
pub const err_code_DRIVERKIT_ERR_DRIVER_DETACH: err_code = 636;
pub const err_code_DRIVERKIT_ERR_DRIVER_INIT: err_code = 637;
pub const err_code_DRIVERKIT_ERR_CONTROL_IFACE_EXPORT: err_code = 638;
pub const err_code_DRIVERKIT_ERR_CONTROL_SERVICE_INIT: err_code = 639;
pub const err_code_DRIVERKIT_ERR_CAP_CAPACITY: err_code = 640;
pub const err_code_PCI_ERR_DEVICE_NOT_INIT: err_code = 641;
pub const err_code_PCI_ERR_IOAPIC_INIT: err_code = 642;
pub const err_code_PCI_ERR_MINT_IOCAP: err_code = 643;
pub const err_code_PCI_ERR_ROUTING_IRQ: err_code = 644;
pub const err_code_PCI_ERR_IRQTABLE_SET: err_code = 645;
pub const err_code_PCI_ERR_UNKNOWN_GSI: err_code = 646;
pub const err_code_PCI_ERR_INVALID_VECTOR: err_code = 647;
pub const err_code_PCI_ERR_DEVICE_INIT: err_code = 648;
pub const err_code_PCI_ERR_MEM_ALLOC: err_code = 649;
pub const err_code_PCI_ERR_WRONG_INDEX: err_code = 650;
pub const err_code_PCI_ERR_MSIX_NOTSUP: err_code = 651;
pub const err_code_PCI_ERR_MSIX_BADVECTOR: err_code = 652;
pub const err_code_PCI_ERR_MSIX_DISABLED: err_code = 653;
pub const err_code_PCI_ERR_SRIOV_NOT_SUPPORTED: err_code = 654;
pub const err_code_PCI_ERR_SRIOV_MAX_VF: err_code = 655;
pub const err_code_PCI_ERR_ARG_PARSE: err_code = 656;
pub const err_code_PCI_ERR_NO_CAP: err_code = 657;
pub const err_code_ACPI_ERR_NO_MCFG_TABLE: err_code = 658;
pub const err_code_ACPI_ERR_INVALID_PATH_NAME: err_code = 659;
pub const err_code_ACPI_ERR_INVALID_HANDLE: err_code = 660;
pub const err_code_ACPI_ERR_NO_CHILD_BRIDGE: err_code = 661;
pub const err_code_ACPI_ERR_GET_RESOURCES: err_code = 662;
pub const err_code_ACPI_ERR_SET_IRQ: err_code = 663;
pub const err_code_ACPI_ERR_NO_MADT_TABLE: err_code = 664;
pub const err_code_ACPI_ERR_OBJECT_NOT_FOUND: err_code = 665;
pub const err_code_IOMMU_ERR_INVALID_CAP: err_code = 666;
pub const err_code_IOMMU_ERR_IOMMU_NOT_FOUND: err_code = 667;
pub const err_code_IOMMU_ERR_DOM_NOT_FOUND: err_code = 668;
pub const err_code_IOMMU_ERR_DEV_NOT_FOUND: err_code = 669;
pub const err_code_IOMMU_ERR_DEV_USED: err_code = 670;
pub const err_code_IOMMU_ERR_DOM_FULL: err_code = 671;
pub const err_code_IOMMU_ERR_DOM_CREATE: err_code = 672;
pub const err_code_IOMMU_ERR_NO_UNITS: err_code = 673;
pub const err_code_IOMMU_ERR_NOT_ENABLED: err_code = 674;
pub const err_code_IOMMU_ERR_INVALID_EP: err_code = 675;
pub const err_code_IOMMU_ERR_NOT_SUPPORTED: err_code = 676;
pub const err_code_SKB_ERR_CONVERSION_ERROR: err_code = 677;
pub const err_code_SKB_ERR_EXECUTION: err_code = 678;
pub const err_code_SKB_ERR_EVALUATE: err_code = 679;
pub const err_code_SKB_ERR_RUN: err_code = 680;
pub const err_code_SKB_ERR_GOAL_FAILURE: err_code = 681;
pub const err_code_SKB_ERR_UNEXPECTED_OUTPUT: err_code = 682;
pub const err_code_SKB_ERR_OVERFLOW: err_code = 683;
pub const err_code_SKB_ERR_IO_OUTPUT: err_code = 3;
pub const err_code_SKB_DATAGATHERER_ERR_CPUID: err_code = 684;
pub const err_code_FS_ERR_INVALID_FH: err_code = 685;
pub const err_code_FS_ERR_NOTDIR: err_code = 686;
pub const err_code_FS_ERR_NOTFILE: err_code = 687;
pub const err_code_FS_ERR_INDEX_BOUNDS: err_code = 688;
pub const err_code_FS_ERR_NOTFOUND: err_code = 689;
pub const err_code_FS_ERR_EXISTS: err_code = 690;
pub const err_code_FS_ERR_NOTEMPTY: err_code = 691;
pub const err_code_FS_ERR_READ: err_code = 692;
pub const err_code_FS_ERR_WRITE: err_code = 693;
pub const err_code_FS_ERR_OPEN: err_code = 694;
pub const err_code_FS_ERR_CLOSE: err_code = 695;
pub const err_code_FS_ERR_BUSY: err_code = 696;
pub const err_code_FS_ERR_BULK_NOT_INIT: err_code = 697;
pub const err_code_FS_ERR_BULK_ALREADY_INIT: err_code = 698;
pub const err_code_VFS_ERR_EOF: err_code = 4;
pub const err_code_VFS_ERR_BAD_MOUNTPOINT: err_code = 699;
pub const err_code_VFS_ERR_MOUNTPOINT_IN_USE: err_code = 700;
pub const err_code_VFS_ERR_BAD_URI: err_code = 701;
pub const err_code_VFS_ERR_UNKNOWN_FILESYSTEM: err_code = 702;
pub const err_code_VFS_ERR_MOUNTPOINT_NOTFOUND: err_code = 703;
pub const err_code_VFS_ERR_NOT_SUPPORTED: err_code = 704;
pub const err_code_VFS_ERR_IN_OPEN: err_code = 705;
pub const err_code_VFS_ERR_IN_STAT: err_code = 706;
pub const err_code_VFS_ERR_IN_READ: err_code = 707;
pub const err_code_VFS_ERR_BCACHE_LIMIT: err_code = 708;
pub const err_code_NFS_ERR_TRANSPORT: err_code = 709;
pub const err_code_NFS_ERR_MNT_PERM: err_code = 710;
pub const err_code_NFS_ERR_MNT_NOENT: err_code = 711;
pub const err_code_NFS_ERR_MNT_IO: err_code = 712;
pub const err_code_NFS_ERR_MNT_ACCES: err_code = 713;
pub const err_code_NFS_ERR_MNT_NOTDIR: err_code = 714;
pub const err_code_NFS_ERR_MNT_INVAL: err_code = 715;
pub const err_code_NFS_ERR_MNT_NAMETOOLONG: err_code = 716;
pub const err_code_NFS_ERR_MNT_NOTSUPP: err_code = 717;
pub const err_code_NFS_ERR_MNT_SERVERFAULT: err_code = 718;
pub const err_code_NFS_ERR_PERM: err_code = 719;
pub const err_code_NFS_ERR_NOENT: err_code = 720;
pub const err_code_NFS_ERR_IO: err_code = 721;
pub const err_code_NFS_ERR_NXIO: err_code = 722;
pub const err_code_NFS_ERR_ACCES: err_code = 723;
pub const err_code_NFS_ERR_EXIST: err_code = 724;
pub const err_code_NFS_ERR_XDEV: err_code = 725;
pub const err_code_NFS_ERR_NODEV: err_code = 726;
pub const err_code_NFS_ERR_NOTDIR: err_code = 727;
pub const err_code_NFS_ERR_ISDIR: err_code = 728;
pub const err_code_NFS_ERR_INVAL: err_code = 729;
pub const err_code_NFS_ERR_FBIG: err_code = 730;
pub const err_code_NFS_ERR_NOSPC: err_code = 731;
pub const err_code_NFS_ERR_ROFS: err_code = 732;
pub const err_code_NFS_ERR_MLINK: err_code = 733;
pub const err_code_NFS_ERR_NAMETOOLONG: err_code = 734;
pub const err_code_NFS_ERR_NOTEMPTY: err_code = 735;
pub const err_code_NFS_ERR_DQUOT: err_code = 736;
pub const err_code_NFS_ERR_STALE: err_code = 737;
pub const err_code_NFS_ERR_REMOTE: err_code = 738;
pub const err_code_NFS_ERR_BADHANDLE: err_code = 739;
pub const err_code_NFS_ERR_NOT_SYNC: err_code = 740;
pub const err_code_NFS_ERR_BAD_COOKIE: err_code = 741;
pub const err_code_NFS_ERR_NOTSUPP: err_code = 742;
pub const err_code_NFS_ERR_TOOSMALL: err_code = 743;
pub const err_code_NFS_ERR_SERVERFAULT: err_code = 744;
pub const err_code_NFS_ERR_BADTYPE: err_code = 745;
pub const err_code_NFS_ERR_JUKEBOX: err_code = 746;
pub const err_code_LWIP_ERR_MEM: err_code = 747;
pub const err_code_LWIP_ERR_BUF: err_code = 748;
pub const err_code_LWIP_ERR_TIMEOUT: err_code = 749;
pub const err_code_LWIP_ERR_RTE: err_code = 750;
pub const err_code_LWIP_ERR_ABRT: err_code = 751;
pub const err_code_LWIP_ERR_RST: err_code = 752;
pub const err_code_LWIP_ERR_CLSD: err_code = 753;
pub const err_code_LWIP_ERR_CONN: err_code = 754;
pub const err_code_LWIP_ERR_VAL: err_code = 755;
pub const err_code_LWIP_ERR_ARG: err_code = 756;
pub const err_code_LWIP_ERR_USE: err_code = 757;
pub const err_code_LWIP_ERR_IF: err_code = 758;
pub const err_code_LWIP_ERR_ISCONN: err_code = 759;
pub const err_code_LWIP_ERR_INPROGRESS: err_code = 760;
pub const err_code_LWIP_ERR_TXFULL: err_code = 761;
pub const err_code_DIST_ERR_NS_REG: err_code = 762;
pub const err_code_DIST_ERR_NS_LOOKUP: err_code = 763;
pub const err_code_OCT_ERR_NO_RECORD: err_code = 764;
pub const err_code_OCT_ERR_NO_RECORD_NAME: err_code = 765;
pub const err_code_OCT_ERR_CONSTRAINT_MISMATCH: err_code = 766;
pub const err_code_OCT_ERR_QUERY_SIZE: err_code = 767;
pub const err_code_OCT_ERR_INVALID_FORMAT: err_code = 768;
pub const err_code_OCT_ERR_UNKNOWN_ATTRIBUTE: err_code = 769;
pub const err_code_OCT_ERR_UNSUPPORTED_BINDING: err_code = 770;
pub const err_code_OCT_ERR_PARSER_FAIL: err_code = 771;
pub const err_code_OCT_ERR_ENGINE_FAIL: err_code = 772;
pub const err_code_OCT_ERR_NO_SUBSCRIPTION: err_code = 773;
pub const err_code_OCT_ERR_NO_SUBSCRIBERS: err_code = 774;
pub const err_code_OCT_ERR_MAX_SUBSCRIPTIONS: err_code = 775;
pub const err_code_OCT_ERR_INVALID_ID: err_code = 776;
pub const err_code_OCT_ERR_CAP_NAME_UNKNOWN: err_code = 777;
pub const err_code_OCT_ERR_CAP_OVERWRITE: err_code = 778;
pub const err_code_OCT_ERR_IDCAP_INVOKE: err_code = 779;
pub const err_code_KALUGA_ERR_PARSE_MODULES: err_code = 780;
pub const err_code_KALUGA_ERR_MODULE_NOT_FOUND: err_code = 781;
pub const err_code_KALUGA_ERR_DRIVER_ALREADY_STARTED: err_code = 782;
pub const err_code_KALUGA_ERR_DRIVER_NOT_AUTO: err_code = 783;
pub const err_code_KALUGA_ERR_WAITING_FOR_ACPI: err_code = 784;
pub const err_code_KALUGA_ERR_WATCHING_FOR_SPAWNDS: err_code = 785;
pub const err_code_KALUGA_ERR_QUERY_LOCAL_APIC: err_code = 786;
pub const err_code_KALUGA_ERR_UNKNOWN_PLATFORM: err_code = 787;
pub const err_code_KALUGA_ERR_CAP_ACQUIRE: err_code = 788;
pub const err_code_THC_CANCELED: err_code = 789;
pub const err_code_MS_ERR_SKB: err_code = 790;
pub const err_code_MS_ERR_INIT_PEERS: err_code = 791;
pub const err_code_STARTD_ERR_BOOTMODULES: err_code = 792;
pub const err_code_LOX_ERR_INIT_LOCKS: err_code = 793;
pub const err_code_LOX_ERR_NO_LOCKS: err_code = 794;
pub const err_code_VBE_ERR_MODE_NOT_FOUND: err_code = 795;
pub const err_code_VBE_ERR_BIOS_CALL_FAILED: err_code = 796;
pub const err_code_AHCI_ERR_PORT_INIT: err_code = 797;
pub const err_code_AHCI_ERR_PORT_INVALID: err_code = 798;
pub const err_code_AHCI_ERR_PORT_BUSY: err_code = 799;
pub const err_code_AHCI_ERR_PORT_MISMATCH: err_code = 800;
pub const err_code_AHCI_ERR_NO_FREE_PRD: err_code = 801;
pub const err_code_AHCI_ERR_ILLEGAL_ARGUMENT: err_code = 802;
pub const err_code_SATA_ERR_INVALID_TYPE: err_code = 803;
pub const err_code_MMC_ERR_TRANSFER: err_code = 804;
pub const err_code_MMC_ERR_READ_READY: err_code = 805;
pub const err_code_MMC_ERR_WRITE_READY: err_code = 806;
pub const err_code_FAT_ERR_BAD_FS: err_code = 807;
pub const err_code_FAT_ERR_CLUSTER_NOT_FREE: err_code = 808;
pub const err_code_FAT_ERR_CLUSTER_BOUNDS: err_code = 809;
pub const err_code_FAT_ERR_FAT_LOOKUP: err_code = 810;
pub const err_code_FAT_ERR_BLOCK_BOUNDS: err_code = 811;
pub const err_code_FAT_ERR_CREATE_ROOT: err_code = 812;
pub const err_code_FAT_ERR_BAD_FILENAME: err_code = 813;
pub const err_code_FS_CACHE_FULL: err_code = 814;
pub const err_code_FS_CACHE_NOTPRESENT: err_code = 815;
pub const err_code_FS_CACHE_CONFLICT: err_code = 816;
pub const err_code_OMAP_SDMA_ERR_NO_AVAIL_CHANNEL: err_code = 817;
pub const err_code_OMAP_SDMA_ERR_TRANSACTION: err_code = 818;
pub const err_code_OMAP_SDMA_ERR_SUPERVISOR: err_code = 819;
pub const err_code_OMAP_SDMA_ERR_MISALIGNED_ADDRESS: err_code = 820;
pub const err_code_OMAP_SDMA_ERR_HARDWARE_LIMIT_SIZE: err_code = 821;
pub const err_code_OMAP_SDMA_ERR_HARDWARE_LIMIT_ADDR: err_code = 822;
pub const err_code_OMAP_SDMA_ERR_OUT_OF_BOUNDS: err_code = 823;
pub const err_code_OMAP_SDMA_ERR_CAP_LOOKUP: err_code = 824;
pub const err_code_ERR_INVALID_ARGS: err_code = 825;
pub const err_code_ERR_NOTIMP: err_code = 826;
pub const err_code_BULK_TRANSFER_MEM: err_code = 827;
pub const err_code_BULK_TRANSFER_NO_CALLBACK: err_code = 828;
pub const err_code_BULK_TRANSFER_CHAN_CREATE: err_code = 829;
pub const err_code_BULK_TRANSFER_CHAN_BIND: err_code = 830;
pub const err_code_BULK_TRANSFER_CHAN_ASSIGN_POOL: err_code = 831;
pub const err_code_BULK_TRANSFER_CHAN_STATE: err_code = 832;
pub const err_code_BULK_TRANSFER_CHAN_TRUST: err_code = 833;
pub const err_code_BULK_TRANSFER_CHAN_INVALID_EP: err_code = 834;
pub const err_code_BULK_TRANSFER_CHAN_DIRECTION: err_code = 835;
pub const err_code_BULK_TRANSFER_POOL_INVALD: err_code = 836;
pub const err_code_BULK_TRANSFER_POOL_NOT_ASSIGNED: err_code = 837;
pub const err_code_BULK_TRANSFER_POOL_ASSIGN_VETO: err_code = 838;
pub const err_code_BULK_TRANSFER_POOL_MAP: err_code = 839;
pub const err_code_BULK_TRANSFER_POOL_UNMAP: err_code = 840;
pub const err_code_BULK_TRANSFER_POOL_ALREADY_ASSIGNED: err_code = 841;
pub const err_code_BULK_TRANSFER_POOL_ALREADY_REMAPPED: err_code = 842;
pub const err_code_BULK_TRANSFER_BUFFER_NOT_OWNED: err_code = 843;
pub const err_code_BULK_TRANSFER_BUFFER_INVALID: err_code = 844;
pub const err_code_BULK_TRANSFER_BUFFER_ALREADY_MAPPED: err_code = 845;
pub const err_code_BULK_TRANSFER_BUFFER_STATE: err_code = 846;
pub const err_code_BULK_TRANSFER_BUFFER_REFCOUNT: err_code = 847;
pub const err_code_BULK_TRANSFER_BUFFER_NOT_A_COPY: err_code = 848;
pub const err_code_BULK_TRANSFER_BUFFER_MAP: err_code = 849;
pub const err_code_BULK_TRANSFER_BUFFER_UNMAP: err_code = 850;
pub const err_code_BULK_TRANSFER_ALLOC_BUFFER_SIZE: err_code = 851;
pub const err_code_BULK_TRANSFER_ALLOC_BUFFER_COUNT: err_code = 852;
pub const err_code_BULK_TRANSFER_INVALID_ARGUMENT: err_code = 853;
pub const err_code_BULK_TRANSFER_SM_NO_PENDING_MSG: err_code = 854;
pub const err_code_BULK_TRANSFER_SM_EXCLUSIVE_WS: err_code = 855;
pub const err_code_BULK_TRANSFER_NET_MAX_QUEUES: err_code = 856;
pub const err_code_BULK_TRANSFER_NET_POOL_USED: err_code = 857;
pub const err_code_VIRTIO_ERR_SIZE_INVALID: err_code = 858;
pub const err_code_VIRTIO_ERR_MAX_INDIRECT: err_code = 859;
pub const err_code_VIRTIO_ERR_CAP_SIZE: err_code = 860;
pub const err_code_VIRTIO_ERR_QUEUE_FULL: err_code = 861;
pub const err_code_VIRTIO_ERR_QUEUE_EMPTY: err_code = 862;
pub const err_code_VIRTIO_ERR_BACKEND: err_code = 863;
pub const err_code_VIRTIO_ERR_DEVICE_REGISTER: err_code = 864;
pub const err_code_VIRTIO_ERR_NOT_VIRTIO_DEVICE: err_code = 865;
pub const err_code_VIRTIO_ERR_VERSION_MISMATCH: err_code = 866;
pub const err_code_VIRTIO_ERR_DEVICE_STATUS: err_code = 867;
pub const err_code_VIRTIO_ERR_DEVICE_TYPE: err_code = 868;
pub const err_code_VIRTIO_ERR_DEVICE_IDLE: err_code = 869;
pub const err_code_VIRTIO_ERR_QUEUE_ACTIVE: err_code = 870;
pub const err_code_VIRTIO_ERR_QUEUE_INVALID: err_code = 871;
pub const err_code_VIRTIO_ERR_QUEUE_BUSY: err_code = 872;
pub const err_code_VIRTIO_ERR_BUFFER_SIZE: err_code = 873;
pub const err_code_VIRTIO_ERR_BUFFER_STATE: err_code = 874;
pub const err_code_VIRTIO_ERR_ARG_INVALID: err_code = 875;
pub const err_code_VIRTIO_ERR_NO_BUFFER: err_code = 876;
pub const err_code_VIRTIO_ERR_ALLOC_FULL: err_code = 877;
pub const err_code_VIRTIO_ERR_BUFFER_USED: err_code = 878;
pub const err_code_VIRTIO_ERR_NO_DESC_AVAIL: err_code = 879;
pub const err_code_VIRTIO_ERR_DEQ_CHAIN: err_code = 880;
pub const err_code_VIRTIO_ERR_INVALID_RING_INDEX: err_code = 881;
pub const err_code_VIRTIO_ERR_BLK_REQ_IOERR: err_code = 882;
pub const err_code_VIRTIO_ERR_BLK_REQ_UNSUP: err_code = 883;
pub const err_code_XEON_PHI_ERR_MGR_REGISTER_FAILED: err_code = 884;
pub const err_code_XEON_PHI_ERR_MGR_MAX_CARDS: err_code = 885;
pub const err_code_XEON_PHI_ERR_MSG_NOT_REACHABLE: err_code = 886;
pub const err_code_XEON_PHI_ERR_MSG_NOT_INITIALIZED: err_code = 887;
pub const err_code_XEON_PHI_ERR_CLIENT_OPEN_REJECT: err_code = 888;
pub const err_code_XEON_PHI_ERR_CLIENT_DOMAIN_VOID: err_code = 889;
pub const err_code_XEON_PHI_ERR_CLIENT_REGISTER: err_code = 890;
pub const err_code_XEON_PHI_ERR_CLIENT_BUSY: err_code = 891;
pub const err_code_XEON_PHI_ERR_INVALID_ID: err_code = 892;
pub const err_code_DMA_ERR_PCI_ADDRESS: err_code = 893;
pub const err_code_DMA_ERR_DEVICE_UNSUPPORTED: err_code = 894;
pub const err_code_DMA_ERR_DEVICE_IDLE: err_code = 895;
pub const err_code_DMA_ERR_ARG_INVALID: err_code = 896;
pub const err_code_DMA_ERR_RESET_TIMEOUT: err_code = 897;
pub const err_code_DMA_ERR_NO_DESCRIPTORS: err_code = 898;
pub const err_code_DMA_ERR_NO_REQUESTS: err_code = 899;
pub const err_code_DMA_ERR_CHAN_ERROR: err_code = 900;
pub const err_code_DMA_ERR_CHAN_BUSY: err_code = 901;
pub const err_code_DMA_ERR_CHAN_IDLE: err_code = 902;
pub const err_code_DMA_ERR_REQUEST_UNFINISHED: err_code = 903;
pub const err_code_DMA_ERR_REQUEST_UNSUPPORTED: err_code = 904;
pub const err_code_DMA_ERR_REQUEST_TOO_LARGE: err_code = 905;
pub const err_code_DMA_ERR_REQUEST_ID: err_code = 906;
pub const err_code_DMA_ERR_ALIGNMENT: err_code = 907;
pub const err_code_DMA_ERR_MEM_OVERLAP: err_code = 908;
pub const err_code_DMA_ERR_MEM_NOT_REGISTERED: err_code = 909;
pub const err_code_DMA_ERR_MEM_OUT_OF_RANGE: err_code = 910;
pub const err_code_DMA_ERR_SVC_REJECT: err_code = 911;
pub const err_code_DMA_ERR_SVC_RESOURCES: err_code = 912;
pub const err_code_DMA_ERR_SVC_VOID: err_code = 913;
pub const err_code_DMA_ERR_SVC_NO_CONNECTION: err_code = 914;
pub const err_code_DMA_ERR_SVC_BUSY: err_code = 915;
pub const err_code_XOMP_ERR_INVALID_WORKER_ARGS: err_code = 916;
pub const err_code_XOMP_ERR_BAD_INVOCATION: err_code = 917;
pub const err_code_XOMP_ERR_INVALID_MSG_FRAME: err_code = 918;
pub const err_code_XOMP_ERR_SPAWN_WORKER_FAILED: err_code = 919;
pub const err_code_XOMP_ERR_MASTER_NOT_INIT: err_code = 920;
pub const err_code_XOMP_ERR_WORKER_INIT_FAILED: err_code = 921;
pub const err_code_XOMP_ERR_WORKER_STATE: err_code = 922;
pub const err_code_XOMP_ERR_INVALID_MEMORY: err_code = 923;
pub const err_code_XOMP_ERR_INVALID_TOKEN: err_code = 924;
pub const err_code_XOMP_ERR_INVALID_ARGUMENTS: err_code = 925;
pub const err_code_NUMA_ERR_NOT_AVAILABLE: err_code = 926;
pub const err_code_NUMA_ERR_BITMAP_PARSE: err_code = 927;
pub const err_code_NUMA_ERR_BITMAP_RANGE: err_code = 928;
pub const err_code_NUMA_ERR_NUMA_MEMBIND: err_code = 929;
pub const err_code_NUMA_ERR_LIB_INIT: err_code = 930;
pub const err_code_NUMA_ERR_SKB: err_code = 931;
pub const err_code_NUMA_ERR_SKB_DATA: err_code = 932;
pub const err_code_NUMA_ERR_NODEID_INVALID: err_code = 933;
pub const err_code_NUMA_ERR_COREID_INVALID: err_code = 934;
pub const err_code_CPUID_ERR_UNSUPPORTED_FUNCTION: err_code = 935;
pub const err_code_CPUID_ERR_UNKNOWN_VENDOR: err_code = 936;
pub const err_code_CPUID_ERR_INVALID_INDEX: err_code = 937;
pub const err_code_DEVQ_ERR_INIT_QUEUE: err_code = 938;
pub const err_code_DEVQ_ERR_BUFFER_ID: err_code = 939;
pub const err_code_DEVQ_ERR_BUFFER_NOT_IN_REGION: err_code = 940;
pub const err_code_DEVQ_ERR_BUFFER_ALREADY_IN_USE: err_code = 941;
pub const err_code_DEVQ_ERR_BUFFER_NOT_IN_USE: err_code = 942;
pub const err_code_DEVQ_ERR_INVALID_BUFFER_ARGS: err_code = 943;
pub const err_code_DEVQ_ERR_INVALID_REGION_ID: err_code = 944;
pub const err_code_DEVQ_ERR_REGION_DESTROY: err_code = 945;
pub const err_code_DEVQ_ERR_INVALID_REGION_ARGS: err_code = 946;
pub const err_code_DEVQ_ERR_REGISTER_REGION: err_code = 947;
pub const err_code_DEVQ_ERR_QUEUE_EMPTY: err_code = 948;
pub const err_code_DEVQ_ERR_QUEUE_FULL: err_code = 949;
pub const err_code_DEVQ_ERR_DESCQ_INIT: err_code = 950;
pub const err_code_NET_QUEUE_ERR_WRONG_PORT: err_code = 951;
pub const err_code_NET_QUEUE_ERR_WRONG_IP: err_code = 952;
pub const err_code_NET_QUEUE_ERR_CHECKSUM: err_code = 953;
pub const err_code_NET_QUEUE_ERR_NOT_UDP: err_code = 954;
pub const err_code_NET_QUEUE_ERR_UNKNOWN_BUF_TYPE: err_code = 955;
pub const err_code_NIC_ERR_IO: err_code = 956;
pub const err_code_NIC_ERR_INTR: err_code = 957;
pub const err_code_NIC_ERR_NOSYS: err_code = 958;
pub const err_code_NIC_ERR_UNKNOWN: err_code = 959;
pub const err_code_NIC_ERR_TX_PKT: err_code = 960;
pub const err_code_NIC_ERR_RX_PKT: err_code = 961;
pub const err_code_NIC_ERR_RX_DISCARD: err_code = 962;
pub const err_code_NIC_ERR_ALLOC_BUF: err_code = 963;
pub const err_code_NIC_ERR_REGISTER_REGION: err_code = 964;
pub const err_code_NIC_ERR_DEREGISTER_REGION: err_code = 965;
pub const err_code_NIC_ERR_ALLOC_QUEUE: err_code = 966;
pub const err_code_NIC_ERR_ENQUEUE: err_code = 967;
pub const err_code_NIC_ERR_QDRIVER: err_code = 968;
pub const err_code_QSERVICE_ERR_NAME: err_code = 969;
pub const err_code_QSERVICE_ERR_ALREADY_ADDED: err_code = 970;
pub const err_code_QSERVICE_ERR_NOT_FOUND: err_code = 971;
pub const err_code_QSERVICE_ERR_NO_VALID_EP: err_code = 972;
pub const err_code_QSERVICE_ERR_INVALID_CLIENT: err_code = 973;
pub const err_code_QSERVICE_ERR_INVALID_SERVICE: err_code = 974;
pub const err_code_PSCI_ERR_NOT_SUPPORTED: err_code = 975;
pub const err_code_PSCI_ERR_INVALID_PARAMETER: err_code = 976;
pub const err_code_PSCI_ERR_DENIED: err_code = 977;
pub const err_code_PSCI_ERR_ALREADY_ON: err_code = 978;
pub const err_code_PSCI_ERR_ON_PENDING: err_code = 979;
pub const err_code_PSCI_ERR_INTERNAL_FAILURE: err_code = 980;
pub const err_code_PSCI_ERR_NOT_PRESENT: err_code = 981;
pub const err_code_PSCI_ERR_DISABLED: err_code = 982;
pub const err_code_PSCI_ERR_INVALID_ADDRESS: err_code = 983;
pub const err_code_PSCI_ERR_UNKNOWN_ERROR: err_code = 984;
pub const err_code_ARRA_ERR_GUEST_NOT_FOUND: err_code = 985;
pub const err_code_VAS_ERR_CREATE_NAME_CONFLICT: err_code = 986;
pub const err_code_VAS_ERR_NO_PERMISSION: err_code = 987;
pub const err_code_VAS_ERR_NOT_FOUND: err_code = 988;
pub const err_code_VAS_ERR_DETACH_SWITCH: err_code = 989;
pub const err_code_VAS_ERR_ATTACH_STATE: err_code = 990;
pub const err_code_VAS_ERR_SWITCH_NOT_ATTACHED: err_code = 991;
pub const err_code_VAS_ERR_NOT_SUPPORTED: err_code = 992;
pub const err_code_VAS_ERR_OUT_OF_HANDLES: err_code = 993;
pub const err_code_AOS_ERR_LMP_SEND_FAILURE: err_code = 994;
pub const err_code_AOS_ERR_LMP_MSGTYPE_UNKNOWN: err_code = 995;
pub const err_code_ENET_ERR_DEV_RESET: err_code = 996;
pub const err_code_ENET_ERR_PHY_RESET: err_code = 997;
pub const err_code_ENET_ERR_MDIO_WRITE: err_code = 998;
pub const err_code_ENET_ERR_MDIO_READ: err_code = 999;
pub const err_code_LPUART_ERR_INVALID_DEV: err_code = 1000;
pub const err_code_LPUART_ERR_NO_DATA: err_code = 1001;
pub const err_code_LPUART_ERR_RCV_OVERRUN: err_code = 1002;
pub const err_code_SDHC_ERR_UNKOWN_VENDOR: err_code = 1003;
pub const err_code_SDHC_ERR_RESET_TIMEOUT: err_code = 1004;
pub const err_code_SDHC_ERR_CMD_TIMEOUT: err_code = 1005;
pub const err_code_SDHC_ERR_CMD_CONFLICT: err_code = 1006;
pub const err_code_SDHC_ERR_TEST_FAILED: err_code = 1007;
pub const err_code_SDHCD_ERR_BULK_FRAME_SET: err_code = 1008;
pub const err_code_SDHCD_ERR_BULK_FRAME_NOT_SET: err_code = 1009;
pub type err_code = ::std::os::raw::c_uint;
extern "C" {
    pub fn err_getcode(errval: errval_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn err_getdomain(errval: errval_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn err_getstring(errval: errval_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn err_print_calltrace(errval: errval_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct imaxdiv_t {
    pub quot: intmax_t,
    pub rem: intmax_t,
}
#[test]
fn bindgen_test_layout_imaxdiv_t() {
    assert_eq!(
        ::std::mem::size_of::<imaxdiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<imaxdiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<imaxdiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<imaxdiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn imaxabs(arg1: intmax_t) -> intmax_t;
}
extern "C" {
    pub fn imaxdiv(arg1: intmax_t, arg2: intmax_t) -> imaxdiv_t;
}
extern "C" {
    pub fn strtoimax(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn strtoumax(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn wcstoimax(
        arg1: *const wchar_t,
        arg2: *mut *mut wchar_t,
        arg3: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn wcstoumax(
        arg1: *const wchar_t,
        arg2: *mut *mut wchar_t,
        arg3: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
pub type word_t = ::std::os::raw::c_int;
pub type uword_t = ::std::os::raw::c_uint;
pub type lpaddr_t = usize;
pub type genpaddr_t = u64;
pub type gensize_t = u64;
pub type lvaddr_t = usize;
pub type genvaddr_t = u64;
pub type forvaddr_t = genvaddr_t;
pub type capaddr_t = u32;
pub type pasid_t = u32;
pub type cslot_t = capaddr_t;
pub type coreid_t = u8;
pub type nodeid_t = coreid_t;
pub type hwid_t = usize;
pub type idcap_id_t = u64;
pub type rsrcid_t = u32;
pub type domainid_t = u32;
pub type perfmon_counter_t = u8;
pub type perfmon_event_t = u64;
pub type perfmon_mask_t = u64;
#[doc = " Absolute system wallclock time in ticks"]
pub type systime_t = u64;
pub type CapRights = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcb {
    _unused: [u8; 0],
}
pub const objtype_ObjType_Num: objtype = 68;
pub const objtype_ObjType_DeviceID: objtype = 67;
pub const objtype_ObjType_DeviceIDManager: objtype = 66;
pub const objtype_ObjType_Domain: objtype = 65;
pub const objtype_ObjType_ProcessManager: objtype = 64;
pub const objtype_ObjType_IPI: objtype = 63;
pub const objtype_ObjType_KernelControlBlock: objtype = 62;
pub const objtype_ObjType_PerfMon: objtype = 61;
pub const objtype_ObjType_ID: objtype = 60;
pub const objtype_ObjType_Notify_IPI: objtype = 59;
pub const objtype_ObjType_IO: objtype = 58;
pub const objtype_ObjType_IRQSrc: objtype = 57;
pub const objtype_ObjType_IRQDest: objtype = 56;
pub const objtype_ObjType_IRQTable: objtype = 55;
pub const objtype_ObjType_VNode_AARCH64_l3_Mapping: objtype = 54;
pub const objtype_ObjType_VNode_AARCH64_l3: objtype = 53;
pub const objtype_ObjType_VNode_AARCH64_l2_Mapping: objtype = 52;
pub const objtype_ObjType_VNode_AARCH64_l2: objtype = 51;
pub const objtype_ObjType_VNode_AARCH64_l1_Mapping: objtype = 50;
pub const objtype_ObjType_VNode_AARCH64_l1: objtype = 49;
pub const objtype_ObjType_VNode_AARCH64_l0_Mapping: objtype = 48;
pub const objtype_ObjType_VNode_AARCH64_l0: objtype = 47;
pub const objtype_ObjType_VNode_ARM_l2_Mapping: objtype = 46;
pub const objtype_ObjType_VNode_ARM_l2: objtype = 45;
pub const objtype_ObjType_VNode_ARM_l1_Mapping: objtype = 44;
pub const objtype_ObjType_VNode_ARM_l1: objtype = 43;
pub const objtype_ObjType_VNode_x86_32_ptable_Mapping: objtype = 42;
pub const objtype_ObjType_VNode_x86_32_ptable: objtype = 41;
pub const objtype_ObjType_VNode_x86_32_pdir_Mapping: objtype = 40;
pub const objtype_ObjType_VNode_x86_32_pdir: objtype = 39;
pub const objtype_ObjType_VNode_x86_32_pdpt_Mapping: objtype = 38;
pub const objtype_ObjType_VNode_x86_32_pdpt: objtype = 37;
pub const objtype_ObjType_VNode_VTd_ctxt_table_Mapping: objtype = 36;
pub const objtype_ObjType_VNode_VTd_ctxt_table: objtype = 35;
pub const objtype_ObjType_VNode_VTd_root_table_Mapping: objtype = 34;
pub const objtype_ObjType_VNode_VTd_root_table: objtype = 33;
pub const objtype_ObjType_VNode_x86_64_ept_ptable_Mapping: objtype = 32;
pub const objtype_ObjType_VNode_x86_64_ept_ptable: objtype = 31;
pub const objtype_ObjType_VNode_x86_64_ept_pdir_Mapping: objtype = 30;
pub const objtype_ObjType_VNode_x86_64_ept_pdir: objtype = 29;
pub const objtype_ObjType_VNode_x86_64_ept_pdpt_Mapping: objtype = 28;
pub const objtype_ObjType_VNode_x86_64_ept_pdpt: objtype = 27;
pub const objtype_ObjType_VNode_x86_64_ept_pml4_Mapping: objtype = 26;
pub const objtype_ObjType_VNode_x86_64_ept_pml4: objtype = 25;
pub const objtype_ObjType_VNode_x86_64_ptable_Mapping: objtype = 24;
pub const objtype_ObjType_VNode_x86_64_ptable: objtype = 23;
pub const objtype_ObjType_VNode_x86_64_pdir_Mapping: objtype = 22;
pub const objtype_ObjType_VNode_x86_64_pdir: objtype = 21;
pub const objtype_ObjType_VNode_x86_64_pdpt_Mapping: objtype = 20;
pub const objtype_ObjType_VNode_x86_64_pdpt: objtype = 19;
pub const objtype_ObjType_VNode_x86_64_pml4_Mapping: objtype = 18;
pub const objtype_ObjType_VNode_x86_64_pml4: objtype = 17;
pub const objtype_ObjType_VNode_x86_64_pml5_Mapping: objtype = 16;
pub const objtype_ObjType_VNode_x86_64_pml5: objtype = 15;
pub const objtype_ObjType_Kernel: objtype = 14;
pub const objtype_ObjType_DevFrame_Mapping: objtype = 13;
pub const objtype_ObjType_DevFrame: objtype = 12;
pub const objtype_ObjType_EndPointUMP_Mapping: objtype = 11;
pub const objtype_ObjType_EndPointUMP: objtype = 10;
pub const objtype_ObjType_Frame_Mapping: objtype = 9;
pub const objtype_ObjType_Frame: objtype = 8;
pub const objtype_ObjType_EndPointLMP: objtype = 7;
pub const objtype_ObjType_Dispatcher: objtype = 6;
pub const objtype_ObjType_FCNode: objtype = 5;
pub const objtype_ObjType_L2CNode: objtype = 4;
pub const objtype_ObjType_L1CNode: objtype = 3;
pub const objtype_ObjType_RAM: objtype = 2;
pub const objtype_ObjType_PhysAddr: objtype = 1;
pub const objtype_ObjType_Null: objtype = 0;
pub type objtype = ::std::os::raw::c_uchar;
pub const objdefines_OBJSIZE_L2CNODE: objdefines = 16384;
pub const objdefines_OBJSIZE_DISPATCHER: objdefines = 1024;
pub const objdefines_OBJSIZE_VNODE: objdefines = 4096;
pub const objdefines_OBJSIZE_VNODE_ARM_L1: objdefines = 16384;
pub const objdefines_OBJSIZE_VNODE_ARM_L2: objdefines = 1024;
pub const objdefines_OBJSIZE_KCB: objdefines = 131072;
pub const objdefines_OBJSIZE_MAPPING: objdefines = 1;
pub type objdefines = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Null {}
#[test]
fn bindgen_test_layout_Null() {
    assert_eq!(
        ::std::mem::size_of::<Null>(),
        0usize,
        concat!("Size of: ", stringify!(Null))
    );
    assert_eq!(
        ::std::mem::align_of::<Null>(),
        1usize,
        concat!("Alignment of ", stringify!(Null))
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PhysAddr {
    pub base: genpaddr_t,
    pub bytes: gensize_t,
    pub pasid: pasid_t,
}
#[test]
fn bindgen_test_layout_PhysAddr() {
    assert_eq!(
        ::std::mem::size_of::<PhysAddr>(),
        20usize,
        concat!("Size of: ", stringify!(PhysAddr))
    );
    assert_eq!(
        ::std::mem::align_of::<PhysAddr>(),
        1usize,
        concat!("Alignment of ", stringify!(PhysAddr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PhysAddr>())).base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PhysAddr),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PhysAddr>())).bytes as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PhysAddr),
            "::",
            stringify!(bytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PhysAddr>())).pasid as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PhysAddr),
            "::",
            stringify!(pasid)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct RAM {
    pub base: genpaddr_t,
    pub bytes: gensize_t,
    pub pasid: pasid_t,
}
#[test]
fn bindgen_test_layout_RAM() {
    assert_eq!(
        ::std::mem::size_of::<RAM>(),
        20usize,
        concat!("Size of: ", stringify!(RAM))
    );
    assert_eq!(
        ::std::mem::align_of::<RAM>(),
        1usize,
        concat!("Alignment of ", stringify!(RAM))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RAM>())).base as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(RAM), "::", stringify!(base))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RAM>())).bytes as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RAM),
            "::",
            stringify!(bytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RAM>())).pasid as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RAM),
            "::",
            stringify!(pasid)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct L1CNode {
    pub cnode: lpaddr_t,
    pub rightsmask: CapRights,
    pub allocated_bytes: gensize_t,
}
#[test]
fn bindgen_test_layout_L1CNode() {
    assert_eq!(
        ::std::mem::size_of::<L1CNode>(),
        17usize,
        concat!("Size of: ", stringify!(L1CNode))
    );
    assert_eq!(
        ::std::mem::align_of::<L1CNode>(),
        1usize,
        concat!("Alignment of ", stringify!(L1CNode))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L1CNode>())).cnode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L1CNode),
            "::",
            stringify!(cnode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L1CNode>())).rightsmask as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L1CNode),
            "::",
            stringify!(rightsmask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L1CNode>())).allocated_bytes as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(L1CNode),
            "::",
            stringify!(allocated_bytes)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct L2CNode {
    pub cnode: lpaddr_t,
    pub rightsmask: CapRights,
}
#[test]
fn bindgen_test_layout_L2CNode() {
    assert_eq!(
        ::std::mem::size_of::<L2CNode>(),
        9usize,
        concat!("Size of: ", stringify!(L2CNode))
    );
    assert_eq!(
        ::std::mem::align_of::<L2CNode>(),
        1usize,
        concat!("Alignment of ", stringify!(L2CNode))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L2CNode>())).cnode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L2CNode),
            "::",
            stringify!(cnode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L2CNode>())).rightsmask as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L2CNode),
            "::",
            stringify!(rightsmask)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct FCNode {
    pub cnode: genpaddr_t,
    pub bits: u8,
    pub rightsmask: CapRights,
    pub core_id: coreid_t,
    pub guard_size: u8,
    pub guard: capaddr_t,
}
#[test]
fn bindgen_test_layout_FCNode() {
    assert_eq!(
        ::std::mem::size_of::<FCNode>(),
        16usize,
        concat!("Size of: ", stringify!(FCNode))
    );
    assert_eq!(
        ::std::mem::align_of::<FCNode>(),
        1usize,
        concat!("Alignment of ", stringify!(FCNode))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FCNode>())).cnode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FCNode),
            "::",
            stringify!(cnode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FCNode>())).bits as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FCNode),
            "::",
            stringify!(bits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FCNode>())).rightsmask as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(FCNode),
            "::",
            stringify!(rightsmask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FCNode>())).core_id as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(FCNode),
            "::",
            stringify!(core_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FCNode>())).guard_size as *const _ as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(FCNode),
            "::",
            stringify!(guard_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FCNode>())).guard as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(FCNode),
            "::",
            stringify!(guard)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct Dispatcher {
    pub dcb: *mut dcb,
}
#[test]
fn bindgen_test_layout_Dispatcher() {
    assert_eq!(
        ::std::mem::size_of::<Dispatcher>(),
        8usize,
        concat!("Size of: ", stringify!(Dispatcher))
    );
    assert_eq!(
        ::std::mem::align_of::<Dispatcher>(),
        1usize,
        concat!("Alignment of ", stringify!(Dispatcher))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Dispatcher>())).dcb as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Dispatcher),
            "::",
            stringify!(dcb)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct EndPointLMP {
    pub listener: *mut dcb,
    pub epoffset: lvaddr_t,
    pub epbuflen: u32,
    pub iftype: u16,
}
#[test]
fn bindgen_test_layout_EndPointLMP() {
    assert_eq!(
        ::std::mem::size_of::<EndPointLMP>(),
        22usize,
        concat!("Size of: ", stringify!(EndPointLMP))
    );
    assert_eq!(
        ::std::mem::align_of::<EndPointLMP>(),
        1usize,
        concat!("Alignment of ", stringify!(EndPointLMP))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EndPointLMP>())).listener as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EndPointLMP),
            "::",
            stringify!(listener)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EndPointLMP>())).epoffset as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(EndPointLMP),
            "::",
            stringify!(epoffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EndPointLMP>())).epbuflen as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(EndPointLMP),
            "::",
            stringify!(epbuflen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EndPointLMP>())).iftype as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(EndPointLMP),
            "::",
            stringify!(iftype)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct Frame {
    pub base: genpaddr_t,
    pub bytes: gensize_t,
    pub pasid: pasid_t,
}
#[test]
fn bindgen_test_layout_Frame() {
    assert_eq!(
        ::std::mem::size_of::<Frame>(),
        20usize,
        concat!("Size of: ", stringify!(Frame))
    );
    assert_eq!(
        ::std::mem::align_of::<Frame>(),
        1usize,
        concat!("Alignment of ", stringify!(Frame))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Frame>())).base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Frame),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Frame>())).bytes as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Frame),
            "::",
            stringify!(bytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Frame>())).pasid as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Frame),
            "::",
            stringify!(pasid)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct Frame_Mapping {
    pub cap: *mut capability,
    pub ptable: *mut cte,
    pub entry: u16,
    pub pte_count: u16,
}
#[test]
fn bindgen_test_layout_Frame_Mapping() {
    assert_eq!(
        ::std::mem::size_of::<Frame_Mapping>(),
        20usize,
        concat!("Size of: ", stringify!(Frame_Mapping))
    );
    assert_eq!(
        ::std::mem::align_of::<Frame_Mapping>(),
        1usize,
        concat!("Alignment of ", stringify!(Frame_Mapping))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Frame_Mapping>())).cap as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Frame_Mapping),
            "::",
            stringify!(cap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Frame_Mapping>())).ptable as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Frame_Mapping),
            "::",
            stringify!(ptable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Frame_Mapping>())).entry as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Frame_Mapping),
            "::",
            stringify!(entry)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Frame_Mapping>())).pte_count as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(Frame_Mapping),
            "::",
            stringify!(pte_count)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct EndPointUMP {
    pub base: genpaddr_t,
    pub bytes: gensize_t,
    pub pasid: pasid_t,
    pub iftype: u16,
}
#[test]
fn bindgen_test_layout_EndPointUMP() {
    assert_eq!(
        ::std::mem::size_of::<EndPointUMP>(),
        22usize,
        concat!("Size of: ", stringify!(EndPointUMP))
    );
    assert_eq!(
        ::std::mem::align_of::<EndPointUMP>(),
        1usize,
        concat!("Alignment of ", stringify!(EndPointUMP))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EndPointUMP>())).base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EndPointUMP),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EndPointUMP>())).bytes as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(EndPointUMP),
            "::",
            stringify!(bytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EndPointUMP>())).pasid as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(EndPointUMP),
            "::",
            stringify!(pasid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EndPointUMP>())).iftype as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(EndPointUMP),
            "::",
            stringify!(iftype)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct EndPointUMP_Mapping {
    pub cap: *mut capability,
    pub ptable: *mut cte,
    pub entry: u16,
    pub pte_count: u16,
}
#[test]
fn bindgen_test_layout_EndPointUMP_Mapping() {
    assert_eq!(
        ::std::mem::size_of::<EndPointUMP_Mapping>(),
        20usize,
        concat!("Size of: ", stringify!(EndPointUMP_Mapping))
    );
    assert_eq!(
        ::std::mem::align_of::<EndPointUMP_Mapping>(),
        1usize,
        concat!("Alignment of ", stringify!(EndPointUMP_Mapping))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EndPointUMP_Mapping>())).cap as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EndPointUMP_Mapping),
            "::",
            stringify!(cap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EndPointUMP_Mapping>())).ptable as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(EndPointUMP_Mapping),
            "::",
            stringify!(ptable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EndPointUMP_Mapping>())).entry as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(EndPointUMP_Mapping),
            "::",
            stringify!(entry)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EndPointUMP_Mapping>())).pte_count as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(EndPointUMP_Mapping),
            "::",
            stringify!(pte_count)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct DevFrame {
    pub base: genpaddr_t,
    pub bytes: gensize_t,
    pub pasid: pasid_t,
}
#[test]
fn bindgen_test_layout_DevFrame() {
    assert_eq!(
        ::std::mem::size_of::<DevFrame>(),
        20usize,
        concat!("Size of: ", stringify!(DevFrame))
    );
    assert_eq!(
        ::std::mem::align_of::<DevFrame>(),
        1usize,
        concat!("Alignment of ", stringify!(DevFrame))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DevFrame>())).base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DevFrame),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DevFrame>())).bytes as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DevFrame),
            "::",
            stringify!(bytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DevFrame>())).pasid as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(DevFrame),
            "::",
            stringify!(pasid)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct DevFrame_Mapping {
    pub cap: *mut capability,
    pub ptable: *mut cte,
    pub entry: u16,
    pub pte_count: u16,
}
#[test]
fn bindgen_test_layout_DevFrame_Mapping() {
    assert_eq!(
        ::std::mem::size_of::<DevFrame_Mapping>(),
        20usize,
        concat!("Size of: ", stringify!(DevFrame_Mapping))
    );
    assert_eq!(
        ::std::mem::align_of::<DevFrame_Mapping>(),
        1usize,
        concat!("Alignment of ", stringify!(DevFrame_Mapping))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DevFrame_Mapping>())).cap as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DevFrame_Mapping),
            "::",
            stringify!(cap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DevFrame_Mapping>())).ptable as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DevFrame_Mapping),
            "::",
            stringify!(ptable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DevFrame_Mapping>())).entry as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(DevFrame_Mapping),
            "::",
            stringify!(entry)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DevFrame_Mapping>())).pte_count as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(DevFrame_Mapping),
            "::",
            stringify!(pte_count)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Kernel {}
#[test]
fn bindgen_test_layout_Kernel() {
    assert_eq!(
        ::std::mem::size_of::<Kernel>(),
        0usize,
        concat!("Size of: ", stringify!(Kernel))
    );
    assert_eq!(
        ::std::mem::align_of::<Kernel>(),
        1usize,
        concat!("Alignment of ", stringify!(Kernel))
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct VNode_x86_64_pml5 {
    pub base: genpaddr_t,
}
#[test]
fn bindgen_test_layout_VNode_x86_64_pml5() {
    assert_eq!(
        ::std::mem::size_of::<VNode_x86_64_pml5>(),
        8usize,
        concat!("Size of: ", stringify!(VNode_x86_64_pml5))
    );
    assert_eq!(
        ::std::mem::align_of::<VNode_x86_64_pml5>(),
        1usize,
        concat!("Alignment of ", stringify!(VNode_x86_64_pml5))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VNode_x86_64_pml5>())).base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VNode_x86_64_pml5),
            "::",
            stringify!(base)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct VNode_x86_64_pml5_Mapping {
    pub cap: *mut capability,
    pub ptable: *mut cte,
    pub entry: u16,
    pub pte_count: u16,
}
#[test]
fn bindgen_test_layout_VNode_x86_64_pml5_Mapping() {
    assert_eq!(
        ::std::mem::size_of::<VNode_x86_64_pml5_Mapping>(),
        20usize,
        concat!("Size of: ", stringify!(VNode_x86_64_pml5_Mapping))
    );
    assert_eq!(
        ::std::mem::align_of::<VNode_x86_64_pml5_Mapping>(),
        1usize,
        concat!("Alignment of ", stringify!(VNode_x86_64_pml5_Mapping))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VNode_x86_64_pml5_Mapping>())).cap as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VNode_x86_64_pml5_Mapping),
            "::",
            stringify!(cap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VNode_x86_64_pml5_Mapping>())).ptable as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VNode_x86_64_pml5_Mapping),
            "::",
            stringify!(ptable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VNode_x86_64_pml5_Mapping>())).entry as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VNode_x86_64_pml5_Mapping),
            "::",
            stringify!(entry)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VNode_x86_64_pml5_Mapping>())).pte_count as *const _ as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(VNode_x86_64_pml5_Mapping),
            "::",
            stringify!(pte_count)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct VNode_x86_64_pml4 {
    pub base: genpaddr_t,
}
#[test]
fn bindgen_test_layout_VNode_x86_64_pml4() {
    assert_eq!(
        ::std::mem::size_of::<VNode_x86_64_pml4>(),
        8usize,
        concat!("Size of: ", stringify!(VNode_x86_64_pml4))
    );
    assert_eq!(
        ::std::mem::align_of::<VNode_x86_64_pml4>(),
        1usize,
        concat!("Alignment of ", stringify!(VNode_x86_64_pml4))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VNode_x86_64_pml4>())).base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VNode_x86_64_pml4),
            "::",
            stringify!(base)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct VNode_x86_64_pml4_Mapping {
    pub cap: *mut capability,
    pub ptable: *mut cte,
    pub entry: u16,
    pub pte_count: u16,
}
#[test]
fn bindgen_test_layout_VNode_x86_64_pml4_Mapping() {
    assert_eq!(
        ::std::mem::size_of::<VNode_x86_64_pml4_Mapping>(),
        20usize,
        concat!("Size of: ", stringify!(VNode_x86_64_pml4_Mapping))
    );
    assert_eq!(
        ::std::mem::align_of::<VNode_x86_64_pml4_Mapping>(),
        1usize,
        concat!("Alignment of ", stringify!(VNode_x86_64_pml4_Mapping))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VNode_x86_64_pml4_Mapping>())).cap as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VNode_x86_64_pml4_Mapping),
            "::",
            stringify!(cap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VNode_x86_64_pml4_Mapping>())).ptable as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VNode_x86_64_pml4_Mapping),
            "::",
            stringify!(ptable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VNode_x86_64_pml4_Mapping>())).entry as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VNode_x86_64_pml4_Mapping),
            "::",
            stringify!(entry)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VNode_x86_64_pml4_Mapping>())).pte_count as *const _ as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(VNode_x86_64_pml4_Mapping),
            "::",
            stringify!(pte_count)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct VNode_x86_64_pdpt {
    pub base: genpaddr_t,
}
#[test]
fn bindgen_test_layout_VNode_x86_64_pdpt() {
    assert_eq!(
        ::std::mem::size_of::<VNode_x86_64_pdpt>(),
        8usize,
        concat!("Size of: ", stringify!(VNode_x86_64_pdpt))
    );
    assert_eq!(
        ::std::mem::align_of::<VNode_x86_64_pdpt>(),
        1usize,
        concat!("Alignment of ", stringify!(VNode_x86_64_pdpt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VNode_x86_64_pdpt>())).base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VNode_x86_64_pdpt),
            "::",
            stringify!(base)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct VNode_x86_64_pdpt_Mapping {
    pub cap: *mut capability,
    pub ptable: *mut cte,
    pub entry: u16,
    pub pte_count: u16,
}
#[test]
fn bindgen_test_layout_VNode_x86_64_pdpt_Mapping() {
    assert_eq!(
        ::std::mem::size_of::<VNode_x86_64_pdpt_Mapping>(),
        20usize,
        concat!("Size of: ", stringify!(VNode_x86_64_pdpt_Mapping))
    );
    assert_eq!(
        ::std::mem::align_of::<VNode_x86_64_pdpt_Mapping>(),
        1usize,
        concat!("Alignment of ", stringify!(VNode_x86_64_pdpt_Mapping))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VNode_x86_64_pdpt_Mapping>())).cap as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VNode_x86_64_pdpt_Mapping),
            "::",
            stringify!(cap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VNode_x86_64_pdpt_Mapping>())).ptable as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VNode_x86_64_pdpt_Mapping),
            "::",
            stringify!(ptable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VNode_x86_64_pdpt_Mapping>())).entry as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VNode_x86_64_pdpt_Mapping),
            "::",
            stringify!(entry)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VNode_x86_64_pdpt_Mapping>())).pte_count as *const _ as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(VNode_x86_64_pdpt_Mapping),
            "::",
            stringify!(pte_count)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct VNode_x86_64_pdir {
    pub base: genpaddr_t,
}
#[test]
fn bindgen_test_layout_VNode_x86_64_pdir() {
    assert_eq!(
        ::std::mem::size_of::<VNode_x86_64_pdir>(),
        8usize,
        concat!("Size of: ", stringify!(VNode_x86_64_pdir))
    );
    assert_eq!(
        ::std::mem::align_of::<VNode_x86_64_pdir>(),
        1usize,
        concat!("Alignment of ", stringify!(VNode_x86_64_pdir))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VNode_x86_64_pdir>())).base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VNode_x86_64_pdir),
            "::",
            stringify!(base)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct VNode_x86_64_pdir_Mapping {
    pub cap: *mut capability,
    pub ptable: *mut cte,
    pub entry: u16,
    pub pte_count: u16,
}
#[test]
fn bindgen_test_layout_VNode_x86_64_pdir_Mapping() {
    assert_eq!(
        ::std::mem::size_of::<VNode_x86_64_pdir_Mapping>(),
        20usize,
        concat!("Size of: ", stringify!(VNode_x86_64_pdir_Mapping))
    );
    assert_eq!(
        ::std::mem::align_of::<VNode_x86_64_pdir_Mapping>(),
        1usize,
        concat!("Alignment of ", stringify!(VNode_x86_64_pdir_Mapping))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VNode_x86_64_pdir_Mapping>())).cap as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VNode_x86_64_pdir_Mapping),
            "::",
            stringify!(cap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VNode_x86_64_pdir_Mapping>())).ptable as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VNode_x86_64_pdir_Mapping),
            "::",
            stringify!(ptable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VNode_x86_64_pdir_Mapping>())).entry as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VNode_x86_64_pdir_Mapping),
            "::",
            stringify!(entry)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VNode_x86_64_pdir_Mapping>())).pte_count as *const _ as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(VNode_x86_64_pdir_Mapping),
            "::",
            stringify!(pte_count)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct VNode_x86_64_ptable {
    pub base: genpaddr_t,
}
#[test]
fn bindgen_test_layout_VNode_x86_64_ptable() {
    assert_eq!(
        ::std::mem::size_of::<VNode_x86_64_ptable>(),
        8usize,
        concat!("Size of: ", stringify!(VNode_x86_64_ptable))
    );
    assert_eq!(
        ::std::mem::align_of::<VNode_x86_64_ptable>(),
        1usize,
        concat!("Alignment of ", stringify!(VNode_x86_64_ptable))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VNode_x86_64_ptable>())).base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VNode_x86_64_ptable),
            "::",
            stringify!(base)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct VNode_x86_64_ptable_Mapping {
    pub cap: *mut capability,
    pub ptable: *mut cte,
    pub entry: u16,
    pub pte_count: u16,
}
#[test]
fn bindgen_test_layout_VNode_x86_64_ptable_Mapping() {
    assert_eq!(
        ::std::mem::size_of::<VNode_x86_64_ptable_Mapping>(),
        20usize,
        concat!("Size of: ", stringify!(VNode_x86_64_ptable_Mapping))
    );
    assert_eq!(
        ::std::mem::align_of::<VNode_x86_64_ptable_Mapping>(),
        1usize,
        concat!("Alignment of ", stringify!(VNode_x86_64_ptable_Mapping))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VNode_x86_64_ptable_Mapping>())).cap as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VNode_x86_64_ptable_Mapping),
            "::",
            stringify!(cap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VNode_x86_64_ptable_Mapping>())).ptable as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VNode_x86_64_ptable_Mapping),
            "::",
            stringify!(ptable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VNode_x86_64_ptable_Mapping>())).entry as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VNode_x86_64_ptable_Mapping),
            "::",
            stringify!(entry)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VNode_x86_64_ptable_Mapping>())).pte_count as *const _ as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(VNode_x86_64_ptable_Mapping),
            "::",
            stringify!(pte_count)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct VNode_x86_64_ept_pml4 {
    pub base: genpaddr_t,
}
#[test]
fn bindgen_test_layout_VNode_x86_64_ept_pml4() {
    assert_eq!(
        ::std::mem::size_of::<VNode_x86_64_ept_pml4>(),
        8usize,
        concat!("Size of: ", stringify!(VNode_x86_64_ept_pml4))
    );
    assert_eq!(
        ::std::mem::align_of::<VNode_x86_64_ept_pml4>(),
        1usize,
        concat!("Alignment of ", stringify!(VNode_x86_64_ept_pml4))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VNode_x86_64_ept_pml4>())).base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VNode_x86_64_ept_pml4),
            "::",
            stringify!(base)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct VNode_x86_64_ept_pml4_Mapping {
    pub cap: *mut capability,
    pub ptable: *mut cte,
    pub entry: u16,
    pub pte_count: u16,
}
#[test]
fn bindgen_test_layout_VNode_x86_64_ept_pml4_Mapping() {
    assert_eq!(
        ::std::mem::size_of::<VNode_x86_64_ept_pml4_Mapping>(),
        20usize,
        concat!("Size of: ", stringify!(VNode_x86_64_ept_pml4_Mapping))
    );
    assert_eq!(
        ::std::mem::align_of::<VNode_x86_64_ept_pml4_Mapping>(),
        1usize,
        concat!("Alignment of ", stringify!(VNode_x86_64_ept_pml4_Mapping))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VNode_x86_64_ept_pml4_Mapping>())).cap as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VNode_x86_64_ept_pml4_Mapping),
            "::",
            stringify!(cap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VNode_x86_64_ept_pml4_Mapping>())).ptable as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VNode_x86_64_ept_pml4_Mapping),
            "::",
            stringify!(ptable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VNode_x86_64_ept_pml4_Mapping>())).entry as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VNode_x86_64_ept_pml4_Mapping),
            "::",
            stringify!(entry)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VNode_x86_64_ept_pml4_Mapping>())).pte_count as *const _ as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(VNode_x86_64_ept_pml4_Mapping),
            "::",
            stringify!(pte_count)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct VNode_x86_64_ept_pdpt {
    pub base: genpaddr_t,
}
#[test]
fn bindgen_test_layout_VNode_x86_64_ept_pdpt() {
    assert_eq!(
        ::std::mem::size_of::<VNode_x86_64_ept_pdpt>(),
        8usize,
        concat!("Size of: ", stringify!(VNode_x86_64_ept_pdpt))
    );
    assert_eq!(
        ::std::mem::align_of::<VNode_x86_64_ept_pdpt>(),
        1usize,
        concat!("Alignment of ", stringify!(VNode_x86_64_ept_pdpt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VNode_x86_64_ept_pdpt>())).base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VNode_x86_64_ept_pdpt),
            "::",
            stringify!(base)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct VNode_x86_64_ept_pdpt_Mapping {
    pub cap: *mut capability,
    pub ptable: *mut cte,
    pub entry: u16,
    pub pte_count: u16,
}
#[test]
fn bindgen_test_layout_VNode_x86_64_ept_pdpt_Mapping() {
    assert_eq!(
        ::std::mem::size_of::<VNode_x86_64_ept_pdpt_Mapping>(),
        20usize,
        concat!("Size of: ", stringify!(VNode_x86_64_ept_pdpt_Mapping))
    );
    assert_eq!(
        ::std::mem::align_of::<VNode_x86_64_ept_pdpt_Mapping>(),
        1usize,
        concat!("Alignment of ", stringify!(VNode_x86_64_ept_pdpt_Mapping))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VNode_x86_64_ept_pdpt_Mapping>())).cap as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VNode_x86_64_ept_pdpt_Mapping),
            "::",
            stringify!(cap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VNode_x86_64_ept_pdpt_Mapping>())).ptable as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VNode_x86_64_ept_pdpt_Mapping),
            "::",
            stringify!(ptable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VNode_x86_64_ept_pdpt_Mapping>())).entry as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VNode_x86_64_ept_pdpt_Mapping),
            "::",
            stringify!(entry)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VNode_x86_64_ept_pdpt_Mapping>())).pte_count as *const _ as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(VNode_x86_64_ept_pdpt_Mapping),
            "::",
            stringify!(pte_count)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct VNode_x86_64_ept_pdir {
    pub base: genpaddr_t,
}
#[test]
fn bindgen_test_layout_VNode_x86_64_ept_pdir() {
    assert_eq!(
        ::std::mem::size_of::<VNode_x86_64_ept_pdir>(),
        8usize,
        concat!("Size of: ", stringify!(VNode_x86_64_ept_pdir))
    );
    assert_eq!(
        ::std::mem::align_of::<VNode_x86_64_ept_pdir>(),
        1usize,
        concat!("Alignment of ", stringify!(VNode_x86_64_ept_pdir))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VNode_x86_64_ept_pdir>())).base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VNode_x86_64_ept_pdir),
            "::",
            stringify!(base)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct VNode_x86_64_ept_pdir_Mapping {
    pub cap: *mut capability,
    pub ptable: *mut cte,
    pub entry: u16,
    pub pte_count: u16,
}
#[test]
fn bindgen_test_layout_VNode_x86_64_ept_pdir_Mapping() {
    assert_eq!(
        ::std::mem::size_of::<VNode_x86_64_ept_pdir_Mapping>(),
        20usize,
        concat!("Size of: ", stringify!(VNode_x86_64_ept_pdir_Mapping))
    );
    assert_eq!(
        ::std::mem::align_of::<VNode_x86_64_ept_pdir_Mapping>(),
        1usize,
        concat!("Alignment of ", stringify!(VNode_x86_64_ept_pdir_Mapping))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VNode_x86_64_ept_pdir_Mapping>())).cap as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VNode_x86_64_ept_pdir_Mapping),
            "::",
            stringify!(cap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VNode_x86_64_ept_pdir_Mapping>())).ptable as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VNode_x86_64_ept_pdir_Mapping),
            "::",
            stringify!(ptable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VNode_x86_64_ept_pdir_Mapping>())).entry as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VNode_x86_64_ept_pdir_Mapping),
            "::",
            stringify!(entry)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VNode_x86_64_ept_pdir_Mapping>())).pte_count as *const _ as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(VNode_x86_64_ept_pdir_Mapping),
            "::",
            stringify!(pte_count)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct VNode_x86_64_ept_ptable {
    pub base: genpaddr_t,
}
#[test]
fn bindgen_test_layout_VNode_x86_64_ept_ptable() {
    assert_eq!(
        ::std::mem::size_of::<VNode_x86_64_ept_ptable>(),
        8usize,
        concat!("Size of: ", stringify!(VNode_x86_64_ept_ptable))
    );
    assert_eq!(
        ::std::mem::align_of::<VNode_x86_64_ept_ptable>(),
        1usize,
        concat!("Alignment of ", stringify!(VNode_x86_64_ept_ptable))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VNode_x86_64_ept_ptable>())).base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VNode_x86_64_ept_ptable),
            "::",
            stringify!(base)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct VNode_x86_64_ept_ptable_Mapping {
    pub cap: *mut capability,
    pub ptable: *mut cte,
    pub entry: u16,
    pub pte_count: u16,
}
#[test]
fn bindgen_test_layout_VNode_x86_64_ept_ptable_Mapping() {
    assert_eq!(
        ::std::mem::size_of::<VNode_x86_64_ept_ptable_Mapping>(),
        20usize,
        concat!("Size of: ", stringify!(VNode_x86_64_ept_ptable_Mapping))
    );
    assert_eq!(
        ::std::mem::align_of::<VNode_x86_64_ept_ptable_Mapping>(),
        1usize,
        concat!("Alignment of ", stringify!(VNode_x86_64_ept_ptable_Mapping))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VNode_x86_64_ept_ptable_Mapping>())).cap as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VNode_x86_64_ept_ptable_Mapping),
            "::",
            stringify!(cap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VNode_x86_64_ept_ptable_Mapping>())).ptable as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VNode_x86_64_ept_ptable_Mapping),
            "::",
            stringify!(ptable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VNode_x86_64_ept_ptable_Mapping>())).entry as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VNode_x86_64_ept_ptable_Mapping),
            "::",
            stringify!(entry)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VNode_x86_64_ept_ptable_Mapping>())).pte_count as *const _
                as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(VNode_x86_64_ept_ptable_Mapping),
            "::",
            stringify!(pte_count)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct VNode_VTd_root_table {
    pub base: genpaddr_t,
}
#[test]
fn bindgen_test_layout_VNode_VTd_root_table() {
    assert_eq!(
        ::std::mem::size_of::<VNode_VTd_root_table>(),
        8usize,
        concat!("Size of: ", stringify!(VNode_VTd_root_table))
    );
    assert_eq!(
        ::std::mem::align_of::<VNode_VTd_root_table>(),
        1usize,
        concat!("Alignment of ", stringify!(VNode_VTd_root_table))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VNode_VTd_root_table>())).base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VNode_VTd_root_table),
            "::",
            stringify!(base)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct VNode_VTd_root_table_Mapping {
    pub cap: *mut capability,
    pub ptable: *mut cte,
    pub entry: u16,
    pub pte_count: u16,
}
#[test]
fn bindgen_test_layout_VNode_VTd_root_table_Mapping() {
    assert_eq!(
        ::std::mem::size_of::<VNode_VTd_root_table_Mapping>(),
        20usize,
        concat!("Size of: ", stringify!(VNode_VTd_root_table_Mapping))
    );
    assert_eq!(
        ::std::mem::align_of::<VNode_VTd_root_table_Mapping>(),
        1usize,
        concat!("Alignment of ", stringify!(VNode_VTd_root_table_Mapping))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VNode_VTd_root_table_Mapping>())).cap as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VNode_VTd_root_table_Mapping),
            "::",
            stringify!(cap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VNode_VTd_root_table_Mapping>())).ptable as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VNode_VTd_root_table_Mapping),
            "::",
            stringify!(ptable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VNode_VTd_root_table_Mapping>())).entry as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VNode_VTd_root_table_Mapping),
            "::",
            stringify!(entry)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VNode_VTd_root_table_Mapping>())).pte_count as *const _ as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(VNode_VTd_root_table_Mapping),
            "::",
            stringify!(pte_count)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct VNode_VTd_ctxt_table {
    pub base: genpaddr_t,
}
#[test]
fn bindgen_test_layout_VNode_VTd_ctxt_table() {
    assert_eq!(
        ::std::mem::size_of::<VNode_VTd_ctxt_table>(),
        8usize,
        concat!("Size of: ", stringify!(VNode_VTd_ctxt_table))
    );
    assert_eq!(
        ::std::mem::align_of::<VNode_VTd_ctxt_table>(),
        1usize,
        concat!("Alignment of ", stringify!(VNode_VTd_ctxt_table))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VNode_VTd_ctxt_table>())).base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VNode_VTd_ctxt_table),
            "::",
            stringify!(base)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct VNode_VTd_ctxt_table_Mapping {
    pub cap: *mut capability,
    pub ptable: *mut cte,
    pub entry: u16,
    pub pte_count: u16,
}
#[test]
fn bindgen_test_layout_VNode_VTd_ctxt_table_Mapping() {
    assert_eq!(
        ::std::mem::size_of::<VNode_VTd_ctxt_table_Mapping>(),
        20usize,
        concat!("Size of: ", stringify!(VNode_VTd_ctxt_table_Mapping))
    );
    assert_eq!(
        ::std::mem::align_of::<VNode_VTd_ctxt_table_Mapping>(),
        1usize,
        concat!("Alignment of ", stringify!(VNode_VTd_ctxt_table_Mapping))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VNode_VTd_ctxt_table_Mapping>())).cap as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VNode_VTd_ctxt_table_Mapping),
            "::",
            stringify!(cap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VNode_VTd_ctxt_table_Mapping>())).ptable as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VNode_VTd_ctxt_table_Mapping),
            "::",
            stringify!(ptable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VNode_VTd_ctxt_table_Mapping>())).entry as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VNode_VTd_ctxt_table_Mapping),
            "::",
            stringify!(entry)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VNode_VTd_ctxt_table_Mapping>())).pte_count as *const _ as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(VNode_VTd_ctxt_table_Mapping),
            "::",
            stringify!(pte_count)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct VNode_x86_32_pdpt {
    pub base: genpaddr_t,
}
#[test]
fn bindgen_test_layout_VNode_x86_32_pdpt() {
    assert_eq!(
        ::std::mem::size_of::<VNode_x86_32_pdpt>(),
        8usize,
        concat!("Size of: ", stringify!(VNode_x86_32_pdpt))
    );
    assert_eq!(
        ::std::mem::align_of::<VNode_x86_32_pdpt>(),
        1usize,
        concat!("Alignment of ", stringify!(VNode_x86_32_pdpt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VNode_x86_32_pdpt>())).base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VNode_x86_32_pdpt),
            "::",
            stringify!(base)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct VNode_x86_32_pdpt_Mapping {
    pub cap: *mut capability,
    pub ptable: *mut cte,
    pub entry: u16,
    pub pte_count: u16,
}
#[test]
fn bindgen_test_layout_VNode_x86_32_pdpt_Mapping() {
    assert_eq!(
        ::std::mem::size_of::<VNode_x86_32_pdpt_Mapping>(),
        20usize,
        concat!("Size of: ", stringify!(VNode_x86_32_pdpt_Mapping))
    );
    assert_eq!(
        ::std::mem::align_of::<VNode_x86_32_pdpt_Mapping>(),
        1usize,
        concat!("Alignment of ", stringify!(VNode_x86_32_pdpt_Mapping))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VNode_x86_32_pdpt_Mapping>())).cap as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VNode_x86_32_pdpt_Mapping),
            "::",
            stringify!(cap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VNode_x86_32_pdpt_Mapping>())).ptable as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VNode_x86_32_pdpt_Mapping),
            "::",
            stringify!(ptable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VNode_x86_32_pdpt_Mapping>())).entry as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VNode_x86_32_pdpt_Mapping),
            "::",
            stringify!(entry)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VNode_x86_32_pdpt_Mapping>())).pte_count as *const _ as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(VNode_x86_32_pdpt_Mapping),
            "::",
            stringify!(pte_count)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct VNode_x86_32_pdir {
    pub base: genpaddr_t,
}
#[test]
fn bindgen_test_layout_VNode_x86_32_pdir() {
    assert_eq!(
        ::std::mem::size_of::<VNode_x86_32_pdir>(),
        8usize,
        concat!("Size of: ", stringify!(VNode_x86_32_pdir))
    );
    assert_eq!(
        ::std::mem::align_of::<VNode_x86_32_pdir>(),
        1usize,
        concat!("Alignment of ", stringify!(VNode_x86_32_pdir))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VNode_x86_32_pdir>())).base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VNode_x86_32_pdir),
            "::",
            stringify!(base)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct VNode_x86_32_pdir_Mapping {
    pub cap: *mut capability,
    pub ptable: *mut cte,
    pub entry: u16,
    pub pte_count: u16,
}
#[test]
fn bindgen_test_layout_VNode_x86_32_pdir_Mapping() {
    assert_eq!(
        ::std::mem::size_of::<VNode_x86_32_pdir_Mapping>(),
        20usize,
        concat!("Size of: ", stringify!(VNode_x86_32_pdir_Mapping))
    );
    assert_eq!(
        ::std::mem::align_of::<VNode_x86_32_pdir_Mapping>(),
        1usize,
        concat!("Alignment of ", stringify!(VNode_x86_32_pdir_Mapping))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VNode_x86_32_pdir_Mapping>())).cap as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VNode_x86_32_pdir_Mapping),
            "::",
            stringify!(cap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VNode_x86_32_pdir_Mapping>())).ptable as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VNode_x86_32_pdir_Mapping),
            "::",
            stringify!(ptable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VNode_x86_32_pdir_Mapping>())).entry as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VNode_x86_32_pdir_Mapping),
            "::",
            stringify!(entry)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VNode_x86_32_pdir_Mapping>())).pte_count as *const _ as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(VNode_x86_32_pdir_Mapping),
            "::",
            stringify!(pte_count)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct VNode_x86_32_ptable {
    pub base: genpaddr_t,
}
#[test]
fn bindgen_test_layout_VNode_x86_32_ptable() {
    assert_eq!(
        ::std::mem::size_of::<VNode_x86_32_ptable>(),
        8usize,
        concat!("Size of: ", stringify!(VNode_x86_32_ptable))
    );
    assert_eq!(
        ::std::mem::align_of::<VNode_x86_32_ptable>(),
        1usize,
        concat!("Alignment of ", stringify!(VNode_x86_32_ptable))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VNode_x86_32_ptable>())).base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VNode_x86_32_ptable),
            "::",
            stringify!(base)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct VNode_x86_32_ptable_Mapping {
    pub cap: *mut capability,
    pub ptable: *mut cte,
    pub entry: u16,
    pub pte_count: u16,
}
#[test]
fn bindgen_test_layout_VNode_x86_32_ptable_Mapping() {
    assert_eq!(
        ::std::mem::size_of::<VNode_x86_32_ptable_Mapping>(),
        20usize,
        concat!("Size of: ", stringify!(VNode_x86_32_ptable_Mapping))
    );
    assert_eq!(
        ::std::mem::align_of::<VNode_x86_32_ptable_Mapping>(),
        1usize,
        concat!("Alignment of ", stringify!(VNode_x86_32_ptable_Mapping))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VNode_x86_32_ptable_Mapping>())).cap as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VNode_x86_32_ptable_Mapping),
            "::",
            stringify!(cap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VNode_x86_32_ptable_Mapping>())).ptable as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VNode_x86_32_ptable_Mapping),
            "::",
            stringify!(ptable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VNode_x86_32_ptable_Mapping>())).entry as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VNode_x86_32_ptable_Mapping),
            "::",
            stringify!(entry)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VNode_x86_32_ptable_Mapping>())).pte_count as *const _ as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(VNode_x86_32_ptable_Mapping),
            "::",
            stringify!(pte_count)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct VNode_ARM_l1 {
    pub base: genpaddr_t,
}
#[test]
fn bindgen_test_layout_VNode_ARM_l1() {
    assert_eq!(
        ::std::mem::size_of::<VNode_ARM_l1>(),
        8usize,
        concat!("Size of: ", stringify!(VNode_ARM_l1))
    );
    assert_eq!(
        ::std::mem::align_of::<VNode_ARM_l1>(),
        1usize,
        concat!("Alignment of ", stringify!(VNode_ARM_l1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VNode_ARM_l1>())).base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VNode_ARM_l1),
            "::",
            stringify!(base)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct VNode_ARM_l1_Mapping {
    pub cap: *mut capability,
    pub ptable: *mut cte,
    pub entry: u16,
    pub pte_count: u16,
}
#[test]
fn bindgen_test_layout_VNode_ARM_l1_Mapping() {
    assert_eq!(
        ::std::mem::size_of::<VNode_ARM_l1_Mapping>(),
        20usize,
        concat!("Size of: ", stringify!(VNode_ARM_l1_Mapping))
    );
    assert_eq!(
        ::std::mem::align_of::<VNode_ARM_l1_Mapping>(),
        1usize,
        concat!("Alignment of ", stringify!(VNode_ARM_l1_Mapping))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VNode_ARM_l1_Mapping>())).cap as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VNode_ARM_l1_Mapping),
            "::",
            stringify!(cap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VNode_ARM_l1_Mapping>())).ptable as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VNode_ARM_l1_Mapping),
            "::",
            stringify!(ptable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VNode_ARM_l1_Mapping>())).entry as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VNode_ARM_l1_Mapping),
            "::",
            stringify!(entry)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VNode_ARM_l1_Mapping>())).pte_count as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(VNode_ARM_l1_Mapping),
            "::",
            stringify!(pte_count)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct VNode_ARM_l2 {
    pub base: genpaddr_t,
}
#[test]
fn bindgen_test_layout_VNode_ARM_l2() {
    assert_eq!(
        ::std::mem::size_of::<VNode_ARM_l2>(),
        8usize,
        concat!("Size of: ", stringify!(VNode_ARM_l2))
    );
    assert_eq!(
        ::std::mem::align_of::<VNode_ARM_l2>(),
        1usize,
        concat!("Alignment of ", stringify!(VNode_ARM_l2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VNode_ARM_l2>())).base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VNode_ARM_l2),
            "::",
            stringify!(base)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct VNode_ARM_l2_Mapping {
    pub cap: *mut capability,
    pub ptable: *mut cte,
    pub entry: u16,
    pub pte_count: u16,
}
#[test]
fn bindgen_test_layout_VNode_ARM_l2_Mapping() {
    assert_eq!(
        ::std::mem::size_of::<VNode_ARM_l2_Mapping>(),
        20usize,
        concat!("Size of: ", stringify!(VNode_ARM_l2_Mapping))
    );
    assert_eq!(
        ::std::mem::align_of::<VNode_ARM_l2_Mapping>(),
        1usize,
        concat!("Alignment of ", stringify!(VNode_ARM_l2_Mapping))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VNode_ARM_l2_Mapping>())).cap as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VNode_ARM_l2_Mapping),
            "::",
            stringify!(cap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VNode_ARM_l2_Mapping>())).ptable as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VNode_ARM_l2_Mapping),
            "::",
            stringify!(ptable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VNode_ARM_l2_Mapping>())).entry as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VNode_ARM_l2_Mapping),
            "::",
            stringify!(entry)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VNode_ARM_l2_Mapping>())).pte_count as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(VNode_ARM_l2_Mapping),
            "::",
            stringify!(pte_count)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct VNode_AARCH64_l0 {
    pub base: genpaddr_t,
}
#[test]
fn bindgen_test_layout_VNode_AARCH64_l0() {
    assert_eq!(
        ::std::mem::size_of::<VNode_AARCH64_l0>(),
        8usize,
        concat!("Size of: ", stringify!(VNode_AARCH64_l0))
    );
    assert_eq!(
        ::std::mem::align_of::<VNode_AARCH64_l0>(),
        1usize,
        concat!("Alignment of ", stringify!(VNode_AARCH64_l0))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VNode_AARCH64_l0>())).base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VNode_AARCH64_l0),
            "::",
            stringify!(base)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct VNode_AARCH64_l0_Mapping {
    pub cap: *mut capability,
    pub ptable: *mut cte,
    pub entry: u16,
    pub pte_count: u16,
}
#[test]
fn bindgen_test_layout_VNode_AARCH64_l0_Mapping() {
    assert_eq!(
        ::std::mem::size_of::<VNode_AARCH64_l0_Mapping>(),
        20usize,
        concat!("Size of: ", stringify!(VNode_AARCH64_l0_Mapping))
    );
    assert_eq!(
        ::std::mem::align_of::<VNode_AARCH64_l0_Mapping>(),
        1usize,
        concat!("Alignment of ", stringify!(VNode_AARCH64_l0_Mapping))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VNode_AARCH64_l0_Mapping>())).cap as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VNode_AARCH64_l0_Mapping),
            "::",
            stringify!(cap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VNode_AARCH64_l0_Mapping>())).ptable as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VNode_AARCH64_l0_Mapping),
            "::",
            stringify!(ptable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VNode_AARCH64_l0_Mapping>())).entry as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VNode_AARCH64_l0_Mapping),
            "::",
            stringify!(entry)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VNode_AARCH64_l0_Mapping>())).pte_count as *const _ as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(VNode_AARCH64_l0_Mapping),
            "::",
            stringify!(pte_count)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct VNode_AARCH64_l1 {
    pub base: genpaddr_t,
}
#[test]
fn bindgen_test_layout_VNode_AARCH64_l1() {
    assert_eq!(
        ::std::mem::size_of::<VNode_AARCH64_l1>(),
        8usize,
        concat!("Size of: ", stringify!(VNode_AARCH64_l1))
    );
    assert_eq!(
        ::std::mem::align_of::<VNode_AARCH64_l1>(),
        1usize,
        concat!("Alignment of ", stringify!(VNode_AARCH64_l1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VNode_AARCH64_l1>())).base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VNode_AARCH64_l1),
            "::",
            stringify!(base)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct VNode_AARCH64_l1_Mapping {
    pub cap: *mut capability,
    pub ptable: *mut cte,
    pub entry: u16,
    pub pte_count: u16,
}
#[test]
fn bindgen_test_layout_VNode_AARCH64_l1_Mapping() {
    assert_eq!(
        ::std::mem::size_of::<VNode_AARCH64_l1_Mapping>(),
        20usize,
        concat!("Size of: ", stringify!(VNode_AARCH64_l1_Mapping))
    );
    assert_eq!(
        ::std::mem::align_of::<VNode_AARCH64_l1_Mapping>(),
        1usize,
        concat!("Alignment of ", stringify!(VNode_AARCH64_l1_Mapping))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VNode_AARCH64_l1_Mapping>())).cap as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VNode_AARCH64_l1_Mapping),
            "::",
            stringify!(cap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VNode_AARCH64_l1_Mapping>())).ptable as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VNode_AARCH64_l1_Mapping),
            "::",
            stringify!(ptable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VNode_AARCH64_l1_Mapping>())).entry as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VNode_AARCH64_l1_Mapping),
            "::",
            stringify!(entry)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VNode_AARCH64_l1_Mapping>())).pte_count as *const _ as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(VNode_AARCH64_l1_Mapping),
            "::",
            stringify!(pte_count)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct VNode_AARCH64_l2 {
    pub base: genpaddr_t,
}
#[test]
fn bindgen_test_layout_VNode_AARCH64_l2() {
    assert_eq!(
        ::std::mem::size_of::<VNode_AARCH64_l2>(),
        8usize,
        concat!("Size of: ", stringify!(VNode_AARCH64_l2))
    );
    assert_eq!(
        ::std::mem::align_of::<VNode_AARCH64_l2>(),
        1usize,
        concat!("Alignment of ", stringify!(VNode_AARCH64_l2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VNode_AARCH64_l2>())).base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VNode_AARCH64_l2),
            "::",
            stringify!(base)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct VNode_AARCH64_l2_Mapping {
    pub cap: *mut capability,
    pub ptable: *mut cte,
    pub entry: u16,
    pub pte_count: u16,
}
#[test]
fn bindgen_test_layout_VNode_AARCH64_l2_Mapping() {
    assert_eq!(
        ::std::mem::size_of::<VNode_AARCH64_l2_Mapping>(),
        20usize,
        concat!("Size of: ", stringify!(VNode_AARCH64_l2_Mapping))
    );
    assert_eq!(
        ::std::mem::align_of::<VNode_AARCH64_l2_Mapping>(),
        1usize,
        concat!("Alignment of ", stringify!(VNode_AARCH64_l2_Mapping))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VNode_AARCH64_l2_Mapping>())).cap as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VNode_AARCH64_l2_Mapping),
            "::",
            stringify!(cap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VNode_AARCH64_l2_Mapping>())).ptable as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VNode_AARCH64_l2_Mapping),
            "::",
            stringify!(ptable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VNode_AARCH64_l2_Mapping>())).entry as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VNode_AARCH64_l2_Mapping),
            "::",
            stringify!(entry)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VNode_AARCH64_l2_Mapping>())).pte_count as *const _ as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(VNode_AARCH64_l2_Mapping),
            "::",
            stringify!(pte_count)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct VNode_AARCH64_l3 {
    pub base: genpaddr_t,
}
#[test]
fn bindgen_test_layout_VNode_AARCH64_l3() {
    assert_eq!(
        ::std::mem::size_of::<VNode_AARCH64_l3>(),
        8usize,
        concat!("Size of: ", stringify!(VNode_AARCH64_l3))
    );
    assert_eq!(
        ::std::mem::align_of::<VNode_AARCH64_l3>(),
        1usize,
        concat!("Alignment of ", stringify!(VNode_AARCH64_l3))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VNode_AARCH64_l3>())).base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VNode_AARCH64_l3),
            "::",
            stringify!(base)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct VNode_AARCH64_l3_Mapping {
    pub cap: *mut capability,
    pub ptable: *mut cte,
    pub entry: u16,
    pub pte_count: u16,
}
#[test]
fn bindgen_test_layout_VNode_AARCH64_l3_Mapping() {
    assert_eq!(
        ::std::mem::size_of::<VNode_AARCH64_l3_Mapping>(),
        20usize,
        concat!("Size of: ", stringify!(VNode_AARCH64_l3_Mapping))
    );
    assert_eq!(
        ::std::mem::align_of::<VNode_AARCH64_l3_Mapping>(),
        1usize,
        concat!("Alignment of ", stringify!(VNode_AARCH64_l3_Mapping))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VNode_AARCH64_l3_Mapping>())).cap as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VNode_AARCH64_l3_Mapping),
            "::",
            stringify!(cap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VNode_AARCH64_l3_Mapping>())).ptable as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VNode_AARCH64_l3_Mapping),
            "::",
            stringify!(ptable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VNode_AARCH64_l3_Mapping>())).entry as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VNode_AARCH64_l3_Mapping),
            "::",
            stringify!(entry)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VNode_AARCH64_l3_Mapping>())).pte_count as *const _ as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(VNode_AARCH64_l3_Mapping),
            "::",
            stringify!(pte_count)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IRQTable {}
#[test]
fn bindgen_test_layout_IRQTable() {
    assert_eq!(
        ::std::mem::size_of::<IRQTable>(),
        0usize,
        concat!("Size of: ", stringify!(IRQTable))
    );
    assert_eq!(
        ::std::mem::align_of::<IRQTable>(),
        1usize,
        concat!("Alignment of ", stringify!(IRQTable))
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct IRQDest {
    pub cpu: u64,
    pub vector: u64,
}
#[test]
fn bindgen_test_layout_IRQDest() {
    assert_eq!(
        ::std::mem::size_of::<IRQDest>(),
        16usize,
        concat!("Size of: ", stringify!(IRQDest))
    );
    assert_eq!(
        ::std::mem::align_of::<IRQDest>(),
        1usize,
        concat!("Alignment of ", stringify!(IRQDest))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IRQDest>())).cpu as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IRQDest),
            "::",
            stringify!(cpu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IRQDest>())).vector as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IRQDest),
            "::",
            stringify!(vector)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct IRQSrc {
    pub vec_start: u64,
    pub vec_end: u64,
}
#[test]
fn bindgen_test_layout_IRQSrc() {
    assert_eq!(
        ::std::mem::size_of::<IRQSrc>(),
        16usize,
        concat!("Size of: ", stringify!(IRQSrc))
    );
    assert_eq!(
        ::std::mem::align_of::<IRQSrc>(),
        1usize,
        concat!("Alignment of ", stringify!(IRQSrc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IRQSrc>())).vec_start as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IRQSrc),
            "::",
            stringify!(vec_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IRQSrc>())).vec_end as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IRQSrc),
            "::",
            stringify!(vec_end)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct IO {
    pub start: u16,
    pub end: u16,
}
#[test]
fn bindgen_test_layout_IO() {
    assert_eq!(
        ::std::mem::size_of::<IO>(),
        4usize,
        concat!("Size of: ", stringify!(IO))
    );
    assert_eq!(
        ::std::mem::align_of::<IO>(),
        1usize,
        concat!("Alignment of ", stringify!(IO))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IO>())).start as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(IO), "::", stringify!(start))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IO>())).end as *const _ as usize },
        2usize,
        concat!("Offset of field: ", stringify!(IO), "::", stringify!(end))
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct Notify_IPI {
    pub coreid: coreid_t,
    pub chanid: u16,
}
#[test]
fn bindgen_test_layout_Notify_IPI() {
    assert_eq!(
        ::std::mem::size_of::<Notify_IPI>(),
        3usize,
        concat!("Size of: ", stringify!(Notify_IPI))
    );
    assert_eq!(
        ::std::mem::align_of::<Notify_IPI>(),
        1usize,
        concat!("Alignment of ", stringify!(Notify_IPI))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Notify_IPI>())).coreid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Notify_IPI),
            "::",
            stringify!(coreid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Notify_IPI>())).chanid as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(Notify_IPI),
            "::",
            stringify!(chanid)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ID {
    pub coreid: coreid_t,
    pub core_local_id: u32,
}
#[test]
fn bindgen_test_layout_ID() {
    assert_eq!(
        ::std::mem::size_of::<ID>(),
        5usize,
        concat!("Size of: ", stringify!(ID))
    );
    assert_eq!(
        ::std::mem::align_of::<ID>(),
        1usize,
        concat!("Alignment of ", stringify!(ID))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ID>())).coreid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ID),
            "::",
            stringify!(coreid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ID>())).core_local_id as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(ID),
            "::",
            stringify!(core_local_id)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PerfMon {}
#[test]
fn bindgen_test_layout_PerfMon() {
    assert_eq!(
        ::std::mem::size_of::<PerfMon>(),
        0usize,
        concat!("Size of: ", stringify!(PerfMon))
    );
    assert_eq!(
        ::std::mem::align_of::<PerfMon>(),
        1usize,
        concat!("Alignment of ", stringify!(PerfMon))
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct KernelControlBlock {
    pub kcb: *mut kcb,
}
#[test]
fn bindgen_test_layout_KernelControlBlock() {
    assert_eq!(
        ::std::mem::size_of::<KernelControlBlock>(),
        8usize,
        concat!("Size of: ", stringify!(KernelControlBlock))
    );
    assert_eq!(
        ::std::mem::align_of::<KernelControlBlock>(),
        1usize,
        concat!("Alignment of ", stringify!(KernelControlBlock))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KernelControlBlock>())).kcb as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(KernelControlBlock),
            "::",
            stringify!(kcb)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPI {}
#[test]
fn bindgen_test_layout_IPI() {
    assert_eq!(
        ::std::mem::size_of::<IPI>(),
        0usize,
        concat!("Size of: ", stringify!(IPI))
    );
    assert_eq!(
        ::std::mem::align_of::<IPI>(),
        1usize,
        concat!("Alignment of ", stringify!(IPI))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ProcessManager {}
#[test]
fn bindgen_test_layout_ProcessManager() {
    assert_eq!(
        ::std::mem::size_of::<ProcessManager>(),
        0usize,
        concat!("Size of: ", stringify!(ProcessManager))
    );
    assert_eq!(
        ::std::mem::align_of::<ProcessManager>(),
        1usize,
        concat!("Alignment of ", stringify!(ProcessManager))
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct Domain {
    pub coreid: coreid_t,
    pub core_local_id: u32,
}
#[test]
fn bindgen_test_layout_Domain() {
    assert_eq!(
        ::std::mem::size_of::<Domain>(),
        5usize,
        concat!("Size of: ", stringify!(Domain))
    );
    assert_eq!(
        ::std::mem::align_of::<Domain>(),
        1usize,
        concat!("Alignment of ", stringify!(Domain))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Domain>())).coreid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Domain),
            "::",
            stringify!(coreid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Domain>())).core_local_id as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(Domain),
            "::",
            stringify!(core_local_id)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DeviceIDManager {}
#[test]
fn bindgen_test_layout_DeviceIDManager() {
    assert_eq!(
        ::std::mem::size_of::<DeviceIDManager>(),
        0usize,
        concat!("Size of: ", stringify!(DeviceIDManager))
    );
    assert_eq!(
        ::std::mem::align_of::<DeviceIDManager>(),
        1usize,
        concat!("Alignment of ", stringify!(DeviceIDManager))
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct DeviceID {
    pub segment: u16,
    pub bus: u8,
    pub device: u8,
    pub function: u8,
    pub type_: u8,
    pub flags: u16,
}
#[test]
fn bindgen_test_layout_DeviceID() {
    assert_eq!(
        ::std::mem::size_of::<DeviceID>(),
        8usize,
        concat!("Size of: ", stringify!(DeviceID))
    );
    assert_eq!(
        ::std::mem::align_of::<DeviceID>(),
        1usize,
        concat!("Alignment of ", stringify!(DeviceID))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DeviceID>())).segment as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DeviceID),
            "::",
            stringify!(segment)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DeviceID>())).bus as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(DeviceID),
            "::",
            stringify!(bus)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DeviceID>())).device as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(DeviceID),
            "::",
            stringify!(device)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DeviceID>())).function as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(DeviceID),
            "::",
            stringify!(function)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DeviceID>())).type_ as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(DeviceID),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DeviceID>())).flags as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(DeviceID),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union capability_u {
    pub null: Null,
    pub physaddr: PhysAddr,
    pub ram: RAM,
    pub l1cnode: L1CNode,
    pub l2cnode: L2CNode,
    pub fcnode: FCNode,
    pub dispatcher: Dispatcher,
    pub endpointlmp: EndPointLMP,
    pub frame: Frame,
    pub frame_mapping: Frame_Mapping,
    pub endpointump: EndPointUMP,
    pub endpointump_mapping: EndPointUMP_Mapping,
    pub devframe: DevFrame,
    pub devframe_mapping: DevFrame_Mapping,
    pub kernel: Kernel,
    pub vnode_x86_64_pml5: VNode_x86_64_pml5,
    pub vnode_x86_64_pml5_mapping: VNode_x86_64_pml5_Mapping,
    pub vnode_x86_64_pml4: VNode_x86_64_pml4,
    pub vnode_x86_64_pml4_mapping: VNode_x86_64_pml4_Mapping,
    pub vnode_x86_64_pdpt: VNode_x86_64_pdpt,
    pub vnode_x86_64_pdpt_mapping: VNode_x86_64_pdpt_Mapping,
    pub vnode_x86_64_pdir: VNode_x86_64_pdir,
    pub vnode_x86_64_pdir_mapping: VNode_x86_64_pdir_Mapping,
    pub vnode_x86_64_ptable: VNode_x86_64_ptable,
    pub vnode_x86_64_ptable_mapping: VNode_x86_64_ptable_Mapping,
    pub vnode_x86_64_ept_pml4: VNode_x86_64_ept_pml4,
    pub vnode_x86_64_ept_pml4_mapping: VNode_x86_64_ept_pml4_Mapping,
    pub vnode_x86_64_ept_pdpt: VNode_x86_64_ept_pdpt,
    pub vnode_x86_64_ept_pdpt_mapping: VNode_x86_64_ept_pdpt_Mapping,
    pub vnode_x86_64_ept_pdir: VNode_x86_64_ept_pdir,
    pub vnode_x86_64_ept_pdir_mapping: VNode_x86_64_ept_pdir_Mapping,
    pub vnode_x86_64_ept_ptable: VNode_x86_64_ept_ptable,
    pub vnode_x86_64_ept_ptable_mapping: VNode_x86_64_ept_ptable_Mapping,
    pub vnode_vtd_root_table: VNode_VTd_root_table,
    pub vnode_vtd_root_table_mapping: VNode_VTd_root_table_Mapping,
    pub vnode_vtd_ctxt_table: VNode_VTd_ctxt_table,
    pub vnode_vtd_ctxt_table_mapping: VNode_VTd_ctxt_table_Mapping,
    pub vnode_x86_32_pdpt: VNode_x86_32_pdpt,
    pub vnode_x86_32_pdpt_mapping: VNode_x86_32_pdpt_Mapping,
    pub vnode_x86_32_pdir: VNode_x86_32_pdir,
    pub vnode_x86_32_pdir_mapping: VNode_x86_32_pdir_Mapping,
    pub vnode_x86_32_ptable: VNode_x86_32_ptable,
    pub vnode_x86_32_ptable_mapping: VNode_x86_32_ptable_Mapping,
    pub vnode_arm_l1: VNode_ARM_l1,
    pub vnode_arm_l1_mapping: VNode_ARM_l1_Mapping,
    pub vnode_arm_l2: VNode_ARM_l2,
    pub vnode_arm_l2_mapping: VNode_ARM_l2_Mapping,
    pub vnode_aarch64_l0: VNode_AARCH64_l0,
    pub vnode_aarch64_l0_mapping: VNode_AARCH64_l0_Mapping,
    pub vnode_aarch64_l1: VNode_AARCH64_l1,
    pub vnode_aarch64_l1_mapping: VNode_AARCH64_l1_Mapping,
    pub vnode_aarch64_l2: VNode_AARCH64_l2,
    pub vnode_aarch64_l2_mapping: VNode_AARCH64_l2_Mapping,
    pub vnode_aarch64_l3: VNode_AARCH64_l3,
    pub vnode_aarch64_l3_mapping: VNode_AARCH64_l3_Mapping,
    pub irqtable: IRQTable,
    pub irqdest: IRQDest,
    pub irqsrc: IRQSrc,
    pub io: IO,
    pub notify_ipi: Notify_IPI,
    pub id: ID,
    pub perfmon: PerfMon,
    pub kernelcontrolblock: KernelControlBlock,
    pub ipi: IPI,
    pub processmanager: ProcessManager,
    pub domain: Domain,
    pub deviceidmanager: DeviceIDManager,
    pub deviceid: DeviceID,
}
#[test]
fn bindgen_test_layout_capability_u() {
    assert_eq!(
        ::std::mem::size_of::<capability_u>(),
        22usize,
        concat!("Size of: ", stringify!(capability_u))
    );
    assert_eq!(
        ::std::mem::align_of::<capability_u>(),
        1usize,
        concat!("Alignment of ", stringify!(capability_u))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<capability_u>())).null as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(capability_u),
            "::",
            stringify!(null)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<capability_u>())).physaddr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(capability_u),
            "::",
            stringify!(physaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<capability_u>())).ram as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(capability_u),
            "::",
            stringify!(ram)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<capability_u>())).l1cnode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(capability_u),
            "::",
            stringify!(l1cnode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<capability_u>())).l2cnode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(capability_u),
            "::",
            stringify!(l2cnode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<capability_u>())).fcnode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(capability_u),
            "::",
            stringify!(fcnode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<capability_u>())).dispatcher as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(capability_u),
            "::",
            stringify!(dispatcher)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<capability_u>())).endpointlmp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(capability_u),
            "::",
            stringify!(endpointlmp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<capability_u>())).frame as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(capability_u),
            "::",
            stringify!(frame)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<capability_u>())).frame_mapping as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(capability_u),
            "::",
            stringify!(frame_mapping)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<capability_u>())).endpointump as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(capability_u),
            "::",
            stringify!(endpointump)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<capability_u>())).endpointump_mapping as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(capability_u),
            "::",
            stringify!(endpointump_mapping)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<capability_u>())).devframe as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(capability_u),
            "::",
            stringify!(devframe)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<capability_u>())).devframe_mapping as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(capability_u),
            "::",
            stringify!(devframe_mapping)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<capability_u>())).kernel as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(capability_u),
            "::",
            stringify!(kernel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<capability_u>())).vnode_x86_64_pml5 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(capability_u),
            "::",
            stringify!(vnode_x86_64_pml5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<capability_u>())).vnode_x86_64_pml5_mapping as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(capability_u),
            "::",
            stringify!(vnode_x86_64_pml5_mapping)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<capability_u>())).vnode_x86_64_pml4 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(capability_u),
            "::",
            stringify!(vnode_x86_64_pml4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<capability_u>())).vnode_x86_64_pml4_mapping as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(capability_u),
            "::",
            stringify!(vnode_x86_64_pml4_mapping)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<capability_u>())).vnode_x86_64_pdpt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(capability_u),
            "::",
            stringify!(vnode_x86_64_pdpt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<capability_u>())).vnode_x86_64_pdpt_mapping as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(capability_u),
            "::",
            stringify!(vnode_x86_64_pdpt_mapping)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<capability_u>())).vnode_x86_64_pdir as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(capability_u),
            "::",
            stringify!(vnode_x86_64_pdir)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<capability_u>())).vnode_x86_64_pdir_mapping as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(capability_u),
            "::",
            stringify!(vnode_x86_64_pdir_mapping)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<capability_u>())).vnode_x86_64_ptable as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(capability_u),
            "::",
            stringify!(vnode_x86_64_ptable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<capability_u>())).vnode_x86_64_ptable_mapping as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(capability_u),
            "::",
            stringify!(vnode_x86_64_ptable_mapping)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<capability_u>())).vnode_x86_64_ept_pml4 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(capability_u),
            "::",
            stringify!(vnode_x86_64_ept_pml4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<capability_u>())).vnode_x86_64_ept_pml4_mapping as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(capability_u),
            "::",
            stringify!(vnode_x86_64_ept_pml4_mapping)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<capability_u>())).vnode_x86_64_ept_pdpt as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(capability_u),
            "::",
            stringify!(vnode_x86_64_ept_pdpt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<capability_u>())).vnode_x86_64_ept_pdpt_mapping as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(capability_u),
            "::",
            stringify!(vnode_x86_64_ept_pdpt_mapping)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<capability_u>())).vnode_x86_64_ept_pdir as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(capability_u),
            "::",
            stringify!(vnode_x86_64_ept_pdir)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<capability_u>())).vnode_x86_64_ept_pdir_mapping as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(capability_u),
            "::",
            stringify!(vnode_x86_64_ept_pdir_mapping)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<capability_u>())).vnode_x86_64_ept_ptable as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(capability_u),
            "::",
            stringify!(vnode_x86_64_ept_ptable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<capability_u>())).vnode_x86_64_ept_ptable_mapping as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(capability_u),
            "::",
            stringify!(vnode_x86_64_ept_ptable_mapping)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<capability_u>())).vnode_vtd_root_table as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(capability_u),
            "::",
            stringify!(vnode_vtd_root_table)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<capability_u>())).vnode_vtd_root_table_mapping as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(capability_u),
            "::",
            stringify!(vnode_vtd_root_table_mapping)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<capability_u>())).vnode_vtd_ctxt_table as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(capability_u),
            "::",
            stringify!(vnode_vtd_ctxt_table)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<capability_u>())).vnode_vtd_ctxt_table_mapping as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(capability_u),
            "::",
            stringify!(vnode_vtd_ctxt_table_mapping)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<capability_u>())).vnode_x86_32_pdpt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(capability_u),
            "::",
            stringify!(vnode_x86_32_pdpt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<capability_u>())).vnode_x86_32_pdpt_mapping as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(capability_u),
            "::",
            stringify!(vnode_x86_32_pdpt_mapping)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<capability_u>())).vnode_x86_32_pdir as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(capability_u),
            "::",
            stringify!(vnode_x86_32_pdir)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<capability_u>())).vnode_x86_32_pdir_mapping as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(capability_u),
            "::",
            stringify!(vnode_x86_32_pdir_mapping)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<capability_u>())).vnode_x86_32_ptable as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(capability_u),
            "::",
            stringify!(vnode_x86_32_ptable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<capability_u>())).vnode_x86_32_ptable_mapping as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(capability_u),
            "::",
            stringify!(vnode_x86_32_ptable_mapping)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<capability_u>())).vnode_arm_l1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(capability_u),
            "::",
            stringify!(vnode_arm_l1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<capability_u>())).vnode_arm_l1_mapping as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(capability_u),
            "::",
            stringify!(vnode_arm_l1_mapping)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<capability_u>())).vnode_arm_l2 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(capability_u),
            "::",
            stringify!(vnode_arm_l2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<capability_u>())).vnode_arm_l2_mapping as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(capability_u),
            "::",
            stringify!(vnode_arm_l2_mapping)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<capability_u>())).vnode_aarch64_l0 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(capability_u),
            "::",
            stringify!(vnode_aarch64_l0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<capability_u>())).vnode_aarch64_l0_mapping as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(capability_u),
            "::",
            stringify!(vnode_aarch64_l0_mapping)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<capability_u>())).vnode_aarch64_l1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(capability_u),
            "::",
            stringify!(vnode_aarch64_l1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<capability_u>())).vnode_aarch64_l1_mapping as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(capability_u),
            "::",
            stringify!(vnode_aarch64_l1_mapping)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<capability_u>())).vnode_aarch64_l2 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(capability_u),
            "::",
            stringify!(vnode_aarch64_l2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<capability_u>())).vnode_aarch64_l2_mapping as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(capability_u),
            "::",
            stringify!(vnode_aarch64_l2_mapping)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<capability_u>())).vnode_aarch64_l3 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(capability_u),
            "::",
            stringify!(vnode_aarch64_l3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<capability_u>())).vnode_aarch64_l3_mapping as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(capability_u),
            "::",
            stringify!(vnode_aarch64_l3_mapping)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<capability_u>())).irqtable as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(capability_u),
            "::",
            stringify!(irqtable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<capability_u>())).irqdest as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(capability_u),
            "::",
            stringify!(irqdest)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<capability_u>())).irqsrc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(capability_u),
            "::",
            stringify!(irqsrc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<capability_u>())).io as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(capability_u),
            "::",
            stringify!(io)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<capability_u>())).notify_ipi as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(capability_u),
            "::",
            stringify!(notify_ipi)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<capability_u>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(capability_u),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<capability_u>())).perfmon as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(capability_u),
            "::",
            stringify!(perfmon)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<capability_u>())).kernelcontrolblock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(capability_u),
            "::",
            stringify!(kernelcontrolblock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<capability_u>())).ipi as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(capability_u),
            "::",
            stringify!(ipi)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<capability_u>())).processmanager as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(capability_u),
            "::",
            stringify!(processmanager)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<capability_u>())).domain as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(capability_u),
            "::",
            stringify!(domain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<capability_u>())).deviceidmanager as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(capability_u),
            "::",
            stringify!(deviceidmanager)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<capability_u>())).deviceid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(capability_u),
            "::",
            stringify!(deviceid)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct capability {
    pub u: capability_u,
    pub type_: objtype,
    pub rights: CapRights,
}
#[test]
fn bindgen_test_layout_capability() {
    assert_eq!(
        ::std::mem::size_of::<capability>(),
        24usize,
        concat!("Size of: ", stringify!(capability))
    );
    assert_eq!(
        ::std::mem::align_of::<capability>(),
        1usize,
        concat!("Alignment of ", stringify!(capability))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<capability>())).u as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(capability),
            "::",
            stringify!(u)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<capability>())).type_ as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(capability),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<capability>())).rights as *const _ as usize },
        23usize,
        concat!(
            "Offset of field: ",
            stringify!(capability),
            "::",
            stringify!(rights)
        )
    );
}
pub const static_assert_0: ::std::os::raw::c_uint = 1;
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
#[doc = "< Copy capability"]
pub const cnode_cmd_CNodeCmd_Copy: cnode_cmd = 0;
#[doc = "< Mint capability"]
pub const cnode_cmd_CNodeCmd_Mint: cnode_cmd = 1;
#[doc = "< Retype capability"]
pub const cnode_cmd_CNodeCmd_Retype: cnode_cmd = 2;
#[doc = "< Delete capability"]
pub const cnode_cmd_CNodeCmd_Delete: cnode_cmd = 3;
#[doc = "< Revoke capability"]
pub const cnode_cmd_CNodeCmd_Revoke: cnode_cmd = 4;
#[doc = "< Create capability"]
pub const cnode_cmd_CNodeCmd_Create: cnode_cmd = 5;
#[doc = "< Get distcap state for capability"]
pub const cnode_cmd_CNodeCmd_GetState: cnode_cmd = 6;
#[doc = "< Get Size of CNode, only applicable for L1 Cnode"]
pub const cnode_cmd_CNodeCmd_GetSize: cnode_cmd = 7;
#[doc = "< Resize CNode, only applicable for L1 Cnode"]
pub const cnode_cmd_CNodeCmd_Resize: cnode_cmd = 8;
#[doc = "< Identify capability"]
pub const cnode_cmd_CNodeCmd_CapIdentify: cnode_cmd = 9;
#[doc = " CNode capability commands."]
pub type cnode_cmd = ::std::os::raw::c_uint;
pub const vnode_cmd_VNodeCmd_Map: vnode_cmd = 0;
pub const vnode_cmd_VNodeCmd_Unmap: vnode_cmd = 1;
pub const vnode_cmd_VNodeCmd_ModifyFlags: vnode_cmd = 2;
#[doc = "< Cleans all dirty bit in the table"]
pub const vnode_cmd_VNodeCmd_CleanDirtyBits: vnode_cmd = 3;
#[doc = "< Copy and remap page table for copy-on-write"]
pub const vnode_cmd_VNodeCmd_CopyRemap: vnode_cmd = 4;
#[doc = "< Clone page table"]
pub const vnode_cmd_VNodeCmd_Inherit: vnode_cmd = 5;
pub type vnode_cmd = ::std::os::raw::c_uint;
pub const mapping_cmd_MappingCmd_Modify: mapping_cmd = 0;
pub const mapping_cmd_MappingCmd_Destroy: mapping_cmd = 1;
#[doc = " Mapping commands"]
pub type mapping_cmd = ::std::os::raw::c_uint;
#[doc = "< Spawn a new kernel"]
pub const kernel_cmd_KernelCmd_Spawn_core: kernel_cmd = 0;
#[doc = "< Return the meta data of a capability"]
pub const kernel_cmd_KernelCmd_Identify_cap: kernel_cmd = 1;
#[doc = "< Return the meta data of another domain's capability"]
pub const kernel_cmd_KernelCmd_Identify_domains_cap: kernel_cmd = 2;
#[doc = "< Set capability as being remote"]
pub const kernel_cmd_KernelCmd_Remote_relations: kernel_cmd = 3;
#[doc = "< Return presence of local relations"]
pub const kernel_cmd_KernelCmd_Cap_has_relations: kernel_cmd = 4;
#[doc = "< Create a new capability"]
pub const kernel_cmd_KernelCmd_Create_cap: kernel_cmd = 5;
pub const kernel_cmd_KernelCmd_Copy_existing: kernel_cmd = 6;
#[doc = "< Returns the id of the core the domain is on"]
pub const kernel_cmd_KernelCmd_Get_core_id: kernel_cmd = 7;
#[doc = "< Returns arch id of caller's core"]
pub const kernel_cmd_KernelCmd_Get_arch_id: kernel_cmd = 8;
#[doc = "< Set the capability to NULL allowed it to be reused"]
pub const kernel_cmd_KernelCmd_Nullify_cap: kernel_cmd = 9;
#[doc = "< Set up trace buffer"]
pub const kernel_cmd_KernelCmd_Setup_trace: kernel_cmd = 10;
#[doc = "< Register monitor notify endpoint"]
pub const kernel_cmd_KernelCmd_Register: kernel_cmd = 11;
#[doc = "< Set domain ID of dispatcher"]
pub const kernel_cmd_KernelCmd_Domain_Id: kernel_cmd = 12;
pub const kernel_cmd_KernelCmd_Get_cap_owner: kernel_cmd = 13;
pub const kernel_cmd_KernelCmd_Set_cap_owner: kernel_cmd = 14;
pub const kernel_cmd_KernelCmd_Lock_cap: kernel_cmd = 15;
pub const kernel_cmd_KernelCmd_Unlock_cap: kernel_cmd = 16;
pub const kernel_cmd_KernelCmd_Delete_last: kernel_cmd = 17;
pub const kernel_cmd_KernelCmd_Delete_foreigns: kernel_cmd = 18;
pub const kernel_cmd_KernelCmd_Revoke_mark_target: kernel_cmd = 19;
pub const kernel_cmd_KernelCmd_Revoke_mark_relations: kernel_cmd = 20;
pub const kernel_cmd_KernelCmd_Delete_step: kernel_cmd = 21;
pub const kernel_cmd_KernelCmd_Clear_step: kernel_cmd = 22;
pub const kernel_cmd_KernelCmd_Retype: kernel_cmd = 23;
pub const kernel_cmd_KernelCmd_Has_descendants: kernel_cmd = 24;
pub const kernel_cmd_KernelCmd_Is_retypeable: kernel_cmd = 25;
pub const kernel_cmd_KernelCmd_Sync_timer: kernel_cmd = 26;
pub const kernel_cmd_KernelCmd_IPI_Register: kernel_cmd = 27;
pub const kernel_cmd_KernelCmd_IPI_Delete: kernel_cmd = 28;
pub const kernel_cmd_KernelCmd_GetGlobalPhys: kernel_cmd = 29;
#[doc = "< add extra kcb to be scheduled"]
pub const kernel_cmd_KernelCmd_Add_kcb: kernel_cmd = 30;
#[doc = "< remove kcb from scheduling ring"]
pub const kernel_cmd_KernelCmd_Remove_kcb: kernel_cmd = 31;
#[doc = "< suspend/resume kcb scheduler"]
pub const kernel_cmd_KernelCmd_Suspend_kcb_sched: kernel_cmd = 32;
#[doc = "< Get architecture platform"]
pub const kernel_cmd_KernelCmd_Get_platform: kernel_cmd = 33;
#[doc = "< Retrieve stored ram caps from KCB"]
pub const kernel_cmd_KernelCmd_ReclaimRAM: kernel_cmd = 34;
pub const kernel_cmd_KernelCmd_Count: kernel_cmd = 35;
#[doc = " Kernel capabilities commands."]
#[doc = " Monitor's invocations of capability operations"]
#[doc = " which the kernel will not subject to cross core checks"]
pub type kernel_cmd = ::std::os::raw::c_uint;
#[doc = "< Set dispatcher parameters"]
pub const dispatcher_cmd_DispatcherCmd_Setup: dispatcher_cmd = 0;
#[doc = "< Set dispatcher properties"]
pub const dispatcher_cmd_DispatcherCmd_Properties: dispatcher_cmd = 1;
#[doc = "< Performance monitoring"]
pub const dispatcher_cmd_DispatcherCmd_PerfMon: dispatcher_cmd = 2;
#[doc = "< Set up the DCB of a guest domain"]
pub const dispatcher_cmd_DispatcherCmd_SetupGuest: dispatcher_cmd = 3;
#[doc = "< Dump hw page tables of dispatcher"]
pub const dispatcher_cmd_DispatcherCmd_DumpPTables: dispatcher_cmd = 4;
#[doc = "< Dump capabilities of dispatcher"]
pub const dispatcher_cmd_DispatcherCmd_DumpCapabilities: dispatcher_cmd = 5;
#[doc = "< Execute vmread on the current and active VMCS"]
pub const dispatcher_cmd_DispatcherCmd_Vmread: dispatcher_cmd = 6;
#[doc = "< Execute vmwrite on the current and active VMCS"]
pub const dispatcher_cmd_DispatcherCmd_Vmwrite: dispatcher_cmd = 7;
#[doc = "< Make VMCS clear and inactive"]
pub const dispatcher_cmd_DispatcherCmd_Vmptrld: dispatcher_cmd = 8;
#[doc = "< Make VMCS current and active"]
pub const dispatcher_cmd_DispatcherCmd_Vmclear: dispatcher_cmd = 9;
#[doc = " Specific commands for dispatcher capabilities."]
pub type dispatcher_cmd = ::std::os::raw::c_uint;
#[doc = "< Return base address of KCB frame"]
pub const kcb_cmd_KCBCmd_Identify: kcb_cmd = 0;
#[doc = "< Duplicate core_data"]
pub const kcb_cmd_KCBCmd_Clone: kcb_cmd = 1;
#[doc = " Kernel control block commands."]
pub type kcb_cmd = ::std::os::raw::c_uint;
#[doc = "< Noop invocation for benchmark"]
pub const ram_cmd_RAMCmd_Noop: ram_cmd = 0;
#[doc = " RAM capability commands"]
pub type ram_cmd = ::std::os::raw::c_uint;
#[doc = "< Allocate new vector (XXX: HACK: this is x86 specific)"]
pub const irqtable_cmd_IRQTableCmd_Alloc: irqtable_cmd = 0;
#[doc = "< Allocate new dest capability (XXX: HACK: this is x86 specific)"]
pub const irqtable_cmd_IRQTableCmd_AllocDestCap: irqtable_cmd = 1;
#[doc = "< Set endpoint for IRQ# notifications"]
pub const irqtable_cmd_IRQTableCmd_Set: irqtable_cmd = 2;
#[doc = "< Remove notification endpoint for IRQ#"]
pub const irqtable_cmd_IRQTableCmd_Delete: irqtable_cmd = 3;
#[doc = " IRQ Table capability commands."]
pub type irqtable_cmd = ::std::os::raw::c_uint;
#[doc = "< Connect this capability to a messaging channel"]
pub const irqdest_cmd_IRQDestCmd_Connect: irqdest_cmd = 0;
#[doc = "< Return the local interrupt vector"]
pub const irqdest_cmd_IRQDestCmd_GetVector: irqdest_cmd = 1;
#[doc = "< Return the local interrupt vector"]
pub const irqdest_cmd_IRQDestCmd_GetCpu: irqdest_cmd = 2;
#[doc = " IRQ Vector commands."]
pub type irqdest_cmd = ::std::os::raw::c_uint;
#[doc = "< Return vector range start"]
pub const irqsrc_cmd_IRQSrcCmd_GetVecStart: irqsrc_cmd = 0;
#[doc = "< Return vector range high"]
pub const irqsrc_cmd_IRQSrcCmd_GetVecEnd: irqsrc_cmd = 1;
#[doc = " IRQ Vector commands."]
pub type irqsrc_cmd = ::std::os::raw::c_uint;
#[doc = "< Output byte to port"]
pub const io_cmd_IOCmd_Outb: io_cmd = 0;
#[doc = "< Output word to port"]
pub const io_cmd_IOCmd_Outw: io_cmd = 1;
#[doc = "< Output double word to port"]
pub const io_cmd_IOCmd_Outd: io_cmd = 2;
#[doc = "< Input byte from port"]
pub const io_cmd_IOCmd_Inb: io_cmd = 3;
#[doc = "< Input word from port"]
pub const io_cmd_IOCmd_Inw: io_cmd = 4;
#[doc = "< Input double word from port"]
pub const io_cmd_IOCmd_Ind: io_cmd = 5;
#[doc = " IO capability commands."]
pub type io_cmd = ::std::os::raw::c_uint;
#[doc = "< Create a new DeviceID"]
pub const devidman_cmd_DeviceIDManager_CreateID: devidman_cmd = 0;
#[doc = " DeviceID Manager Commands"]
pub type devidman_cmd = ::std::os::raw::c_uint;
pub const notify_cmd_NotifyCmd_Send: notify_cmd = 0;
#[doc = " Notify capability commands."]
pub type notify_cmd = ::std::os::raw::c_uint;
#[doc = "< Activate performance counters"]
pub const perfmon_cmd_PerfmonCmd_Activate: perfmon_cmd = 0;
#[doc = "< Deactivate performance counters"]
pub const perfmon_cmd_PerfmonCmd_Deactivate: perfmon_cmd = 1;
#[doc = "< Read current performance counter values"]
pub const perfmon_cmd_PerfmonCmd_Write: perfmon_cmd = 2;
#[doc = " Performance monitoring commands."]
#[doc = " Seems to be already included in the Dispatcher capability."]
pub type perfmon_cmd = ::std::os::raw::c_uint;
#[doc = "< Return system-wide unique ID"]
pub const id_cmd_IDCmd_Identify: id_cmd = 0;
#[doc = " ID capability commands."]
pub type id_cmd = ::std::os::raw::c_uint;
#[doc = "< Send Startup IPI to a destination core"]
pub const ipi_cmd_IPICmd_Send_Start: ipi_cmd = 0;
#[doc = "< Send Init IPI to a destination core"]
pub const ipi_cmd_IPICmd_Send_Init: ipi_cmd = 1;
#[doc = " IPI capability commands"]
pub type ipi_cmd = ::std::os::raw::c_uint;
#[doc = " \\brief Values returned from frame identify invocation"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct frame_identity {
    #[doc = "< Physical base address of frame"]
    pub base: genpaddr_t,
    #[doc = "< Size of frame, in bytes"]
    pub bytes: gensize_t,
    #[doc = "< the address space id"]
    pub pasid: pasid_t,
}
#[test]
fn bindgen_test_layout_frame_identity() {
    assert_eq!(
        ::std::mem::size_of::<frame_identity>(),
        24usize,
        concat!("Size of: ", stringify!(frame_identity))
    );
    assert_eq!(
        ::std::mem::align_of::<frame_identity>(),
        8usize,
        concat!("Alignment of ", stringify!(frame_identity))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<frame_identity>())).base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(frame_identity),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<frame_identity>())).bytes as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(frame_identity),
            "::",
            stringify!(bytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<frame_identity>())).pasid as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(frame_identity),
            "::",
            stringify!(pasid)
        )
    );
}
#[doc = " \\brief Values returned from the VNode identify invocation"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnode_identity {
    #[doc = "< Physical base address of the VNode"]
    pub base: genpaddr_t,
    #[doc = "< Type of VNode"]
    pub type_: u8,
}
#[test]
fn bindgen_test_layout_vnode_identity() {
    assert_eq!(
        ::std::mem::size_of::<vnode_identity>(),
        16usize,
        concat!("Size of: ", stringify!(vnode_identity))
    );
    assert_eq!(
        ::std::mem::align_of::<vnode_identity>(),
        8usize,
        concat!("Alignment of ", stringify!(vnode_identity))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vnode_identity>())).base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vnode_identity),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vnode_identity>())).type_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vnode_identity),
            "::",
            stringify!(type_)
        )
    );
}
pub const device_id_type_t_DEVICE_ID_TYPE_UNKNOWN: device_id_type_t = 0;
pub const device_id_type_t_DEVICE_ID_TYPE_PCI: device_id_type_t = 1;
pub const device_id_type_t_DEVICE_ID_TYPE_USB: device_id_type_t = 2;
pub const device_id_type_t_DEVICE_ID_TYPE_MAX: device_id_type_t = 3;
#[doc = " @brief values for the type field in the device_identity struct below"]
pub type device_id_type_t = ::std::os::raw::c_uint;
#[doc = " \\brief Values returned from the DeviceID identify invocation"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct device_identity {
    pub segment: u16,
    pub bus: u8,
    pub device: u8,
    pub function: u8,
    pub type_: u8,
    pub flags: u16,
}
#[test]
fn bindgen_test_layout_device_identity() {
    assert_eq!(
        ::std::mem::size_of::<device_identity>(),
        8usize,
        concat!("Size of: ", stringify!(device_identity))
    );
    assert_eq!(
        ::std::mem::align_of::<device_identity>(),
        2usize,
        concat!("Alignment of ", stringify!(device_identity))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<device_identity>())).segment as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(device_identity),
            "::",
            stringify!(segment)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<device_identity>())).bus as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(device_identity),
            "::",
            stringify!(bus)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<device_identity>())).device as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(device_identity),
            "::",
            stringify!(device)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<device_identity>())).function as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(device_identity),
            "::",
            stringify!(function)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<device_identity>())).type_ as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(device_identity),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<device_identity>())).flags as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(device_identity),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct endpoint_identity {
    #[doc = "< Physical Address of the Endpoint"]
    pub base: genpaddr_t,
    #[doc = "< Length of the Endpoint"]
    pub length: gensize_t,
    #[doc = "< interface type"]
    pub iftype: u16,
    #[doc = "< type of the endpoint"]
    pub eptype: u16,
}
#[test]
fn bindgen_test_layout_endpoint_identity() {
    assert_eq!(
        ::std::mem::size_of::<endpoint_identity>(),
        24usize,
        concat!("Size of: ", stringify!(endpoint_identity))
    );
    assert_eq!(
        ::std::mem::align_of::<endpoint_identity>(),
        8usize,
        concat!("Alignment of ", stringify!(endpoint_identity))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<endpoint_identity>())).base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(endpoint_identity),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<endpoint_identity>())).length as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(endpoint_identity),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<endpoint_identity>())).iftype as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(endpoint_identity),
            "::",
            stringify!(iftype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<endpoint_identity>())).eptype as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(endpoint_identity),
            "::",
            stringify!(eptype)
        )
    );
}
pub const cpu_type_CPU_K1OM: cpu_type = 0;
pub const cpu_type_CPU_X86_64: cpu_type = 1;
pub const cpu_type_CPU_X86_32: cpu_type = 2;
pub const cpu_type_CPU_ARM7: cpu_type = 3;
pub const cpu_type_CPU_ARM8: cpu_type = 4;
pub const cpu_type_CPU_TYPE_NUM: cpu_type = 5;
pub type cpu_type = ::std::os::raw::c_uint;
extern "C" {
    pub fn bcmp(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcopy(
        arg1: *const ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: size_t,
    );
}
extern "C" {
    pub fn bzero(arg1: *mut ::std::os::raw::c_void, arg2: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn explicit_bzero(arg1: *mut ::std::os::raw::c_void, arg2: size_t);
}
extern "C" {
    pub fn ffs(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsl(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsll(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fls(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flsl(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flsll(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn index(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rindex(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcasecmp(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xlocale {
    _unused: [u8; 0],
}
pub type locale_t = *mut _xlocale;
extern "C" {
    pub fn strcasecmp_l(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp_l(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: size_t,
        arg4: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memccpy(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memchr(
        arg1: *const ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memrchr(
        arg1: *const ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_int,
        arg3: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memcpy(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmem(
        arg1: *const ::std::os::raw::c_void,
        arg2: size_t,
        arg3: *const ::std::os::raw::c_void,
        arg4: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(
        arg1: *mut ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn stpcpy(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpncpy(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcasestr(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcat(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchr(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchrnul(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcpy(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcspn(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strdup(arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strerror(arg1: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strerror_r(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strlcat(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn strlcpy(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn strlen(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strmode(arg1: ::std::os::raw::c_int, arg2: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn strncat(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncmp(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncpy(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strndup(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strnlen(arg1: *const ::std::os::raw::c_char, arg2: size_t) -> size_t;
}
extern "C" {
    pub fn strnstr(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strpbrk(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strsep(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strsignal(arg1: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strspn(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strstr(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok_r(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strxfrm(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn swab(
        arg1: *const ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: ssize_t,
    );
}
extern "C" {
    pub fn timingsafe_bcmp(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
        arg3: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timingsafe_memcmp(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
        arg3: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll_l(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm_l(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: size_t,
        arg4: locale_t,
    ) -> size_t;
}
pub type spinlock_t = u32;
pub type paging_aarch64_flags_t = usize;
#[doc = " return type from a system call: two words"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sysret {
    pub error: errval_t,
    pub value: usize,
}
#[test]
fn bindgen_test_layout_sysret() {
    assert_eq!(
        ::std::mem::size_of::<sysret>(),
        16usize,
        concat!("Size of: ", stringify!(sysret))
    );
    assert_eq!(
        ::std::mem::align_of::<sysret>(),
        8usize,
        concat!("Alignment of ", stringify!(sysret))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sysret>())).error as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sysret),
            "::",
            stringify!(error)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sysret>())).value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sysret),
            "::",
            stringify!(value)
        )
    );
}
#[doc = " Empty memory: describes a RAM cap in supercn"]
pub const region_type_RegionType_Empty: region_type = 0;
#[doc = " Code/Data of init itself: describes a Frame cap in segcn"]
pub const region_type_RegionType_RootTask: region_type = 1;
#[doc = " Physical address range (not RAM): describes a PhysAddr cap in physaddrcn"]
pub const region_type_RegionType_PhyAddr: region_type = 2;
#[doc = " BIOS tables and platform-specific data: describes a PhysAddr cap in physaddrcn"]
pub const region_type_RegionType_PlatformData: region_type = 3;
#[doc = " Multiboot module: describes multiple Frame caps in modulecn"]
pub const region_type_RegionType_Module: region_type = 4;
pub const region_type_RegionType_ACPI_TABLE: region_type = 5;
#[doc = "< Must be last"]
pub const region_type_RegionType_Max: region_type = 6;
#[doc = " Memory region types."]
pub type region_type = ::std::os::raw::c_uint;
#[doc = " A memory region."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mem_region {
    #[doc = "< Address of the start of the region"]
    pub mr_base: genpaddr_t,
    #[doc = "< Type of region"]
    pub mr_type: region_type,
    #[doc = "< Size in bytes"]
    pub mr_bytes: gensize_t,
    #[doc = "< Flag for user code to mark region consumed"]
    pub mr_consumed: bool,
    #[doc = "< Size in bytes (module type only)"]
    pub mrmod_size: size_t,
    #[doc = "< Offset of module string (module type only)"]
    pub mrmod_data: isize,
    #[doc = "< First slot containing caps (module only)"]
    pub mrmod_slot: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_mem_region() {
    assert_eq!(
        ::std::mem::size_of::<mem_region>(),
        56usize,
        concat!("Size of: ", stringify!(mem_region))
    );
    assert_eq!(
        ::std::mem::align_of::<mem_region>(),
        8usize,
        concat!("Alignment of ", stringify!(mem_region))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mem_region>())).mr_base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_region),
            "::",
            stringify!(mr_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mem_region>())).mr_type as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_region),
            "::",
            stringify!(mr_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mem_region>())).mr_bytes as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_region),
            "::",
            stringify!(mr_bytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mem_region>())).mr_consumed as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_region),
            "::",
            stringify!(mr_consumed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mem_region>())).mrmod_size as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_region),
            "::",
            stringify!(mrmod_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mem_region>())).mrmod_data as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_region),
            "::",
            stringify!(mrmod_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mem_region>())).mrmod_slot as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_region),
            "::",
            stringify!(mrmod_slot)
        )
    );
}
#[doc = " This structure holds essential information for the init process to"]
#[doc = " allocate and manage its address space."]
#[repr(C)]
#[derive(Debug)]
pub struct bootinfo {
    #[doc = " For __k1om__"]
    pub host_msg: u64,
    pub host_msg_bits: u8,
    #[doc = " Number of entries in regions array"]
    pub regions_length: size_t,
    #[doc = " Amount of memory required to spawn another core"]
    pub mem_spawn_core: size_t,
    #[doc = " Memory regions array"]
    pub regions: __IncompleteArrayField<mem_region>,
}
#[test]
fn bindgen_test_layout_bootinfo() {
    assert_eq!(
        ::std::mem::size_of::<bootinfo>(),
        32usize,
        concat!("Size of: ", stringify!(bootinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<bootinfo>(),
        8usize,
        concat!("Alignment of ", stringify!(bootinfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bootinfo>())).host_msg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bootinfo),
            "::",
            stringify!(host_msg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bootinfo>())).host_msg_bits as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bootinfo),
            "::",
            stringify!(host_msg_bits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bootinfo>())).regions_length as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(bootinfo),
            "::",
            stringify!(regions_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bootinfo>())).mem_spawn_core as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(bootinfo),
            "::",
            stringify!(mem_spawn_core)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bootinfo>())).regions as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(bootinfo),
            "::",
            stringify!(regions)
        )
    );
}
pub type dispatcher_handle_t = usize;
#[repr(C)]
#[derive(Copy, Clone)]
pub union registers_aarch64 {
    pub named: registers_aarch64_registers_aarch64_named,
    pub syscall_args: registers_aarch64_registers_aarch64_syscall_args,
    pub regs: [u64; 98usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct registers_aarch64_registers_aarch64_named {
    pub x0: u64,
    pub x1: u64,
    pub x2: u64,
    pub x3: u64,
    pub x4: u64,
    pub x5: u64,
    pub x6: u64,
    pub x7: u64,
    pub x8: u64,
    pub x9: u64,
    pub x10: u64,
    pub x11: u64,
    pub x12: u64,
    pub x13: u64,
    pub x14: u64,
    pub x15: u64,
    pub x16: u64,
    pub x17: u64,
    pub x18: u64,
    pub x19: u64,
    pub x20: u64,
    pub x21: u64,
    pub x22: u64,
    pub x23: u64,
    pub x24: u64,
    pub x25: u64,
    pub x26: u64,
    pub x27: u64,
    pub x28: u64,
    pub x29: u64,
    pub x30: u64,
    pub stack: u64,
    pub pc: u64,
    pub spsr: u64,
    pub v: [[u64; 2usize]; 32usize],
}
#[test]
fn bindgen_test_layout_registers_aarch64_registers_aarch64_named() {
    assert_eq!(
        ::std::mem::size_of::<registers_aarch64_registers_aarch64_named>(),
        784usize,
        concat!(
            "Size of: ",
            stringify!(registers_aarch64_registers_aarch64_named)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<registers_aarch64_registers_aarch64_named>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(registers_aarch64_registers_aarch64_named)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<registers_aarch64_registers_aarch64_named>())).x0 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(registers_aarch64_registers_aarch64_named),
            "::",
            stringify!(x0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<registers_aarch64_registers_aarch64_named>())).x1 as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(registers_aarch64_registers_aarch64_named),
            "::",
            stringify!(x1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<registers_aarch64_registers_aarch64_named>())).x2 as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(registers_aarch64_registers_aarch64_named),
            "::",
            stringify!(x2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<registers_aarch64_registers_aarch64_named>())).x3 as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(registers_aarch64_registers_aarch64_named),
            "::",
            stringify!(x3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<registers_aarch64_registers_aarch64_named>())).x4 as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(registers_aarch64_registers_aarch64_named),
            "::",
            stringify!(x4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<registers_aarch64_registers_aarch64_named>())).x5 as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(registers_aarch64_registers_aarch64_named),
            "::",
            stringify!(x5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<registers_aarch64_registers_aarch64_named>())).x6 as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(registers_aarch64_registers_aarch64_named),
            "::",
            stringify!(x6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<registers_aarch64_registers_aarch64_named>())).x7 as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(registers_aarch64_registers_aarch64_named),
            "::",
            stringify!(x7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<registers_aarch64_registers_aarch64_named>())).x8 as *const _
                as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(registers_aarch64_registers_aarch64_named),
            "::",
            stringify!(x8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<registers_aarch64_registers_aarch64_named>())).x9 as *const _
                as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(registers_aarch64_registers_aarch64_named),
            "::",
            stringify!(x9)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<registers_aarch64_registers_aarch64_named>())).x10 as *const _
                as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(registers_aarch64_registers_aarch64_named),
            "::",
            stringify!(x10)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<registers_aarch64_registers_aarch64_named>())).x11 as *const _
                as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(registers_aarch64_registers_aarch64_named),
            "::",
            stringify!(x11)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<registers_aarch64_registers_aarch64_named>())).x12 as *const _
                as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(registers_aarch64_registers_aarch64_named),
            "::",
            stringify!(x12)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<registers_aarch64_registers_aarch64_named>())).x13 as *const _
                as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(registers_aarch64_registers_aarch64_named),
            "::",
            stringify!(x13)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<registers_aarch64_registers_aarch64_named>())).x14 as *const _
                as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(registers_aarch64_registers_aarch64_named),
            "::",
            stringify!(x14)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<registers_aarch64_registers_aarch64_named>())).x15 as *const _
                as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(registers_aarch64_registers_aarch64_named),
            "::",
            stringify!(x15)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<registers_aarch64_registers_aarch64_named>())).x16 as *const _
                as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(registers_aarch64_registers_aarch64_named),
            "::",
            stringify!(x16)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<registers_aarch64_registers_aarch64_named>())).x17 as *const _
                as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(registers_aarch64_registers_aarch64_named),
            "::",
            stringify!(x17)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<registers_aarch64_registers_aarch64_named>())).x18 as *const _
                as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(registers_aarch64_registers_aarch64_named),
            "::",
            stringify!(x18)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<registers_aarch64_registers_aarch64_named>())).x19 as *const _
                as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(registers_aarch64_registers_aarch64_named),
            "::",
            stringify!(x19)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<registers_aarch64_registers_aarch64_named>())).x20 as *const _
                as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(registers_aarch64_registers_aarch64_named),
            "::",
            stringify!(x20)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<registers_aarch64_registers_aarch64_named>())).x21 as *const _
                as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(registers_aarch64_registers_aarch64_named),
            "::",
            stringify!(x21)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<registers_aarch64_registers_aarch64_named>())).x22 as *const _
                as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(registers_aarch64_registers_aarch64_named),
            "::",
            stringify!(x22)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<registers_aarch64_registers_aarch64_named>())).x23 as *const _
                as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(registers_aarch64_registers_aarch64_named),
            "::",
            stringify!(x23)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<registers_aarch64_registers_aarch64_named>())).x24 as *const _
                as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(registers_aarch64_registers_aarch64_named),
            "::",
            stringify!(x24)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<registers_aarch64_registers_aarch64_named>())).x25 as *const _
                as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(registers_aarch64_registers_aarch64_named),
            "::",
            stringify!(x25)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<registers_aarch64_registers_aarch64_named>())).x26 as *const _
                as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(registers_aarch64_registers_aarch64_named),
            "::",
            stringify!(x26)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<registers_aarch64_registers_aarch64_named>())).x27 as *const _
                as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(registers_aarch64_registers_aarch64_named),
            "::",
            stringify!(x27)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<registers_aarch64_registers_aarch64_named>())).x28 as *const _
                as usize
        },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(registers_aarch64_registers_aarch64_named),
            "::",
            stringify!(x28)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<registers_aarch64_registers_aarch64_named>())).x29 as *const _
                as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(registers_aarch64_registers_aarch64_named),
            "::",
            stringify!(x29)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<registers_aarch64_registers_aarch64_named>())).x30 as *const _
                as usize
        },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(registers_aarch64_registers_aarch64_named),
            "::",
            stringify!(x30)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<registers_aarch64_registers_aarch64_named>())).stack as *const _
                as usize
        },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(registers_aarch64_registers_aarch64_named),
            "::",
            stringify!(stack)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<registers_aarch64_registers_aarch64_named>())).pc as *const _
                as usize
        },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(registers_aarch64_registers_aarch64_named),
            "::",
            stringify!(pc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<registers_aarch64_registers_aarch64_named>())).spsr as *const _
                as usize
        },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(registers_aarch64_registers_aarch64_named),
            "::",
            stringify!(spsr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<registers_aarch64_registers_aarch64_named>())).v as *const _
                as usize
        },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(registers_aarch64_registers_aarch64_named),
            "::",
            stringify!(v)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct registers_aarch64_registers_aarch64_syscall_args {
    pub arg0: u64,
    pub arg1: u64,
    pub arg2: u64,
    pub arg3: u64,
    pub arg4: u64,
    pub arg5: u64,
    pub arg6: u64,
    pub arg7: u64,
    pub x8: u64,
    pub x9: u64,
    pub x10: u64,
    pub x11: u64,
    pub x12: u64,
    pub x13: u64,
    pub x14: u64,
    pub x15: u64,
    pub x16: u64,
    pub x17: u64,
    pub x18: u64,
    pub x19: u64,
    pub x20: u64,
    pub x21: u64,
    pub x22: u64,
    pub x23: u64,
    pub x24: u64,
    pub x25: u64,
    pub x26: u64,
    pub x27: u64,
    pub x28: u64,
    pub x29: u64,
    pub x30: u64,
    pub stack: u64,
    pub pc: u64,
    pub spsr: u64,
    pub v: [[u64; 2usize]; 32usize],
}
#[test]
fn bindgen_test_layout_registers_aarch64_registers_aarch64_syscall_args() {
    assert_eq!(
        ::std::mem::size_of::<registers_aarch64_registers_aarch64_syscall_args>(),
        784usize,
        concat!(
            "Size of: ",
            stringify!(registers_aarch64_registers_aarch64_syscall_args)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<registers_aarch64_registers_aarch64_syscall_args>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(registers_aarch64_registers_aarch64_syscall_args)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<registers_aarch64_registers_aarch64_syscall_args>())).arg0
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(registers_aarch64_registers_aarch64_syscall_args),
            "::",
            stringify!(arg0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<registers_aarch64_registers_aarch64_syscall_args>())).arg1
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(registers_aarch64_registers_aarch64_syscall_args),
            "::",
            stringify!(arg1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<registers_aarch64_registers_aarch64_syscall_args>())).arg2
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(registers_aarch64_registers_aarch64_syscall_args),
            "::",
            stringify!(arg2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<registers_aarch64_registers_aarch64_syscall_args>())).arg3
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(registers_aarch64_registers_aarch64_syscall_args),
            "::",
            stringify!(arg3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<registers_aarch64_registers_aarch64_syscall_args>())).arg4
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(registers_aarch64_registers_aarch64_syscall_args),
            "::",
            stringify!(arg4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<registers_aarch64_registers_aarch64_syscall_args>())).arg5
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(registers_aarch64_registers_aarch64_syscall_args),
            "::",
            stringify!(arg5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<registers_aarch64_registers_aarch64_syscall_args>())).arg6
                as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(registers_aarch64_registers_aarch64_syscall_args),
            "::",
            stringify!(arg6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<registers_aarch64_registers_aarch64_syscall_args>())).arg7
                as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(registers_aarch64_registers_aarch64_syscall_args),
            "::",
            stringify!(arg7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<registers_aarch64_registers_aarch64_syscall_args>())).x8
                as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(registers_aarch64_registers_aarch64_syscall_args),
            "::",
            stringify!(x8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<registers_aarch64_registers_aarch64_syscall_args>())).x9
                as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(registers_aarch64_registers_aarch64_syscall_args),
            "::",
            stringify!(x9)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<registers_aarch64_registers_aarch64_syscall_args>())).x10
                as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(registers_aarch64_registers_aarch64_syscall_args),
            "::",
            stringify!(x10)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<registers_aarch64_registers_aarch64_syscall_args>())).x11
                as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(registers_aarch64_registers_aarch64_syscall_args),
            "::",
            stringify!(x11)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<registers_aarch64_registers_aarch64_syscall_args>())).x12
                as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(registers_aarch64_registers_aarch64_syscall_args),
            "::",
            stringify!(x12)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<registers_aarch64_registers_aarch64_syscall_args>())).x13
                as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(registers_aarch64_registers_aarch64_syscall_args),
            "::",
            stringify!(x13)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<registers_aarch64_registers_aarch64_syscall_args>())).x14
                as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(registers_aarch64_registers_aarch64_syscall_args),
            "::",
            stringify!(x14)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<registers_aarch64_registers_aarch64_syscall_args>())).x15
                as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(registers_aarch64_registers_aarch64_syscall_args),
            "::",
            stringify!(x15)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<registers_aarch64_registers_aarch64_syscall_args>())).x16
                as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(registers_aarch64_registers_aarch64_syscall_args),
            "::",
            stringify!(x16)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<registers_aarch64_registers_aarch64_syscall_args>())).x17
                as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(registers_aarch64_registers_aarch64_syscall_args),
            "::",
            stringify!(x17)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<registers_aarch64_registers_aarch64_syscall_args>())).x18
                as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(registers_aarch64_registers_aarch64_syscall_args),
            "::",
            stringify!(x18)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<registers_aarch64_registers_aarch64_syscall_args>())).x19
                as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(registers_aarch64_registers_aarch64_syscall_args),
            "::",
            stringify!(x19)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<registers_aarch64_registers_aarch64_syscall_args>())).x20
                as *const _ as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(registers_aarch64_registers_aarch64_syscall_args),
            "::",
            stringify!(x20)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<registers_aarch64_registers_aarch64_syscall_args>())).x21
                as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(registers_aarch64_registers_aarch64_syscall_args),
            "::",
            stringify!(x21)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<registers_aarch64_registers_aarch64_syscall_args>())).x22
                as *const _ as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(registers_aarch64_registers_aarch64_syscall_args),
            "::",
            stringify!(x22)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<registers_aarch64_registers_aarch64_syscall_args>())).x23
                as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(registers_aarch64_registers_aarch64_syscall_args),
            "::",
            stringify!(x23)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<registers_aarch64_registers_aarch64_syscall_args>())).x24
                as *const _ as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(registers_aarch64_registers_aarch64_syscall_args),
            "::",
            stringify!(x24)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<registers_aarch64_registers_aarch64_syscall_args>())).x25
                as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(registers_aarch64_registers_aarch64_syscall_args),
            "::",
            stringify!(x25)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<registers_aarch64_registers_aarch64_syscall_args>())).x26
                as *const _ as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(registers_aarch64_registers_aarch64_syscall_args),
            "::",
            stringify!(x26)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<registers_aarch64_registers_aarch64_syscall_args>())).x27
                as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(registers_aarch64_registers_aarch64_syscall_args),
            "::",
            stringify!(x27)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<registers_aarch64_registers_aarch64_syscall_args>())).x28
                as *const _ as usize
        },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(registers_aarch64_registers_aarch64_syscall_args),
            "::",
            stringify!(x28)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<registers_aarch64_registers_aarch64_syscall_args>())).x29
                as *const _ as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(registers_aarch64_registers_aarch64_syscall_args),
            "::",
            stringify!(x29)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<registers_aarch64_registers_aarch64_syscall_args>())).x30
                as *const _ as usize
        },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(registers_aarch64_registers_aarch64_syscall_args),
            "::",
            stringify!(x30)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<registers_aarch64_registers_aarch64_syscall_args>())).stack
                as *const _ as usize
        },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(registers_aarch64_registers_aarch64_syscall_args),
            "::",
            stringify!(stack)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<registers_aarch64_registers_aarch64_syscall_args>())).pc
                as *const _ as usize
        },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(registers_aarch64_registers_aarch64_syscall_args),
            "::",
            stringify!(pc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<registers_aarch64_registers_aarch64_syscall_args>())).spsr
                as *const _ as usize
        },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(registers_aarch64_registers_aarch64_syscall_args),
            "::",
            stringify!(spsr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<registers_aarch64_registers_aarch64_syscall_args>())).v
                as *const _ as usize
        },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(registers_aarch64_registers_aarch64_syscall_args),
            "::",
            stringify!(v)
        )
    );
}
#[test]
fn bindgen_test_layout_registers_aarch64() {
    assert_eq!(
        ::std::mem::size_of::<registers_aarch64>(),
        784usize,
        concat!("Size of: ", stringify!(registers_aarch64))
    );
    assert_eq!(
        ::std::mem::align_of::<registers_aarch64>(),
        8usize,
        concat!("Alignment of ", stringify!(registers_aarch64))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<registers_aarch64>())).named as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(registers_aarch64),
            "::",
            stringify!(named)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<registers_aarch64>())).syscall_args as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(registers_aarch64),
            "::",
            stringify!(syscall_args)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<registers_aarch64>())).regs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(registers_aarch64),
            "::",
            stringify!(regs)
        )
    );
}
pub type arch_registers_state_t = registers_aarch64;
pub type cycles_t = size_t;
pub type iref_t = u32;
#[doc = " Relative delay time (in microseconds)"]
pub type delayus_t = u64;
#[doc = " PCI addresses"]
pub type pciaddr_t = u64;
#[doc = " PCI size"]
pub type pcisize_t = u64;
pub type _coremask_word_t = u64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct coremask_t {
    pub bits: [_coremask_word_t; 4usize],
}
#[test]
fn bindgen_test_layout_coremask_t() {
    assert_eq!(
        ::std::mem::size_of::<coremask_t>(),
        32usize,
        concat!("Size of: ", stringify!(coremask_t))
    );
    assert_eq!(
        ::std::mem::align_of::<coremask_t>(),
        8usize,
        concat!("Alignment of ", stringify!(coremask_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<coremask_t>())).bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(coremask_t),
            "::",
            stringify!(bits)
        )
    );
}
pub const task_type_TASK_TYPE_BEST_EFFORT: task_type = 0;
pub const task_type_TASK_TYPE_SOFT_REALTIME: task_type = 1;
pub const task_type_TASK_TYPE_HARD_REALTIME: task_type = 2;
pub type task_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dispatcher_shared_generic {
    #[doc = "< Disabled flag (Must be able to change atomically)"]
    pub disabled: u32,
    #[doc = "< Has work (ie. is runnable) (Must be able to change atomically)"]
    pub haswork: u32,
    #[doc = "< User-mode pointer to dispatcher"]
    pub udisp: lvaddr_t,
    #[doc = "< # LMP words delivered and seen"]
    pub lmp_delivered: u32,
    #[doc = "< # LMP words delivered and seen"]
    pub lmp_seen: u32,
    #[doc = "< Hint for location of LMP"]
    pub lmp_hint: lvaddr_t,
    #[doc = "< Run entry"]
    pub dispatcher_run: lvaddr_t,
    #[doc = "< LRPC entry"]
    pub dispatcher_lrpc: lvaddr_t,
    #[doc = "< Pagefault entry"]
    pub dispatcher_pagefault: lvaddr_t,
    #[doc = "< Disabled pagefault entry"]
    pub dispatcher_pagefault_disabled: lvaddr_t,
    #[doc = "< Trap entry"]
    pub dispatcher_trap: lvaddr_t,
    #[doc = "< System time when last dispatched/resumed (W/O to kernel)"]
    pub systime: systime_t,
    #[doc = "< System time at which to wake dispatcher from sleep (R/O by kernel, on yield)"]
    pub wakeup: systime_t,
    #[doc = "< Name of domain, for debugging purposes"]
    pub name: [::std::os::raw::c_char; 16usize],
    #[doc = "< Systime frequency"]
    pub systime_frequency: u64,
    #[doc = "< Core id of current core, in this part so kernel can update"]
    pub curr_core_id: coreid_t,
}
#[test]
fn bindgen_test_layout_dispatcher_shared_generic() {
    assert_eq!(
        ::std::mem::size_of::<dispatcher_shared_generic>(),
        120usize,
        concat!("Size of: ", stringify!(dispatcher_shared_generic))
    );
    assert_eq!(
        ::std::mem::align_of::<dispatcher_shared_generic>(),
        8usize,
        concat!("Alignment of ", stringify!(dispatcher_shared_generic))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dispatcher_shared_generic>())).disabled as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dispatcher_shared_generic),
            "::",
            stringify!(disabled)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dispatcher_shared_generic>())).haswork as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(dispatcher_shared_generic),
            "::",
            stringify!(haswork)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dispatcher_shared_generic>())).udisp as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dispatcher_shared_generic),
            "::",
            stringify!(udisp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dispatcher_shared_generic>())).lmp_delivered as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(dispatcher_shared_generic),
            "::",
            stringify!(lmp_delivered)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dispatcher_shared_generic>())).lmp_seen as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(dispatcher_shared_generic),
            "::",
            stringify!(lmp_seen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dispatcher_shared_generic>())).lmp_hint as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(dispatcher_shared_generic),
            "::",
            stringify!(lmp_hint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dispatcher_shared_generic>())).dispatcher_run as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(dispatcher_shared_generic),
            "::",
            stringify!(dispatcher_run)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dispatcher_shared_generic>())).dispatcher_lrpc as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(dispatcher_shared_generic),
            "::",
            stringify!(dispatcher_lrpc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dispatcher_shared_generic>())).dispatcher_pagefault as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(dispatcher_shared_generic),
            "::",
            stringify!(dispatcher_pagefault)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dispatcher_shared_generic>())).dispatcher_pagefault_disabled
                as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(dispatcher_shared_generic),
            "::",
            stringify!(dispatcher_pagefault_disabled)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dispatcher_shared_generic>())).dispatcher_trap as *const _
                as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(dispatcher_shared_generic),
            "::",
            stringify!(dispatcher_trap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dispatcher_shared_generic>())).systime as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(dispatcher_shared_generic),
            "::",
            stringify!(systime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dispatcher_shared_generic>())).wakeup as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(dispatcher_shared_generic),
            "::",
            stringify!(wakeup)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dispatcher_shared_generic>())).name as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(dispatcher_shared_generic),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dispatcher_shared_generic>())).systime_frequency as *const _
                as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(dispatcher_shared_generic),
            "::",
            stringify!(systime_frequency)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dispatcher_shared_generic>())).curr_core_id as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(dispatcher_shared_generic),
            "::",
            stringify!(curr_core_id)
        )
    );
}
pub type fpos_t = __off_t;
pub type va_list = __va_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sbuf {
    pub _base: *mut ::std::os::raw::c_uchar,
    pub _size: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___sbuf() {
    assert_eq!(
        ::std::mem::size_of::<__sbuf>(),
        16usize,
        concat!("Size of: ", stringify!(__sbuf))
    );
    assert_eq!(
        ::std::mem::align_of::<__sbuf>(),
        8usize,
        concat!("Alignment of ", stringify!(__sbuf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sbuf>()))._base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sbuf),
            "::",
            stringify!(_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sbuf>()))._size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sbuf),
            "::",
            stringify!(_size)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sFILE {
    pub _p: *mut ::std::os::raw::c_uchar,
    pub _r: ::std::os::raw::c_int,
    pub _w: ::std::os::raw::c_int,
    pub _flags: ::std::os::raw::c_short,
    pub _file: ::std::os::raw::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: ::std::os::raw::c_int,
    pub _cookie: *mut ::std::os::raw::c_void,
    pub _close: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
    pub _read: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: *mut ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub _seek: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: fpos_t,
            arg3: ::std::os::raw::c_int,
        ) -> fpos_t,
    >,
    pub _write: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: *const ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub _ub: __sbuf,
    pub _up: *mut ::std::os::raw::c_uchar,
    pub _ur: ::std::os::raw::c_int,
    pub _ubuf: [::std::os::raw::c_uchar; 3usize],
    pub _nbuf: [::std::os::raw::c_uchar; 1usize],
    pub _lb: __sbuf,
    pub _blksize: ::std::os::raw::c_int,
    pub _offset: fpos_t,
    pub _fl_mutex: *mut pthread_mutex,
    pub _fl_owner: *mut pthread,
    pub _fl_count: ::std::os::raw::c_int,
    pub _orientation: ::std::os::raw::c_int,
    pub _mbstate: __mbstate_t,
    pub _flags2: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___sFILE() {
    assert_eq!(
        ::std::mem::size_of::<__sFILE>(),
        312usize,
        concat!("Size of: ", stringify!(__sFILE))
    );
    assert_eq!(
        ::std::mem::align_of::<__sFILE>(),
        8usize,
        concat!("Alignment of ", stringify!(__sFILE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._p as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_p)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._r as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_r)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._w as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_w)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._file as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_file)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._bf as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_bf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._lbfsize as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_lbfsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._cookie as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_cookie)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._close as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_close)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._read as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_read)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._seek as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_seek)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._write as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_write)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._ub as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ub)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._up as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_up)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._ur as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ur)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._ubuf as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ubuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._nbuf as *const _ as usize },
        119usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_nbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._lb as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_lb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._blksize as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_blksize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._offset as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._fl_mutex as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_fl_mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._fl_owner as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_fl_owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._fl_count as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_fl_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._orientation as *const _ as usize },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_orientation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._mbstate as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_mbstate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._flags2 as *const _ as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_flags2)
        )
    );
}
pub type FILE = __sFILE;
extern "C" {
    pub static mut __stdinp: *mut FILE;
}
extern "C" {
    pub static mut __stdoutp: *mut FILE;
}
extern "C" {
    pub static mut __stderrp: *mut FILE;
}
extern "C" {
    pub fn clearerr(arg1: *mut FILE);
}
extern "C" {
    pub fn fclose(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn feof(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetpos(arg1: *mut FILE, arg2: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fopen(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fprintf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputs(arg1: *const ::std::os::raw::c_char, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        arg1: *mut ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_ulong,
        arg3: ::std::os::raw::c_ulong,
        arg4: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn freopen(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fscanf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fseek(
        arg1: *mut FILE,
        arg2: ::std::os::raw::c_long,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(arg1: *mut FILE, arg2: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(arg1: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn fwrite(
        arg1: *const ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_ulong,
        arg3: ::std::os::raw::c_ulong,
        arg4: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn getc(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gets(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn perror(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn printf(arg1: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn remove(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rewind(arg1: *mut FILE);
}
extern "C" {
    pub fn scanf(arg1: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuf(arg1: *mut FILE, arg2: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        arg1: *mut FILE,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ungetc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn snprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_ulong,
        arg3: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_ulong,
        arg3: *const ::std::os::raw::c_char,
        arg4: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fdopen(arg1: ::std::os::raw::c_int, arg2: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fileno(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pclose(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn ftrylockfile(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn funlockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn getc_unlocked(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(arg1: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror_unlocked(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno_unlocked(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fseeko(
        arg1: *mut FILE,
        arg2: __off_t,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(arg1: *mut FILE) -> __off_t;
}
extern "C" {
    pub fn getw(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tempnam(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fmemopen(
        arg1: *mut ::std::os::raw::c_void,
        arg2: size_t,
        arg3: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn getdelim(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut size_t,
        arg3: ::std::os::raw::c_int,
        arg4: *mut FILE,
    ) -> ssize_t;
}
extern "C" {
    pub fn open_memstream(arg1: *mut *mut ::std::os::raw::c_char, arg2: *mut size_t) -> *mut FILE;
}
extern "C" {
    pub fn renameat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getline(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut size_t,
        arg3: *mut FILE,
    ) -> ssize_t;
}
extern "C" {
    pub fn dprintf(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn asprintf(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid_r(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcloseall();
}
extern "C" {
    pub fn fdclose(arg1: *mut FILE, arg2: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetln(arg1: *mut FILE, arg2: *mut size_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fmtcheck(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn fpurge(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(
        arg1: *mut FILE,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn setlinebuf(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vasprintf(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static sys_nerr: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut sys_errlist: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub fn funopen(
        arg1: *const ::std::os::raw::c_void,
        arg2: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *mut ::std::os::raw::c_char,
                arg3: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        arg3: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_char,
                arg3: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        arg4: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: fpos_t,
                arg3: ::std::os::raw::c_int,
            ) -> fpos_t,
        >,
        arg5: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
        >,
    ) -> *mut FILE;
}
pub type cookie_read_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_char,
        arg3: size_t,
    ) -> __ssize_t,
>;
pub type cookie_write_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
        arg3: size_t,
    ) -> __ssize_t,
>;
pub type cookie_seek_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut off64_t,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
pub type cookie_close_function_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cookie_io_functions_t {
    pub read: cookie_read_function_t,
    pub write: cookie_write_function_t,
    pub seek: cookie_seek_function_t,
    pub close: cookie_close_function_t,
}
#[test]
fn bindgen_test_layout_cookie_io_functions_t() {
    assert_eq!(
        ::std::mem::size_of::<cookie_io_functions_t>(),
        32usize,
        concat!("Size of: ", stringify!(cookie_io_functions_t))
    );
    assert_eq!(
        ::std::mem::align_of::<cookie_io_functions_t>(),
        8usize,
        concat!("Alignment of ", stringify!(cookie_io_functions_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cookie_io_functions_t>())).read as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cookie_io_functions_t),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cookie_io_functions_t>())).write as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cookie_io_functions_t),
            "::",
            stringify!(write)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cookie_io_functions_t>())).seek as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cookie_io_functions_t),
            "::",
            stringify!(seek)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cookie_io_functions_t>())).close as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cookie_io_functions_t),
            "::",
            stringify!(close)
        )
    );
}
extern "C" {
    pub fn fopencookie(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
        arg3: cookie_io_functions_t,
    ) -> *mut FILE;
}
extern "C" {
    pub fn __srget(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __swbuf(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut __isthreaded: ::std::os::raw::c_int;
}
pub type distcap_state_t = u8;
pub const static_assert_14: ::std::os::raw::c_uint = 1;
pub type _bindgen_ty_2 = ::std::os::raw::c_uint;
pub const static_assert_15: ::std::os::raw::c_uint = 1;
pub type _bindgen_ty_3 = ::std::os::raw::c_uint;
pub const cnode_type_CNODE_TYPE_ROOT: cnode_type = 0;
pub const cnode_type_CNODE_TYPE_OTHER: cnode_type = 1;
pub const cnode_type_CNODE_TYPE_COUNT: cnode_type = 2;
pub type cnode_type = ::std::os::raw::c_uchar;
#[doc = " \\brief User-level representation of a CNode, this is essentially a capref"]
#[doc = " to a CNode."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct cnoderef {
    pub croot: capaddr_t,
    pub cnode: capaddr_t,
    pub level: cnode_type,
}
#[test]
fn bindgen_test_layout_cnoderef() {
    assert_eq!(
        ::std::mem::size_of::<cnoderef>(),
        9usize,
        concat!("Size of: ", stringify!(cnoderef))
    );
    assert_eq!(
        ::std::mem::align_of::<cnoderef>(),
        1usize,
        concat!("Alignment of ", stringify!(cnoderef))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cnoderef>())).croot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cnoderef),
            "::",
            stringify!(croot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cnoderef>())).cnode as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cnoderef),
            "::",
            stringify!(cnode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cnoderef>())).level as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cnoderef),
            "::",
            stringify!(level)
        )
    );
}
#[doc = " \\brief User-level representation of a capability and its CSpace address"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct capref {
    pub cnode: cnoderef,
    pub slot: cslot_t,
}
#[test]
fn bindgen_test_layout_capref() {
    assert_eq!(
        ::std::mem::size_of::<capref>(),
        16usize,
        concat!("Size of: ", stringify!(capref))
    );
    assert_eq!(
        ::std::mem::align_of::<capref>(),
        4usize,
        concat!("Alignment of ", stringify!(capref))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<capref>())).cnode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(capref),
            "::",
            stringify!(cnode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<capref>())).slot as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(capref),
            "::",
            stringify!(slot)
        )
    );
}
extern "C" {
    pub static mut cnode_root: cnoderef;
}
extern "C" {
    pub static mut cnode_task: cnoderef;
}
extern "C" {
    pub static mut cnode_base: cnoderef;
}
extern "C" {
    pub static mut cnode_super: cnoderef;
}
extern "C" {
    pub static mut cnode_page: cnoderef;
}
extern "C" {
    pub static mut cnode_module: cnoderef;
}
extern "C" {
    pub static mut cap_root: capref;
}
extern "C" {
    pub static mut cap_monitorep: capref;
}
extern "C" {
    pub static mut cap_irq: capref;
}
extern "C" {
    pub static mut cap_io: capref;
}
extern "C" {
    pub static mut cap_dispatcher: capref;
}
extern "C" {
    pub static mut cap_selfep: capref;
}
extern "C" {
    pub static mut cap_kernel: capref;
}
extern "C" {
    pub static mut cap_initep: capref;
}
extern "C" {
    pub static mut cap_perfmon: capref;
}
extern "C" {
    pub static mut cap_dispframe: capref;
}
extern "C" {
    pub static mut cap_sessionid: capref;
}
extern "C" {
    pub static mut cap_ipi: capref;
}
extern "C" {
    pub static mut cap_vroot: capref;
}
extern "C" {
    pub static mut cap_argcn: capref;
}
extern "C" {
    pub static mut cap_procmng: capref;
}
extern "C" {
    pub static mut cap_domainid: capref;
}
extern "C" {
    pub static mut cap_bootinfo: capref;
}
extern "C" {
    pub static mut cap_mmstrings: capref;
}
#[doc = " A thread of execution"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct thread {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct thread_mutex {
    pub locked: ::std::os::raw::c_int,
    pub queue: *mut thread,
    pub lock: spinlock_t,
    pub holder: *mut thread,
}
#[test]
fn bindgen_test_layout_thread_mutex() {
    assert_eq!(
        ::std::mem::size_of::<thread_mutex>(),
        32usize,
        concat!("Size of: ", stringify!(thread_mutex))
    );
    assert_eq!(
        ::std::mem::align_of::<thread_mutex>(),
        8usize,
        concat!("Alignment of ", stringify!(thread_mutex))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_mutex>())).locked as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_mutex),
            "::",
            stringify!(locked)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_mutex>())).queue as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_mutex),
            "::",
            stringify!(queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_mutex>())).lock as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_mutex),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_mutex>())).holder as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_mutex),
            "::",
            stringify!(holder)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct thread_cond {
    pub queue: *mut thread,
    pub lock: spinlock_t,
}
#[test]
fn bindgen_test_layout_thread_cond() {
    assert_eq!(
        ::std::mem::size_of::<thread_cond>(),
        16usize,
        concat!("Size of: ", stringify!(thread_cond))
    );
    assert_eq!(
        ::std::mem::align_of::<thread_cond>(),
        8usize,
        concat!("Alignment of ", stringify!(thread_cond))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_cond>())).queue as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_cond),
            "::",
            stringify!(queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_cond>())).lock as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_cond),
            "::",
            stringify!(lock)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct thread_sem {
    pub value: ::std::os::raw::c_uint,
    pub queue: *mut thread,
    pub lock: spinlock_t,
}
#[test]
fn bindgen_test_layout_thread_sem() {
    assert_eq!(
        ::std::mem::size_of::<thread_sem>(),
        24usize,
        concat!("Size of: ", stringify!(thread_sem))
    );
    assert_eq!(
        ::std::mem::align_of::<thread_sem>(),
        8usize,
        concat!("Alignment of ", stringify!(thread_sem))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_sem>())).value as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_sem),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_sem>())).queue as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_sem),
            "::",
            stringify!(queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_sem>())).lock as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_sem),
            "::",
            stringify!(lock)
        )
    );
}
pub type thread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct thread_barrier {
    pub count: u64,
    pub max_count: u64,
    pub mutex: thread_sem,
    pub barrier: thread_sem,
    pub reset: thread_sem,
}
#[test]
fn bindgen_test_layout_thread_barrier() {
    assert_eq!(
        ::std::mem::size_of::<thread_barrier>(),
        88usize,
        concat!("Size of: ", stringify!(thread_barrier))
    );
    assert_eq!(
        ::std::mem::align_of::<thread_barrier>(),
        8usize,
        concat!("Alignment of ", stringify!(thread_barrier))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_barrier>())).count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_barrier),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_barrier>())).max_count as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_barrier),
            "::",
            stringify!(max_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_barrier>())).mutex as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_barrier),
            "::",
            stringify!(mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_barrier>())).barrier as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_barrier),
            "::",
            stringify!(barrier)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_barrier>())).reset as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_barrier),
            "::",
            stringify!(reset)
        )
    );
}
extern "C" {
    pub fn disp_init_disabled(handle: dispatcher_handle_t);
}
extern "C" {
    pub fn disp_init_onthread() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn disp_disable() -> dispatcher_handle_t;
}
extern "C" {
    pub fn disp_try_disable(was_enabled: *mut bool) -> dispatcher_handle_t;
}
extern "C" {
    pub fn disp_enable(handle: dispatcher_handle_t);
}
extern "C" {
    pub fn disp_arch_init(handle: dispatcher_handle_t);
}
extern "C" {
    #[doc = " \\brief Resume execution of a given register state"]
    #[doc = ""]
    #[doc = " This function resumes the execution of the given register state on the"]
    #[doc = " current dispatcher. It may only be called while the dispatcher is disabled."]
    #[doc = ""]
    #[doc = " \\param disp Current dispatcher pointer"]
    #[doc = " \\param regs Register state snapshot"]
    pub fn disp_resume(handle: dispatcher_handle_t, archregs: *mut arch_registers_state_t);
}
extern "C" {
    #[doc = " \\brief Switch execution between two register states, and turn off"]
    #[doc = " disabled activations."]
    #[doc = ""]
    #[doc = " This function saves as much as necessary of the current register state"]
    #[doc = " (which, when resumed will return to the caller), and switches execution"]
    #[doc = " by resuming the given register state.  It may only be called while the"]
    #[doc = " dispatcher is disabled.  A side effect is that activations are reenabled."]
    #[doc = " Note that the thread context saved is a voluntary save so only callee"]
    #[doc = " save registers need to be saved, but we dont currently provide any"]
    #[doc = " way to optimise the corresponding resume."]
    #[doc = ""]
    #[doc = " \\param disp Current dispatcher pointer"]
    #[doc = " \\param from_regs Location to save current register state"]
    #[doc = " \\param to_regs Location from which to resume new register state"]
    pub fn disp_switch(
        handle: dispatcher_handle_t,
        from_state: *mut arch_registers_state_t,
        to_state: *mut arch_registers_state_t,
    );
}
extern "C" {
    #[doc = " \\brief Save the current register state and optionally yield the CPU"]
    #[doc = ""]
    #[doc = " This function saves as much as necessary of the current register state"]
    #[doc = " (which, when resumed will return to the caller), and then either"]
    #[doc = " re-enters the thread scheduler or yields the CPU."]
    #[doc = " It may only be called while the dispatcher is disabled."]
    #[doc = " Note that the thread context saved is a voluntary save so only callee"]
    #[doc = " save registers need to be saved, but we dont currently provide any"]
    #[doc = " way to optimise the corresponding resume."]
    #[doc = ""]
    #[doc = " \\param disp Current dispatcher pointer"]
    #[doc = " \\param regs Location to save current register state"]
    #[doc = " \\param yield If true, yield CPU to kernel; otherwise re-run thread scheduler"]
    #[doc = " \\param yield_to Endpoint capability for dispatcher to which we want to yield"]
    pub fn disp_save(
        handle: dispatcher_handle_t,
        state: *mut arch_registers_state_t,
        yield_: bool,
        yield_to: capaddr_t,
    );
}
extern "C" {
    pub fn disp_save_suspend();
}
extern "C" {
    pub fn disp_save_rm_kcb();
}
extern "C" {
    pub fn disp_yield_disabled(handle: dispatcher_handle_t);
}
extern "C" {
    pub fn disp_new(core_id: ::std::os::raw::c_int) -> dispatcher_handle_t;
}
extern "C" {
    pub fn disp_name() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn disp_run_counter() -> u64;
}
extern "C" {
    pub fn disp_assert_fail(
        exp: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        func: *const ::std::os::raw::c_char,
        line: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn disp_warn_fail(
        exp: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        func: *const ::std::os::raw::c_char,
        line: *const ::std::os::raw::c_char,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct event_closure {
    pub handler: ::std::option::Option<unsafe extern "C" fn(arg: *mut ::std::os::raw::c_void)>,
    pub arg: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_event_closure() {
    assert_eq!(
        ::std::mem::size_of::<event_closure>(),
        16usize,
        concat!("Size of: ", stringify!(event_closure))
    );
    assert_eq!(
        ::std::mem::align_of::<event_closure>(),
        8usize,
        concat!("Alignment of ", stringify!(event_closure))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<event_closure>())).handler as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(event_closure),
            "::",
            stringify!(handler)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<event_closure>())).arg as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(event_closure),
            "::",
            stringify!(arg)
        )
    );
}
pub const ws_chantype_CHANTYPE_LMP_IN: ws_chantype = 0;
pub const ws_chantype_CHANTYPE_LMP_OUT: ws_chantype = 1;
pub const ws_chantype_CHANTYPE_UMP_IN: ws_chantype = 2;
#[doc = "< Timer events"]
pub const ws_chantype_CHANTYPE_DEFERRED: ws_chantype = 3;
pub const ws_chantype_CHANTYPE_EVENT_QUEUE: ws_chantype = 4;
pub const ws_chantype_CHANTYPE_OTHER: ws_chantype = 5;
#[doc = " \\brief Channel type"]
#[doc = ""]
#[doc = " This is used for debugging and to determine the function to call when polling."]
pub type ws_chantype = ::std::os::raw::c_uint;
#[doc = "< Initialised, but not yet registered on a waitset"]
pub const ws_chanstate_CHAN_UNREGISTERED: ws_chanstate = 0;
#[doc = "< Has a registered event handler, but the event has not fired"]
pub const ws_chanstate_CHAN_IDLE: ws_chanstate = 1;
#[doc = "< Idle and polled. Channel implementation must be called to check for pending events"]
pub const ws_chanstate_CHAN_POLLED: ws_chanstate = 2;
#[doc = "< Has a pending event waiting to be delivered"]
pub const ws_chanstate_CHAN_PENDING: ws_chanstate = 3;
#[doc = "< There's no registered event handler (for now)"]
pub const ws_chanstate_CHAN_WAITING: ws_chanstate = 4;
#[doc = " Current state of a channel on a specific waitset"]
pub type ws_chanstate = ::std::os::raw::c_uint;
#[doc = " \\brief Per-channel state belonging to waitset"]
#[doc = ""]
#[doc = " This data is logically private to the waitset, but is allocated and stored"]
#[doc = " inside the channels themselves."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct waitset_chanstate {
    #[doc = "< Next/prev channel in queue"]
    pub next: *mut waitset_chanstate,
    #[doc = "< Next/prev channel in queue"]
    pub prev: *mut waitset_chanstate,
    #[doc = "< Waitset in which this channel is registered"]
    pub waitset: *mut waitset,
    #[doc = "< Event closure to run when channel is ready"]
    pub closure: event_closure,
    #[doc = "< Channel type"]
    pub chantype: ws_chantype,
    #[doc = "< Channel event state"]
    pub state: ws_chanstate,
    #[doc = "< Token of an event"]
    pub token: u32,
    #[doc = "< Channel should be always registered"]
    pub persistent: bool,
    #[doc = "< Dispatcher's polled queue"]
    pub polled_next: *mut waitset_chanstate,
    #[doc = "< Dispatcher's polled queue"]
    pub polled_prev: *mut waitset_chanstate,
    #[doc = "< Thread waiting for this event"]
    pub wait_for: *mut thread,
    #[doc = "< Chanstate that triggers this chanstate"]
    pub trigger: *mut waitset_chanstate,
    #[doc = "< custom argument"]
    pub arg: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_waitset_chanstate() {
    assert_eq!(
        ::std::mem::size_of::<waitset_chanstate>(),
        96usize,
        concat!("Size of: ", stringify!(waitset_chanstate))
    );
    assert_eq!(
        ::std::mem::align_of::<waitset_chanstate>(),
        8usize,
        concat!("Alignment of ", stringify!(waitset_chanstate))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<waitset_chanstate>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(waitset_chanstate),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<waitset_chanstate>())).prev as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(waitset_chanstate),
            "::",
            stringify!(prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<waitset_chanstate>())).waitset as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(waitset_chanstate),
            "::",
            stringify!(waitset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<waitset_chanstate>())).closure as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(waitset_chanstate),
            "::",
            stringify!(closure)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<waitset_chanstate>())).chantype as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(waitset_chanstate),
            "::",
            stringify!(chantype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<waitset_chanstate>())).state as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(waitset_chanstate),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<waitset_chanstate>())).token as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(waitset_chanstate),
            "::",
            stringify!(token)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<waitset_chanstate>())).persistent as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(waitset_chanstate),
            "::",
            stringify!(persistent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<waitset_chanstate>())).polled_next as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(waitset_chanstate),
            "::",
            stringify!(polled_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<waitset_chanstate>())).polled_prev as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(waitset_chanstate),
            "::",
            stringify!(polled_prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<waitset_chanstate>())).wait_for as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(waitset_chanstate),
            "::",
            stringify!(wait_for)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<waitset_chanstate>())).trigger as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(waitset_chanstate),
            "::",
            stringify!(trigger)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<waitset_chanstate>())).arg as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(waitset_chanstate),
            "::",
            stringify!(arg)
        )
    );
}
#[doc = " \\brief Wait set"]
#[doc = ""]
#[doc = " This data is private to the waitset (a waitset is an opaque type),"]
#[doc = " but defined in the header for allocation purposes."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct waitset {
    #[doc = "< Channels with pending events"]
    pub pending: *mut waitset_chanstate,
    #[doc = "< Channels that need to be polled"]
    pub polled: *mut waitset_chanstate,
    #[doc = "< All other channels on this waitset"]
    pub idle: *mut waitset_chanstate,
    #[doc = "< Channels waiting for an event handler registration"]
    pub waiting: *mut waitset_chanstate,
    #[doc = " Queue of threads blocked on this waitset (when no events are pending)"]
    pub waiting_threads: *mut thread,
}
#[test]
fn bindgen_test_layout_waitset() {
    assert_eq!(
        ::std::mem::size_of::<waitset>(),
        40usize,
        concat!("Size of: ", stringify!(waitset))
    );
    assert_eq!(
        ::std::mem::align_of::<waitset>(),
        8usize,
        concat!("Alignment of ", stringify!(waitset))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<waitset>())).pending as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(waitset),
            "::",
            stringify!(pending)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<waitset>())).polled as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(waitset),
            "::",
            stringify!(polled)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<waitset>())).idle as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(waitset),
            "::",
            stringify!(idle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<waitset>())).waiting as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(waitset),
            "::",
            stringify!(waiting)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<waitset>())).waiting_threads as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(waitset),
            "::",
            stringify!(waiting_threads)
        )
    );
}
extern "C" {
    pub fn poll_channels_disabled(handle: dispatcher_handle_t);
}
extern "C" {
    pub fn waitset_init(ws: *mut waitset);
}
extern "C" {
    pub fn waitset_destroy(ws: *mut waitset) -> errval_t;
}
extern "C" {
    pub fn get_next_event(ws: *mut waitset, retclosure: *mut event_closure) -> errval_t;
}
extern "C" {
    pub fn get_next_event_disabled(
        ws: *mut waitset,
        retchan: *mut *mut waitset_chanstate,
        retclosure: *mut event_closure,
        waitfor: *mut waitset_chanstate,
        waitfor2: *mut waitset_chanstate,
        handle: dispatcher_handle_t,
        debug: bool,
    ) -> errval_t;
}
extern "C" {
    pub fn check_for_event(ws: *mut waitset) -> errval_t;
}
extern "C" {
    pub fn event_dispatch(ws: *mut waitset) -> errval_t;
}
extern "C" {
    pub fn wait_for_channel(
        ws: *mut waitset,
        channel: *mut waitset_chanstate,
        error_var: *mut errval_t,
    ) -> errval_t;
}
extern "C" {
    pub fn event_dispatch_disabled(ws: *mut waitset, handle: dispatcher_handle_t) -> errval_t;
}
extern "C" {
    pub fn event_dispatch_debug(ws: *mut waitset) -> errval_t;
}
extern "C" {
    pub fn event_dispatch_non_block(ws: *mut waitset) -> errval_t;
}
pub type thread_func_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn thread_create(
        start_func: thread_func_t,
        data: *mut ::std::os::raw::c_void,
    ) -> *mut thread;
}
extern "C" {
    pub fn thread_create_varstack(
        start_func: thread_func_t,
        arg: *mut ::std::os::raw::c_void,
        stacksize: size_t,
    ) -> *mut thread;
}
extern "C" {
    pub fn thread_yield();
}
extern "C" {
    pub fn thread_yield_dispatcher(endpoint: capref);
}
extern "C" {
    pub fn thread_exit(status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn thread_self() -> *mut thread;
}
extern "C" {
    pub fn thread_self_disabled() -> *mut thread;
}
extern "C" {
    pub fn thread_join(thread: *mut thread, retval: *mut ::std::os::raw::c_int) -> errval_t;
}
extern "C" {
    pub fn thread_detach(thread: *mut thread) -> errval_t;
}
extern "C" {
    pub fn thread_pause(thread: *mut thread);
}
extern "C" {
    pub fn thread_pause_and_capture_state(
        thread: *mut thread,
        ret_regs: *mut *mut arch_registers_state_t,
    );
}
extern "C" {
    pub fn thread_resume(thread: *mut thread);
}
extern "C" {
    pub fn thread_mutex_init(mutex: *mut thread_mutex);
}
extern "C" {
    pub fn thread_mutex_lock(mutex: *mut thread_mutex);
}
extern "C" {
    pub fn thread_mutex_trylock(mutex: *mut thread_mutex) -> bool;
}
extern "C" {
    pub fn thread_mutex_lock_nested(mutex: *mut thread_mutex);
}
extern "C" {
    pub fn thread_mutex_unlock(mutex: *mut thread_mutex);
}
extern "C" {
    pub fn thread_mutex_unlock_disabled(
        handle: dispatcher_handle_t,
        mutex: *mut thread_mutex,
    ) -> *mut thread;
}
extern "C" {
    pub fn thread_cond_init(cond: *mut thread_cond);
}
extern "C" {
    pub fn thread_cond_signal(cond: *mut thread_cond);
}
extern "C" {
    pub fn thread_cond_broadcast(cond: *mut thread_cond);
}
extern "C" {
    pub fn thread_cond_wait(cond: *mut thread_cond, mutex: *mut thread_mutex);
}
extern "C" {
    pub fn thread_sem_init(sem: *mut thread_sem, value: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn thread_sem_wait(sem: *mut thread_sem);
}
extern "C" {
    pub fn thread_sem_trywait(sem: *mut thread_sem) -> bool;
}
extern "C" {
    pub fn thread_sem_post(sem: *mut thread_sem);
}
extern "C" {
    pub fn thread_set_tls(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn thread_get_tls() -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn thread_set_tls_key(arg1: ::std::os::raw::c_int, arg2: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn thread_get_tls_key(arg1: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn thread_id() -> usize;
}
extern "C" {
    pub fn thread_get_id(t: *mut thread) -> usize;
}
extern "C" {
    pub fn thread_set_id(id: usize);
}
extern "C" {
    pub fn thread_set_token(channel: *mut waitset_chanstate) -> u32;
}
extern "C" {
    pub fn thread_clear_token(channel: *mut waitset_chanstate);
}
extern "C" {
    pub fn thread_current_token() -> u32;
}
extern "C" {
    pub fn thread_set_outgoing_token(token: u32);
}
extern "C" {
    pub fn thread_get_outgoing_token(token: *mut u32);
}
extern "C" {
    #[doc = " Set/get a local trigger for currently processed event channel"]
    pub fn thread_set_local_trigger(trigger: *mut waitset_chanstate);
}
extern "C" {
    pub fn thread_get_local_trigger() -> *mut waitset_chanstate;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct flounder_rpc_context {
    _unused: [u8; 0],
}
extern "C" {
    pub fn thread_set_rpc_in_progress(v: bool);
}
extern "C" {
    pub fn thread_get_rpc_in_progress() -> bool;
}
extern "C" {
    pub fn thread_set_async_error(e: errval_t);
}
extern "C" {
    pub fn thread_get_async_error() -> errval_t;
}
extern "C" {
    pub fn thread_store_recv_slot(recv_slot: capref);
}
extern "C" {
    pub fn thread_get_next_recv_slot() -> capref;
}
extern "C" {
    pub static mut thread_once_local_epoch: thread_once_t;
}
extern "C" {
    pub fn thread_once_internal(
        control: *mut thread_once_t,
        func: ::std::option::Option<unsafe extern "C" fn()>,
    );
}
extern "C" {
    #[doc = " \\brief Set a thread's exit status."]
    #[doc = ""]
    #[doc = " \\param status The status."]
    pub fn thread_set_status(status: ::std::os::raw::c_int);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct block_head {
    _unused: [u8; 0],
}
pub type slab_refill_func_t =
    ::std::option::Option<unsafe extern "C" fn(slabs: *mut slab_allocator) -> errval_t>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slab_head {
    #[doc = "< Next slab in the allocator"]
    pub next: *mut slab_head,
    #[doc = "< Count of total and free blocks in this slab"]
    pub total: u32,
    #[doc = "< Count of total and free blocks in this slab"]
    pub free: u32,
    #[doc = "< Pointer to free block list"]
    pub blocks: *mut block_head,
}
#[test]
fn bindgen_test_layout_slab_head() {
    assert_eq!(
        ::std::mem::size_of::<slab_head>(),
        24usize,
        concat!("Size of: ", stringify!(slab_head))
    );
    assert_eq!(
        ::std::mem::align_of::<slab_head>(),
        8usize,
        concat!("Alignment of ", stringify!(slab_head))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<slab_head>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slab_head),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<slab_head>())).total as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(slab_head),
            "::",
            stringify!(total)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<slab_head>())).free as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(slab_head),
            "::",
            stringify!(free)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<slab_head>())).blocks as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(slab_head),
            "::",
            stringify!(blocks)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slab_allocator {
    #[doc = "< Pointer to list of slabs"]
    pub slabs: *mut slab_head,
    #[doc = "< Size of blocks managed by this allocator"]
    pub blocksize: size_t,
    #[doc = "< Refill function"]
    pub refill_func: slab_refill_func_t,
}
#[test]
fn bindgen_test_layout_slab_allocator() {
    assert_eq!(
        ::std::mem::size_of::<slab_allocator>(),
        24usize,
        concat!("Size of: ", stringify!(slab_allocator))
    );
    assert_eq!(
        ::std::mem::align_of::<slab_allocator>(),
        8usize,
        concat!("Alignment of ", stringify!(slab_allocator))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<slab_allocator>())).slabs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slab_allocator),
            "::",
            stringify!(slabs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<slab_allocator>())).blocksize as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(slab_allocator),
            "::",
            stringify!(blocksize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<slab_allocator>())).refill_func as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(slab_allocator),
            "::",
            stringify!(refill_func)
        )
    );
}
extern "C" {
    pub fn slab_init(
        slabs: *mut slab_allocator,
        blocksize: size_t,
        refill_func: slab_refill_func_t,
    );
}
extern "C" {
    pub fn slab_grow(slabs: *mut slab_allocator, buf: *mut ::std::os::raw::c_void, buflen: size_t);
}
extern "C" {
    pub fn slab_alloc(slabs: *mut slab_allocator) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn slab_free(slabs: *mut slab_allocator, block: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn slab_freecount(slabs: *mut slab_allocator) -> size_t;
}
extern "C" {
    pub fn slab_default_refill(slabs: *mut slab_allocator) -> errval_t;
}
pub const exception_type_EXCEPT_NULL: exception_type = 0;
#[doc = "< Page fault (or other memory access fault)"]
pub const exception_type_EXCEPT_PAGEFAULT: exception_type = 1;
#[doc = "< Software breakpoint"]
pub const exception_type_EXCEPT_BREAKPOINT: exception_type = 2;
#[doc = "< Single-step execution"]
pub const exception_type_EXCEPT_SINGLESTEP: exception_type = 3;
pub const exception_type_EXCEPT_OTHER: exception_type = 4;
pub type exception_type = ::std::os::raw::c_uint;
pub const pagefault_exception_type_PAGEFLT_NULL: pagefault_exception_type = 0;
#[doc = "< Read page fault"]
pub const pagefault_exception_type_PAGEFLT_READ: pagefault_exception_type = 1;
#[doc = "< Write page fault"]
pub const pagefault_exception_type_PAGEFLT_WRITE: pagefault_exception_type = 2;
#[doc = "< Execute (instruction fetch) page fault"]
pub const pagefault_exception_type_PAGEFLT_EXEC: pagefault_exception_type = 3;
#[doc = " Subtype for page fault exceptions"]
pub type pagefault_exception_type = ::std::os::raw::c_uint;
#[doc = " \\brief Exception handler function"]
#[doc = ""]
#[doc = " \\param type    Exception type"]
#[doc = " \\param subtype Exception subtype"]
#[doc = " \\param addr    Exception address"]
#[doc = " \\param regs    Register state at time of exception"]
#[doc = " \\param fpuregs FPU state at time of exception. NULL if unused."]
#[doc = ""]
#[doc = " \\return If this function returns, the register state specified in"]
#[doc = " regs/fpuregs will be resumed."]
pub type exception_handler_fn = ::std::option::Option<
    unsafe extern "C" fn(
        type_: exception_type,
        subtype: ::std::os::raw::c_int,
        addr: *mut ::std::os::raw::c_void,
        regs: *mut arch_registers_state_t,
    ),
>;
extern "C" {
    pub fn thread_set_exception_handler(
        newhandler: exception_handler_fn,
        oldhandler: *mut exception_handler_fn,
        new_stack_base: *mut ::std::os::raw::c_void,
        new_stack_top: *mut ::std::os::raw::c_void,
        old_stack_base: *mut *mut ::std::os::raw::c_void,
        old_stack_top: *mut *mut ::std::os::raw::c_void,
    ) -> errval_t;
}
pub type paging_flags_t = ::std::os::raw::c_int;
#[doc = "< for free paging regions (may be allocated)"]
pub const paging_region_type_PAGING_REGION_FREE: paging_region_type = 0;
#[doc = "< for occupied regions (addresses less than VADDR_OFFSET)"]
pub const paging_region_type_PAGING_REGION_UNUSABLE: paging_region_type = 1;
#[doc = "< for malloc area e.a."]
pub const paging_region_type_PAGING_REGION_HEAP: paging_region_type = 2;
#[doc = "< for thread stacks"]
pub const paging_region_type_PAGING_REGION_STACK: paging_region_type = 3;
pub const paging_region_type_PAGING_REGION_OTHER: paging_region_type = 4;
pub type paging_region_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct paging_region {
    pub base_addr: lvaddr_t,
    pub current_addr: lvaddr_t,
    pub region_size: size_t,
    pub region_name: [::std::os::raw::c_char; 32usize],
    pub type_: paging_region_type,
    pub lazily_mapped: bool,
    pub map_large_pages: bool,
    #[doc = "< lazily mapped pages should be mapped using this flag"]
    pub flags: paging_flags_t,
    pub next: *mut paging_region,
    pub prev: *mut paging_region,
}
#[test]
fn bindgen_test_layout_paging_region() {
    assert_eq!(
        ::std::mem::size_of::<paging_region>(),
        88usize,
        concat!("Size of: ", stringify!(paging_region))
    );
    assert_eq!(
        ::std::mem::align_of::<paging_region>(),
        8usize,
        concat!("Alignment of ", stringify!(paging_region))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<paging_region>())).base_addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(paging_region),
            "::",
            stringify!(base_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<paging_region>())).current_addr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(paging_region),
            "::",
            stringify!(current_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<paging_region>())).region_size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(paging_region),
            "::",
            stringify!(region_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<paging_region>())).region_name as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(paging_region),
            "::",
            stringify!(region_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<paging_region>())).type_ as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(paging_region),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<paging_region>())).lazily_mapped as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(paging_region),
            "::",
            stringify!(lazily_mapped)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<paging_region>())).map_large_pages as *const _ as usize },
        61usize,
        concat!(
            "Offset of field: ",
            stringify!(paging_region),
            "::",
            stringify!(map_large_pages)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<paging_region>())).flags as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(paging_region),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<paging_region>())).next as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(paging_region),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<paging_region>())).prev as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(paging_region),
            "::",
            stringify!(prev)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_guard {
    pub next: *mut stack_guard,
    pub stack_bottom: lvaddr_t,
    pub thread_id: usize,
}
#[test]
fn bindgen_test_layout_stack_guard() {
    assert_eq!(
        ::std::mem::size_of::<stack_guard>(),
        24usize,
        concat!("Size of: ", stringify!(stack_guard))
    );
    assert_eq!(
        ::std::mem::align_of::<stack_guard>(),
        8usize,
        concat!("Alignment of ", stringify!(stack_guard))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stack_guard>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stack_guard),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stack_guard>())).stack_bottom as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(stack_guard),
            "::",
            stringify!(stack_bottom)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stack_guard>())).thread_id as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(stack_guard),
            "::",
            stringify!(thread_id)
        )
    );
}
#[doc = " \\brief shadow page table"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mapping_table {
    #[doc = " capref to the pagetable"]
    pub pt_cap: capref,
    #[doc = " paging region that contains the first vaddr that is mapped in this pt"]
    pub region: *mut paging_region,
    #[doc = " mappings in this table"]
    pub mapping_caps: [capref; 512usize],
    #[doc = " \\brief child tables"]
    #[doc = ""]
    #[doc = " \\note If at a certain index this array is NULL but the corresponding"]
    #[doc = "       entry in mapping_caps is not a null capref, this means that a"]
    #[doc = "       superpage mapping is done in this entry"]
    #[doc = ""]
    pub children: [*mut mapping_table; 512usize],
}
#[test]
fn bindgen_test_layout_mapping_table() {
    assert_eq!(
        ::std::mem::size_of::<mapping_table>(),
        12312usize,
        concat!("Size of: ", stringify!(mapping_table))
    );
    assert_eq!(
        ::std::mem::align_of::<mapping_table>(),
        8usize,
        concat!("Alignment of ", stringify!(mapping_table))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mapping_table>())).pt_cap as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mapping_table),
            "::",
            stringify!(pt_cap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mapping_table>())).region as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mapping_table),
            "::",
            stringify!(region)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mapping_table>())).mapping_caps as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(mapping_table),
            "::",
            stringify!(mapping_caps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mapping_table>())).children as *const _ as usize },
        8216usize,
        concat!(
            "Offset of field: ",
            stringify!(mapping_table),
            "::",
            stringify!(children)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct paging_state {
    pub mutex: thread_mutex,
    pub slot_alloc: *mut slot_allocator,
    pub map_l0: mapping_table,
    pub mappings_alloc: slab_allocator,
    pub mappings_alloc_is_refilling: bool,
    pub head: *mut paging_region,
    pub vaddr_offset_region: paging_region,
    pub free_region: paging_region,
    pub heap_region: paging_region,
    pub meta_region: paging_region,
    pub stack_region: paging_region,
}
#[test]
fn bindgen_test_layout_paging_state() {
    assert_eq!(
        ::std::mem::size_of::<paging_state>(),
        12832usize,
        concat!("Size of: ", stringify!(paging_state))
    );
    assert_eq!(
        ::std::mem::align_of::<paging_state>(),
        8usize,
        concat!("Alignment of ", stringify!(paging_state))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<paging_state>())).mutex as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(paging_state),
            "::",
            stringify!(mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<paging_state>())).slot_alloc as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(paging_state),
            "::",
            stringify!(slot_alloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<paging_state>())).map_l0 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(paging_state),
            "::",
            stringify!(map_l0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<paging_state>())).mappings_alloc as *const _ as usize },
        12352usize,
        concat!(
            "Offset of field: ",
            stringify!(paging_state),
            "::",
            stringify!(mappings_alloc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<paging_state>())).mappings_alloc_is_refilling as *const _
                as usize
        },
        12376usize,
        concat!(
            "Offset of field: ",
            stringify!(paging_state),
            "::",
            stringify!(mappings_alloc_is_refilling)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<paging_state>())).head as *const _ as usize },
        12384usize,
        concat!(
            "Offset of field: ",
            stringify!(paging_state),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<paging_state>())).vaddr_offset_region as *const _ as usize
        },
        12392usize,
        concat!(
            "Offset of field: ",
            stringify!(paging_state),
            "::",
            stringify!(vaddr_offset_region)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<paging_state>())).free_region as *const _ as usize },
        12480usize,
        concat!(
            "Offset of field: ",
            stringify!(paging_state),
            "::",
            stringify!(free_region)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<paging_state>())).heap_region as *const _ as usize },
        12568usize,
        concat!(
            "Offset of field: ",
            stringify!(paging_state),
            "::",
            stringify!(heap_region)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<paging_state>())).meta_region as *const _ as usize },
        12656usize,
        concat!(
            "Offset of field: ",
            stringify!(paging_state),
            "::",
            stringify!(meta_region)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<paging_state>())).stack_region as *const _ as usize },
        12744usize,
        concat!(
            "Offset of field: ",
            stringify!(paging_state),
            "::",
            stringify!(stack_region)
        )
    );
}
extern "C" {
    pub fn frame_alloc_and_map_flags(
        cap: *mut capref,
        bytes: size_t,
        retbytes: *mut size_t,
        buf: *mut *mut ::std::os::raw::c_void,
        flags: ::std::os::raw::c_int,
    ) -> errval_t;
}
extern "C" {
    pub fn frame_alloc_and_map(
        cap: *mut capref,
        bytes: size_t,
        retbytes: *mut size_t,
        buf: *mut *mut ::std::os::raw::c_void,
    ) -> errval_t;
}
extern "C" {
    pub fn paging_map_stack_guard(ps: *mut paging_state, stack_bottom: lvaddr_t) -> errval_t;
}
extern "C" {
    pub fn page_fault_handler(
        type_: exception_type,
        subtype: ::std::os::raw::c_int,
        addr: *mut ::std::os::raw::c_void,
        regs: *mut arch_registers_state_t,
    );
}
extern "C" {
    pub fn paging_map_single_page_at(
        st: *mut paging_state,
        addr: lvaddr_t,
        flags: ::std::os::raw::c_int,
        pagesize: size_t,
    ) -> errval_t;
}
extern "C" {
    pub fn paging_init_state(
        st: *mut paging_state,
        start_vaddr: lvaddr_t,
        pdir: capref,
        ca: *mut slot_allocator,
    ) -> errval_t;
}
extern "C" {
    pub fn paging_init_state_foreign(
        st: *mut paging_state,
        start_vaddr: lvaddr_t,
        pdir: capref,
        ca: *mut slot_allocator,
    ) -> errval_t;
}
extern "C" {
    #[doc = " initialize self-paging module"]
    pub fn paging_init() -> errval_t;
}
extern "C" {
    pub fn paging_init_stack(ps: *mut paging_state) -> errval_t;
}
extern "C" {
    pub fn paging_init_onthread(t: *mut thread);
}
extern "C" {
    pub fn paging_region_init(
        st: *mut paging_state,
        pr: *mut paging_region,
        size: size_t,
        flags: paging_flags_t,
    ) -> errval_t;
}
extern "C" {
    pub fn paging_region_init_fixed(
        st: *mut paging_state,
        pr: *mut paging_region,
        base: lvaddr_t,
        size: size_t,
        flags: paging_flags_t,
    ) -> errval_t;
}
extern "C" {
    pub fn paging_region_init_aligned(
        st: *mut paging_state,
        pr: *mut paging_region,
        size: size_t,
        alignment: size_t,
        flags: paging_flags_t,
    ) -> errval_t;
}
extern "C" {
    pub fn paging_region_lookup(st: *mut paging_state, vaddr: lvaddr_t) -> *mut paging_region;
}
extern "C" {
    pub fn paging_region_delete(ps: *mut paging_state, pr: *mut paging_region) -> errval_t;
}
extern "C" {
    #[doc = " \\brief return a pointer to a bit of the paging region `pr`."]
    #[doc = " This function gets used in some of the code that is responsible"]
    #[doc = " for allocating Frame (and other) capabilities."]
    pub fn paging_region_map(
        pr: *mut paging_region,
        req_size: size_t,
        retbuf: *mut *mut ::std::os::raw::c_void,
        ret_size: *mut size_t,
    ) -> errval_t;
}
extern "C" {
    #[doc = " \\brief free a bit of the paging region `pr`."]
    #[doc = " This function gets used in some of the code that is responsible"]
    #[doc = " for allocating Frame (and other) capabilities."]
    #[doc = " We ignore unmap requests right now."]
    pub fn paging_region_unmap(pr: *mut paging_region, base: lvaddr_t, bytes: size_t) -> errval_t;
}
extern "C" {
    #[doc = " \\brief Find a bit of free virtual address space that is large enough to"]
    #[doc = "        accomodate a buffer of size `bytes`."]
    pub fn paging_alloc(
        st: *mut paging_state,
        buf: *mut *mut ::std::os::raw::c_void,
        bytes: size_t,
        alignment: size_t,
    ) -> errval_t;
}
extern "C" {
    #[doc = " Functions to map a user provided frame."]
    pub fn paging_map_frame_attr(
        st: *mut paging_state,
        buf: *mut *mut ::std::os::raw::c_void,
        bytes: size_t,
        frame: capref,
        flags: ::std::os::raw::c_int,
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> errval_t;
}
extern "C" {
    #[doc = " shadow page table lookup"]
    pub fn paging_spt_find(
        st: *mut paging_state,
        level: ::std::os::raw::c_int,
        addr: lvaddr_t,
        create: bool,
        ret: *mut *mut mapping_table,
    ) -> errval_t;
}
extern "C" {
    #[doc = " Map user provided frame at user provided VA with given flags."]
    pub fn paging_map_fixed_attr(
        st: *mut paging_state,
        vaddr: lvaddr_t,
        frame: capref,
        bytes: size_t,
        flags: ::std::os::raw::c_int,
    ) -> errval_t;
}
extern "C" {
    #[doc = " refill slab allocator without causing a page fault"]
    #[doc = ""]
    #[doc = " \\param frame references the capability slot where the frame cap can be put into"]
    pub fn slab_refill_no_pagefault(
        slabs: *mut slab_allocator,
        frame: capref,
        minbytes: size_t,
    ) -> errval_t;
}
extern "C" {
    #[doc = " \\brief unmap region starting at address `region`."]
    #[doc = " NOTE: this function is currently here to make libbarrelfish compile. As"]
    #[doc = " noted on paging_region_unmap we ignore unmap requests right now."]
    pub fn paging_unmap(st: *mut paging_state, region: *const ::std::os::raw::c_void) -> errval_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slot_allocator {
    pub alloc: ::std::option::Option<
        unsafe extern "C" fn(ca: *mut slot_allocator, cap: *mut capref) -> errval_t,
    >,
    pub free: ::std::option::Option<
        unsafe extern "C" fn(ca: *mut slot_allocator, cap: capref) -> errval_t,
    >,
    #[doc = "< Mutex for thread safety"]
    pub mutex: thread_mutex,
    #[doc = "< Slots to grow allocator by"]
    pub nslots: cslot_t,
    #[doc = "< Space left in the allocator"]
    pub space: cslot_t,
}
#[test]
fn bindgen_test_layout_slot_allocator() {
    assert_eq!(
        ::std::mem::size_of::<slot_allocator>(),
        56usize,
        concat!("Size of: ", stringify!(slot_allocator))
    );
    assert_eq!(
        ::std::mem::align_of::<slot_allocator>(),
        8usize,
        concat!("Alignment of ", stringify!(slot_allocator))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<slot_allocator>())).alloc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slot_allocator),
            "::",
            stringify!(alloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<slot_allocator>())).free as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(slot_allocator),
            "::",
            stringify!(free)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<slot_allocator>())).mutex as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(slot_allocator),
            "::",
            stringify!(mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<slot_allocator>())).nslots as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(slot_allocator),
            "::",
            stringify!(nslots)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<slot_allocator>())).space as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(slot_allocator),
            "::",
            stringify!(space)
        )
    );
}
#[doc = " Meta data for single_slot_allocator"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cnode_meta {
    pub slot: cslot_t,
    pub space: cslot_t,
    pub next: *mut cnode_meta,
}
#[test]
fn bindgen_test_layout_cnode_meta() {
    assert_eq!(
        ::std::mem::size_of::<cnode_meta>(),
        16usize,
        concat!("Size of: ", stringify!(cnode_meta))
    );
    assert_eq!(
        ::std::mem::align_of::<cnode_meta>(),
        8usize,
        concat!("Alignment of ", stringify!(cnode_meta))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cnode_meta>())).slot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cnode_meta),
            "::",
            stringify!(slot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cnode_meta>())).space as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cnode_meta),
            "::",
            stringify!(space)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cnode_meta>())).next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cnode_meta),
            "::",
            stringify!(next)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct single_slot_allocator {
    #[doc = "< Public data"]
    pub a: slot_allocator,
    #[doc = "< Cap of the cnode the allocator is tracking"]
    pub cap: capref,
    #[doc = "< Cnode the allocator is tracking"]
    pub cnode: cnoderef,
    #[doc = "< Linked list of free slots"]
    pub head: *mut cnode_meta,
    #[doc = "< Slab for backing the list"]
    pub slab: slab_allocator,
    #[doc = "< Currently refilling"]
    pub refilling: bool,
}
#[test]
fn bindgen_test_layout_single_slot_allocator() {
    assert_eq!(
        ::std::mem::size_of::<single_slot_allocator>(),
        128usize,
        concat!("Size of: ", stringify!(single_slot_allocator))
    );
    assert_eq!(
        ::std::mem::align_of::<single_slot_allocator>(),
        8usize,
        concat!("Alignment of ", stringify!(single_slot_allocator))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<single_slot_allocator>())).a as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(single_slot_allocator),
            "::",
            stringify!(a)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<single_slot_allocator>())).cap as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(single_slot_allocator),
            "::",
            stringify!(cap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<single_slot_allocator>())).cnode as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(single_slot_allocator),
            "::",
            stringify!(cnode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<single_slot_allocator>())).head as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(single_slot_allocator),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<single_slot_allocator>())).slab as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(single_slot_allocator),
            "::",
            stringify!(slab)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<single_slot_allocator>())).refilling as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(single_slot_allocator),
            "::",
            stringify!(refilling)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slot_allocator_list {
    pub a: single_slot_allocator,
    pub next: *mut slot_allocator_list,
}
#[test]
fn bindgen_test_layout_slot_allocator_list() {
    assert_eq!(
        ::std::mem::size_of::<slot_allocator_list>(),
        136usize,
        concat!("Size of: ", stringify!(slot_allocator_list))
    );
    assert_eq!(
        ::std::mem::align_of::<slot_allocator_list>(),
        8usize,
        concat!("Alignment of ", stringify!(slot_allocator_list))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<slot_allocator_list>())).a as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slot_allocator_list),
            "::",
            stringify!(a)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<slot_allocator_list>())).next as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(slot_allocator_list),
            "::",
            stringify!(next)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct multi_slot_allocator {
    #[doc = "< Public data"]
    pub a: slot_allocator,
    #[doc = "< List of single slot allocators"]
    pub head: *mut slot_allocator_list,
    #[doc = "< One single allocator in reserve"]
    pub reserve: *mut slot_allocator_list,
    #[doc = "< Slab backing the slot_allocator_list"]
    pub slab: slab_allocator,
    pub region: paging_region,
}
#[test]
fn bindgen_test_layout_multi_slot_allocator() {
    assert_eq!(
        ::std::mem::size_of::<multi_slot_allocator>(),
        184usize,
        concat!("Size of: ", stringify!(multi_slot_allocator))
    );
    assert_eq!(
        ::std::mem::align_of::<multi_slot_allocator>(),
        8usize,
        concat!("Alignment of ", stringify!(multi_slot_allocator))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<multi_slot_allocator>())).a as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(multi_slot_allocator),
            "::",
            stringify!(a)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<multi_slot_allocator>())).head as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(multi_slot_allocator),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<multi_slot_allocator>())).reserve as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(multi_slot_allocator),
            "::",
            stringify!(reserve)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<multi_slot_allocator>())).slab as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(multi_slot_allocator),
            "::",
            stringify!(slab)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<multi_slot_allocator>())).region as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(multi_slot_allocator),
            "::",
            stringify!(region)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct range_slot_allocator {
    #[doc = "< capref for the L1 cnode"]
    pub cnode_cap: capref,
    #[doc = "< cnoderef for the cnode to allocate from"]
    pub cnode: cnoderef,
    #[doc = "< Linked list of meta data"]
    pub meta: *mut cnode_meta,
    #[doc = "< Slab allocation"]
    pub slab: slab_allocator,
    #[doc = "< Mutex for thread safety (used when is_head == true)"]
    pub mutex: thread_mutex,
    #[doc = "< Next slot allocator"]
    pub next: *mut range_slot_allocator,
    #[doc = "< Is this instance head of a chain"]
    pub is_head: bool,
}
#[test]
fn bindgen_test_layout_range_slot_allocator() {
    assert_eq!(
        ::std::mem::size_of::<range_slot_allocator>(),
        112usize,
        concat!("Size of: ", stringify!(range_slot_allocator))
    );
    assert_eq!(
        ::std::mem::align_of::<range_slot_allocator>(),
        8usize,
        concat!("Alignment of ", stringify!(range_slot_allocator))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<range_slot_allocator>())).cnode_cap as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(range_slot_allocator),
            "::",
            stringify!(cnode_cap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<range_slot_allocator>())).cnode as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(range_slot_allocator),
            "::",
            stringify!(cnode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<range_slot_allocator>())).meta as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(range_slot_allocator),
            "::",
            stringify!(meta)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<range_slot_allocator>())).slab as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(range_slot_allocator),
            "::",
            stringify!(slab)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<range_slot_allocator>())).mutex as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(range_slot_allocator),
            "::",
            stringify!(mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<range_slot_allocator>())).next as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(range_slot_allocator),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<range_slot_allocator>())).is_head as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(range_slot_allocator),
            "::",
            stringify!(is_head)
        )
    );
}
extern "C" {
    pub fn single_slot_alloc_init(
        ret: *mut single_slot_allocator,
        nslots: cslot_t,
        retslots: *mut cslot_t,
    ) -> errval_t;
}
extern "C" {
    pub fn single_slot_alloc_init_raw(
        ret: *mut single_slot_allocator,
        cap: capref,
        cnode: cnoderef,
        nslots: cslot_t,
        buf: *mut ::std::os::raw::c_void,
        buflen: size_t,
    ) -> errval_t;
}
extern "C" {
    pub fn single_slot_alloc_freecount(s: *mut single_slot_allocator) -> cslot_t;
}
extern "C" {
    pub fn single_slot_alloc_resize(
        this: *mut single_slot_allocator,
        newslotcount: cslot_t,
    ) -> errval_t;
}
extern "C" {
    pub fn two_level_slot_alloc_init(ret: *mut multi_slot_allocator) -> errval_t;
}
extern "C" {
    pub fn two_level_slot_alloc_init_raw(
        ret: *mut multi_slot_allocator,
        initial_cap: capref,
        initial_cnode: cnoderef,
        reserve_cap: capref,
        reserve_cnode: cnoderef,
        head_buf: *mut ::std::os::raw::c_void,
        reserve_buf: *mut ::std::os::raw::c_void,
        bufsize: size_t,
    ) -> errval_t;
}
extern "C" {
    pub fn slot_alloc_init() -> errval_t;
}
extern "C" {
    pub fn get_default_slot_allocator() -> *mut slot_allocator;
}
extern "C" {
    pub fn slot_alloc(ret: *mut capref) -> errval_t;
}
extern "C" {
    #[doc = " Root slot allocator functions"]
    pub fn slot_alloc_root(ret: *mut capref) -> errval_t;
}
pub type cn_ram_alloc_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        st: *mut ::std::os::raw::c_void,
        reqbits: size_t,
        ret: *mut capref,
    ) -> errval_t,
>;
extern "C" {
    pub fn root_slot_allocator_refill(
        myalloc: cn_ram_alloc_func_t,
        allocst: *mut ::std::os::raw::c_void,
    ) -> errval_t;
}
extern "C" {
    pub fn slot_free(ret: capref) -> errval_t;
}
extern "C" {
    pub static mut slot_free_other:
        ::std::option::Option<unsafe extern "C" fn(ret: capref) -> errval_t>;
}
extern "C" {
    pub fn range_slot_alloc(
        alloc: *mut range_slot_allocator,
        nslots: cslot_t,
        ret: *mut capref,
    ) -> errval_t;
}
extern "C" {
    pub fn range_slot_free(
        alloc: *mut range_slot_allocator,
        cap: capref,
        nslots: cslot_t,
    ) -> errval_t;
}
extern "C" {
    pub fn range_slot_alloc_init(
        ret: *mut range_slot_allocator,
        nslots: cslot_t,
        retslots: *mut cslot_t,
    ) -> errval_t;
}
extern "C" {
    pub fn range_slot_alloc_freecount(alloc: *mut range_slot_allocator) -> size_t;
}
extern "C" {
    pub fn range_slot_alloc_refill(alloc: *mut range_slot_allocator, slots: cslot_t) -> errval_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct morecore_state {
    _unused: [u8; 0],
}
extern "C" {
    pub fn debug_cap_identify(cap: capref, ret: *mut capability) -> errval_t;
}
extern "C" {
    pub fn debug_dump_hw_ptables(arg1: *mut ::std::os::raw::c_void) -> errval_t;
}
extern "C" {
    pub fn debug_cap_trace_ctrl(types: usize, start_addr: genpaddr_t, size: gensize_t) -> errval_t;
}
extern "C" {
    pub fn debug_cspace(root: capref);
}
extern "C" {
    pub fn debug_my_cspace();
}
extern "C" {
    pub fn debug_printf(fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn debug_print_cap(
        buf: *mut ::std::os::raw::c_char,
        len: size_t,
        cap: *mut capability,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn debug_print_cap_at_capref(
        buf: *mut ::std::os::raw::c_char,
        len: size_t,
        cap: capref,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn debug_print_capref(
        buf: *mut ::std::os::raw::c_char,
        len: size_t,
        cap: capref,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn debug_print_cnoderef(
        buf: *mut ::std::os::raw::c_char,
        len: size_t,
        cnode: cnoderef,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn debug_print_paging_state(arg1: paging_state);
}
extern "C" {
    pub fn debug_print_paging_region(arg1: paging_region);
}
extern "C" {
    pub fn debug_print_morecore_state(arg1: morecore_state);
}
extern "C" {
    pub fn debug_print_save_area(state: *mut arch_registers_state_t);
}
extern "C" {
    pub fn debug_print_fpu_state(state: *mut arch_registers_state_t);
}
extern "C" {
    pub fn debug_dump(state: *mut arch_registers_state_t);
}
extern "C" {
    pub fn debug_call_chain(state: *mut arch_registers_state_t);
}
extern "C" {
    pub fn debug_return_addresses();
}
extern "C" {
    pub fn debug_dump_mem_around_addr(addr: lvaddr_t);
}
extern "C" {
    pub fn debug_dump_mem(base: lvaddr_t, limit: lvaddr_t, point: lvaddr_t);
}
extern "C" {
    pub fn debug_err(
        file: *const ::std::os::raw::c_char,
        func: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        err: errval_t,
        msg: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn user_panic_fn(
        file: *const ::std::os::raw::c_char,
        func: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        msg: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn is_ancestor(arg1: *mut capability, arg2: *mut capability) -> bool;
}
extern "C" {
    pub fn is_copy(arg1: *mut capability, arg2: *mut capability) -> bool;
}
extern "C" {
    pub fn is_well_founded(arg1: objtype, arg2: objtype) -> bool;
}
extern "C" {
    pub fn is_equal_type(arg1: objtype, arg2: objtype) -> bool;
}
extern "C" {
    pub fn compare_caps(arg1: *mut capability, arg2: *mut capability, arg3: bool) -> i8;
}
extern "C" {
    pub fn get_address(arg1: *mut capability) -> genpaddr_t;
}
extern "C" {
    pub fn get_size(arg1: *mut capability) -> gensize_t;
}
extern "C" {
    pub fn get_type_root(arg1: objtype) -> u8;
}
extern "C" {
    #[doc = " \\brief the actual syscall function"]
    #[doc = ""]
    #[doc = " the arguments are left in the registers x0-x11"]
    #[doc = " the return value is stored in x0 and x1 when returning from the syscall"]
    pub fn syscall(
        num: u64,
        arg1: u64,
        arg2: u64,
        arg3: u64,
        arg4: u64,
        arg5: u64,
        arg6: u64,
        arg7: u64,
        arg8: u64,
        arg9: u64,
        arg10: u64,
        arg11: u64,
    ) -> sysret;
}
#[doc = " Incoming LMP endpoint message buffer"]
#[repr(C)]
#[derive(Debug)]
pub struct lmp_endpoint_kern {
    #[doc = "< Address of cspace root of cnode to receive caps"]
    pub recv_cspc: capaddr_t,
    #[doc = "< CSpace address of slot to receive caps"]
    pub recv_cptr: capaddr_t,
    #[doc = "< Position in buffer (words delivered by kernel)"]
    pub delivered: u32,
    #[doc = "< Position in buffer (words consumed by user)"]
    pub consumed: u32,
    #[doc = "< Buffer for async LMP messages"]
    pub buf: __IncompleteArrayField<usize>,
}
#[test]
fn bindgen_test_layout_lmp_endpoint_kern() {
    assert_eq!(
        ::std::mem::size_of::<lmp_endpoint_kern>(),
        16usize,
        concat!("Size of: ", stringify!(lmp_endpoint_kern))
    );
    assert_eq!(
        ::std::mem::align_of::<lmp_endpoint_kern>(),
        8usize,
        concat!("Alignment of ", stringify!(lmp_endpoint_kern))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lmp_endpoint_kern>())).recv_cspc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lmp_endpoint_kern),
            "::",
            stringify!(recv_cspc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lmp_endpoint_kern>())).recv_cptr as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lmp_endpoint_kern),
            "::",
            stringify!(recv_cptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lmp_endpoint_kern>())).delivered as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lmp_endpoint_kern),
            "::",
            stringify!(delivered)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lmp_endpoint_kern>())).consumed as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lmp_endpoint_kern),
            "::",
            stringify!(consumed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lmp_endpoint_kern>())).buf as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lmp_endpoint_kern),
            "::",
            stringify!(buf)
        )
    );
}
pub const lmp_send_flag_LMP_FLAG_SYNC: lmp_send_flag = 1;
pub const lmp_send_flag_LMP_FLAG_YIELD: lmp_send_flag = 2;
pub const lmp_send_flag_LMP_FLAG_GIVEAWAY: lmp_send_flag = 4;
pub const lmp_send_flag_LMP_FLAG_IDENTIFY: lmp_send_flag = 8;
#[doc = " LMP send flags"]
pub type lmp_send_flag = ::std::os::raw::c_uint;
#[doc = " LMP send flags"]
pub use self::lmp_send_flag as lmp_send_flags_t;
#[doc = " \\brief LMP receiver-side header."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union lmp_recv_header {
    pub raw: usize,
    pub x: lmp_recv_header__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lmp_recv_header__bindgen_ty_1 {
    pub flags: lmp_recv_header__bindgen_ty_1__bindgen_ty_1,
    #[doc = "< Length of payload in words"]
    pub length: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct lmp_recv_header__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_lmp_recv_header__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<lmp_recv_header__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(lmp_recv_header__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<lmp_recv_header__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(lmp_recv_header__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl lmp_recv_header__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn captransfer(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_captransfer(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(captransfer: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let captransfer: u8 = unsafe { ::std::mem::transmute(captransfer) };
            captransfer as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_lmp_recv_header__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<lmp_recv_header__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(lmp_recv_header__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<lmp_recv_header__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(lmp_recv_header__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lmp_recv_header__bindgen_ty_1>())).flags as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lmp_recv_header__bindgen_ty_1),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lmp_recv_header__bindgen_ty_1>())).length as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(lmp_recv_header__bindgen_ty_1),
            "::",
            stringify!(length)
        )
    );
}
#[test]
fn bindgen_test_layout_lmp_recv_header() {
    assert_eq!(
        ::std::mem::size_of::<lmp_recv_header>(),
        8usize,
        concat!("Size of: ", stringify!(lmp_recv_header))
    );
    assert_eq!(
        ::std::mem::align_of::<lmp_recv_header>(),
        8usize,
        concat!("Alignment of ", stringify!(lmp_recv_header))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lmp_recv_header>())).raw as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lmp_recv_header),
            "::",
            stringify!(raw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lmp_recv_header>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lmp_recv_header),
            "::",
            stringify!(x)
        )
    );
}
pub const static_assert_16: ::std::os::raw::c_uint = 1;
pub type _bindgen_ty_4 = ::std::os::raw::c_uint;
pub const static_assert_17: ::std::os::raw::c_uint = 1;
pub type _bindgen_ty_5 = ::std::os::raw::c_uint;
extern "C" {
    pub fn get_phys_addr(cap_ref: capref) -> genpaddr_t;
}
extern "C" {
    pub fn get_phys_size(cap_ref: capref) -> gensize_t;
}
extern "C" {
    pub fn cnode_create(
        ret_dest: *mut capref,
        cnoderef: *mut cnoderef,
        slots: cslot_t,
        retslots: *mut cslot_t,
    ) -> errval_t;
}
extern "C" {
    pub fn cnode_create_foreign_l2(
        dest_l1: capref,
        dest_slot: cslot_t,
        cnoderef: *mut cnoderef,
    ) -> errval_t;
}
extern "C" {
    pub fn cnode_create_l2(ret_dest: *mut capref, cnoderef: *mut cnoderef) -> errval_t;
}
extern "C" {
    pub fn cnode_create_l1(ret_dest: *mut capref, cnoderef: *mut cnoderef) -> errval_t;
}
extern "C" {
    pub fn cnode_create_raw(
        dest: capref,
        cnoderef: *mut cnoderef,
        cntype: objtype,
        slots: cslot_t,
        retslots: *mut cslot_t,
    ) -> errval_t;
}
extern "C" {
    pub fn cnode_create_with_guard(
        dest: capref,
        cnoderef: *mut cnoderef,
        slots: cslot_t,
        retslots: *mut cslot_t,
        guard: u64,
        guard_size: u8,
    ) -> errval_t;
}
extern "C" {
    pub fn cnode_create_from_mem(
        dest: capref,
        src: capref,
        cntype: objtype,
        cnoderef: *mut cnoderef,
        slots: size_t,
    ) -> errval_t;
}
extern "C" {
    pub fn root_cnode_resize(cn: capref, ret: capref) -> errval_t;
}
extern "C" {
    pub fn cap_retype(
        dest_start: capref,
        src: capref,
        offset: gensize_t,
        new_type: objtype,
        objsize: gensize_t,
        count: size_t,
    ) -> errval_t;
}
extern "C" {
    pub fn cap_create(dest: capref, type_: objtype, bytes: size_t) -> errval_t;
}
extern "C" {
    pub fn cap_delete(cap: capref) -> errval_t;
}
extern "C" {
    pub fn cap_revoke(cap: capref) -> errval_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cspace_allocator {
    _unused: [u8; 0],
}
extern "C" {
    pub fn cap_destroy(cap: capref) -> errval_t;
}
extern "C" {
    pub fn cap_register_revoke(cap: capref, cont: event_closure) -> errval_t;
}
extern "C" {
    pub fn vnode_create(dest: capref, type_: objtype) -> errval_t;
}
extern "C" {
    pub fn frame_create(dest: capref, bytes: size_t, retbytes: *mut size_t) -> errval_t;
}
extern "C" {
    pub fn frame_create_aligned(
        dest: capref,
        bytes: size_t,
        alignment: size_t,
        retbytes: *mut size_t,
    ) -> errval_t;
}
extern "C" {
    pub fn frame_alloc(dest: *mut capref, bytes: size_t, retbytes: *mut size_t) -> errval_t;
}
extern "C" {
    pub fn frame_alloc_aligned(
        dest: *mut capref,
        bytes: size_t,
        alignment: size_t,
        retbytes: *mut size_t,
    ) -> errval_t;
}
extern "C" {
    pub fn devframe_type(dest: *mut capref, src: capref, bits: u8) -> errval_t;
}
extern "C" {
    pub fn dispatcher_create(dest: capref) -> errval_t;
}
pub type handler_func_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>;
extern "C" {
    pub fn endpoint_create(
        buflen: size_t,
        retcap: *mut capref,
        retep: *mut *mut lmp_endpoint,
    ) -> errval_t;
}
extern "C" {
    pub fn ump_endpoint_create(dest: capref, bytes: size_t) -> errval_t;
}
extern "C" {
    pub fn ump_endpoint_create_with_iftype(dest: capref, bytes: size_t, iftype: u16) -> errval_t;
}
extern "C" {
    pub fn idcap_alloc(dest: *mut capref) -> errval_t;
}
extern "C" {
    pub fn idcap_create(dest: capref) -> errval_t;
}
extern "C" {
    pub fn cnode_build_cnoderef(cnoder: *mut cnoderef, capr: capref) -> errval_t;
}
extern "C" {
    pub fn cnode_build_l1cnoderef(cnoder: *mut cnoderef, capr: capref) -> errval_t;
}
pub type ram_alloc_func_t = ::std::option::Option<
    unsafe extern "C" fn(ret: *mut capref, size: size_t, alignment: size_t) -> errval_t,
>;
extern "C" {
    pub fn ram_alloc_fixed(ret: *mut capref, size: size_t, alignment: size_t) -> errval_t;
}
extern "C" {
    pub fn ram_alloc_aligned(ret: *mut capref, size: size_t, alignment: size_t) -> errval_t;
}
extern "C" {
    pub fn ram_alloc(retcap: *mut capref, size: size_t) -> errval_t;
}
extern "C" {
    pub fn ram_available(available: *mut genpaddr_t, total: *mut genpaddr_t) -> errval_t;
}
extern "C" {
    pub fn ram_alloc_set(local_allocator: ram_alloc_func_t) -> errval_t;
}
extern "C" {
    pub fn ram_set_affinity(minbase: u64, maxlimit: u64);
}
extern "C" {
    pub fn ram_get_affinity(minbase: *mut u64, maxlimit: *mut u64);
}
extern "C" {
    pub fn ram_alloc_init();
}
extern "C" {
    #[doc = " \\brief Yield the CPU."]
    #[doc = ""]
    #[doc = " Yields the remainder of the time-slice for this dispatcher to the next"]
    #[doc = " runnable dispatcher."]
    #[doc = ""]
    #[doc = " \\param target Dispatcher to yield to, or CPTR_NULL for an undirected yield"]
    #[doc = ""]
    #[doc = " \\return Syscall error code (#SYS_ERR_OK on success)."]
    pub fn sys_yield(target: capaddr_t) -> errval_t;
}
extern "C" {
    #[doc = " Suspend the current cpu"]
    pub fn sys_suspend(halt: bool) -> errval_t;
}
extern "C" {
    pub fn sys_nop() -> errval_t;
}
extern "C" {
    pub fn sys_reboot() -> errval_t;
}
extern "C" {
    #[doc = " \\brief Print a string through the kernel."]
    #[doc = ""]
    #[doc = " This calls #SYSCALL_PRINT to print 'string' of length 'length' through"]
    #[doc = " the kernel. Whether and where 'string' is printed is determined by"]
    #[doc = " the kernel."]
    #[doc = ""]
    #[doc = " \\param string        Pointer to string to print."]
    #[doc = " \\param length        Length of string."]
    #[doc = ""]
    #[doc = " \\return Syscall error code (#SYS_ERR_OK on success)."]
    pub fn sys_print(string: *const ::std::os::raw::c_char, length: size_t) -> errval_t;
}
extern "C" {
    pub fn sys_getchar(c: *mut ::std::os::raw::c_char) -> errval_t;
}
extern "C" {
    #[doc = " \\brief get time elapsed (in milliseconds) since system boot."]
    pub fn sys_get_absolute_time() -> u64;
}
#[doc = " Run events continuously, as the waitset allows"]
pub const event_queue_mode_EVENT_QUEUE_CONTINUOUS: event_queue_mode = 0;
#[doc = " Trigger one event at a time, when event_queue_trigger() is called"]
pub const event_queue_mode_EVENT_QUEUE_ONESHOT: event_queue_mode = 1;
#[doc = " What mode does an event queue operate in?"]
pub type event_queue_mode = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct event_queue_node {
    pub event: event_closure,
    pub next: *mut event_queue_node,
    pub prev: *mut event_queue_node,
    pub run: bool,
}
#[test]
fn bindgen_test_layout_event_queue_node() {
    assert_eq!(
        ::std::mem::size_of::<event_queue_node>(),
        40usize,
        concat!("Size of: ", stringify!(event_queue_node))
    );
    assert_eq!(
        ::std::mem::align_of::<event_queue_node>(),
        8usize,
        concat!("Alignment of ", stringify!(event_queue_node))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<event_queue_node>())).event as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(event_queue_node),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<event_queue_node>())).next as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(event_queue_node),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<event_queue_node>())).prev as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(event_queue_node),
            "::",
            stringify!(prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<event_queue_node>())).run as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(event_queue_node),
            "::",
            stringify!(run)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct event_queue {
    pub mutex: thread_mutex,
    pub waitset: *mut waitset,
    pub waitset_state: waitset_chanstate,
    pub head: *mut event_queue_node,
    pub tail: *mut event_queue_node,
    pub mode: event_queue_mode,
}
#[test]
fn bindgen_test_layout_event_queue() {
    assert_eq!(
        ::std::mem::size_of::<event_queue>(),
        160usize,
        concat!("Size of: ", stringify!(event_queue))
    );
    assert_eq!(
        ::std::mem::align_of::<event_queue>(),
        8usize,
        concat!("Alignment of ", stringify!(event_queue))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<event_queue>())).mutex as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(event_queue),
            "::",
            stringify!(mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<event_queue>())).waitset as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(event_queue),
            "::",
            stringify!(waitset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<event_queue>())).waitset_state as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(event_queue),
            "::",
            stringify!(waitset_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<event_queue>())).head as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(event_queue),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<event_queue>())).tail as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(event_queue),
            "::",
            stringify!(tail)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<event_queue>())).mode as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(event_queue),
            "::",
            stringify!(mode)
        )
    );
}
extern "C" {
    pub fn event_queue_init(evq: *mut event_queue, waitset: *mut waitset, mode: event_queue_mode);
}
extern "C" {
    pub fn event_queue_add(q: *mut event_queue, qn: *mut event_queue_node, event: event_closure);
}
extern "C" {
    pub fn event_queue_cancel(q: *mut event_queue, qn: *mut event_queue_node) -> errval_t;
}
extern "C" {
    pub fn event_queue_trigger(q: *mut event_queue) -> errval_t;
}
extern "C" {
    pub fn event_queue_flush(q: *mut event_queue) -> errval_t;
}
pub type domain_spanned_callback_t =
    ::std::option::Option<unsafe extern "C" fn(arg: *mut ::std::os::raw::c_void, err: errval_t)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aos_chan {
    _unused: [u8; 0],
}
extern "C" {
    pub fn get_default_waitset() -> *mut waitset;
}
extern "C" {
    pub fn disp_set_core_id(core_id: coreid_t);
}
extern "C" {
    pub fn disp_get_core_id() -> coreid_t;
}
extern "C" {
    pub fn disp_get_current_core_id() -> coreid_t;
}
extern "C" {
    pub fn disp_get_eh_frame(eh_frame: *mut lvaddr_t, eh_frame_size: *mut size_t);
}
extern "C" {
    pub fn disp_get_eh_frame_hdr(eh_frame_hdr: *mut lvaddr_t, eh_frame_hdr_size: *mut size_t);
}
extern "C" {
    pub fn disp_get_domain_id() -> domainid_t;
}
extern "C" {
    pub fn disp_handle_get_core_id(handle: dispatcher_handle_t) -> coreid_t;
}
extern "C" {
    pub fn set_init_chan(initchan: *mut aos_chan);
}
extern "C" {
    pub fn get_init_chan() -> *mut aos_chan;
}
extern "C" {
    pub fn set_init_rpc(initrpc: *mut aos_rpc);
}
extern "C" {
    pub fn get_init_rpc() -> *mut aos_rpc;
}
extern "C" {
    pub fn get_morecore_state() -> *mut morecore_state;
}
extern "C" {
    pub fn get_current_paging_state() -> *mut paging_state;
}
extern "C" {
    pub fn set_current_paging_state(st: *mut paging_state);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ram_alloc_state {
    _unused: [u8; 0],
}
extern "C" {
    pub fn get_ram_alloc_state() -> *mut ram_alloc_state;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slot_alloc_state {
    _unused: [u8; 0],
}
extern "C" {
    pub fn get_slot_alloc_state() -> *mut slot_alloc_state;
}
#[doc = " LMP endpoint structure (including data accessed only by user code)"]
#[repr(C)]
#[derive(Debug)]
pub struct lmp_endpoint {
    #[doc = "< Next/prev endpoint in poll list"]
    pub next: *mut lmp_endpoint,
    #[doc = "< Next/prev endpoint in poll list"]
    pub prev: *mut lmp_endpoint,
    #[doc = "< Receive slot"]
    pub recv_slot: capref,
    #[doc = "< Waitset per-channel state"]
    pub waitset_state: waitset_chanstate,
    #[doc = "< Length of endpoint buffer (in words)"]
    pub buflen: u32,
    #[doc = "< Position in buffer processed by poll loop, but"]
    #[doc = "< not necessarily consumed by the user"]
    pub seen: u32,
    #[doc = "< Public part (shared with kernel)"]
    pub k: lmp_endpoint_kern,
}
#[test]
fn bindgen_test_layout_lmp_endpoint() {
    assert_eq!(
        ::std::mem::size_of::<lmp_endpoint>(),
        152usize,
        concat!("Size of: ", stringify!(lmp_endpoint))
    );
    assert_eq!(
        ::std::mem::align_of::<lmp_endpoint>(),
        8usize,
        concat!("Alignment of ", stringify!(lmp_endpoint))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lmp_endpoint>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lmp_endpoint),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lmp_endpoint>())).prev as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lmp_endpoint),
            "::",
            stringify!(prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lmp_endpoint>())).recv_slot as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lmp_endpoint),
            "::",
            stringify!(recv_slot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lmp_endpoint>())).waitset_state as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lmp_endpoint),
            "::",
            stringify!(waitset_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lmp_endpoint>())).buflen as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(lmp_endpoint),
            "::",
            stringify!(buflen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lmp_endpoint>())).seen as *const _ as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(lmp_endpoint),
            "::",
            stringify!(seen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lmp_endpoint>())).k as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(lmp_endpoint),
            "::",
            stringify!(k)
        )
    );
}
#[doc = " \\brief Message layout in user's buffer."]
#[doc = ""]
#[doc = " Note that the kernel never delivers a message like this."]
#[repr(C)]
#[derive(Debug)]
pub struct lmp_recv_buf {
    #[doc = "< Length of message payload (in words)"]
    pub msglen: size_t,
    #[doc = "< Length of entire buffer (in words)"]
    pub buflen: size_t,
    #[doc = "< Payload (variable length)"]
    pub words: __IncompleteArrayField<usize>,
}
#[test]
fn bindgen_test_layout_lmp_recv_buf() {
    assert_eq!(
        ::std::mem::size_of::<lmp_recv_buf>(),
        16usize,
        concat!("Size of: ", stringify!(lmp_recv_buf))
    );
    assert_eq!(
        ::std::mem::align_of::<lmp_recv_buf>(),
        8usize,
        concat!("Alignment of ", stringify!(lmp_recv_buf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lmp_recv_buf>())).msglen as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lmp_recv_buf),
            "::",
            stringify!(msglen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lmp_recv_buf>())).buflen as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lmp_recv_buf),
            "::",
            stringify!(buflen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lmp_recv_buf>())).words as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lmp_recv_buf),
            "::",
            stringify!(words)
        )
    );
}
#[doc = " Fixed-length version of #lmp_recv_buf"]
#[repr(C)]
#[derive(Debug)]
pub struct lmp_recv_msg {
    pub buf: lmp_recv_buf,
    #[doc = "< Payload (fixed length)"]
    pub words: [usize; 4usize],
}
#[test]
fn bindgen_test_layout_lmp_recv_msg() {
    assert_eq!(
        ::std::mem::size_of::<lmp_recv_msg>(),
        48usize,
        concat!("Size of: ", stringify!(lmp_recv_msg))
    );
    assert_eq!(
        ::std::mem::align_of::<lmp_recv_msg>(),
        8usize,
        concat!("Alignment of ", stringify!(lmp_recv_msg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lmp_recv_msg>())).buf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lmp_recv_msg),
            "::",
            stringify!(buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lmp_recv_msg>())).words as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lmp_recv_msg),
            "::",
            stringify!(words)
        )
    );
}
extern "C" {
    pub fn lmp_endpoint_alloc(buflen: size_t, retep: *mut *mut lmp_endpoint) -> errval_t;
}
extern "C" {
    pub fn lmp_endpoint_free(ep: *mut lmp_endpoint);
}
extern "C" {
    pub fn lmp_endpoint_create_in_slot(
        buflen: size_t,
        dest: capref,
        retep: *mut *mut lmp_endpoint,
    ) -> errval_t;
}
extern "C" {
    pub fn lmp_endpoint_set_recv_slot(ep: *mut lmp_endpoint, slot: capref);
}
extern "C" {
    pub fn lmp_endpoint_can_recv(ep: *mut lmp_endpoint) -> bool;
}
extern "C" {
    pub fn lmp_endpoints_poll_disabled(handle: dispatcher_handle_t);
}
extern "C" {
    pub fn lmp_endpoint_recv(
        ep: *mut lmp_endpoint,
        buf: *mut lmp_recv_buf,
        cap: *mut capref,
    ) -> errval_t;
}
extern "C" {
    pub fn lmp_endpoint_register(
        ep: *mut lmp_endpoint,
        ws: *mut waitset,
        closure: event_closure,
    ) -> errval_t;
}
extern "C" {
    pub fn lmp_endpoint_deregister(ep: *mut lmp_endpoint) -> errval_t;
}
extern "C" {
    pub fn lmp_endpoint_migrate(ep: *mut lmp_endpoint, ws: *mut waitset);
}
extern "C" {
    pub fn lmp_endpoint_store_lrpc_disabled(
        ep: *mut lmp_endpoint,
        bufpos: u32,
        arg1: usize,
        arg2: usize,
        arg3: usize,
        arg4: usize,
    );
}
extern "C" {
    pub fn lmp_endpoint_init();
}
#[doc = " A bidirectional LMP channel"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lmp_chan {
    #[doc = "< State belonging to waitset (for send)"]
    pub send_waitset: waitset_chanstate,
    #[doc = "< Next/prev in list of channels with send events"]
    pub next: *mut lmp_chan,
    #[doc = "< Next/prev in list of channels with send events"]
    pub prev: *mut lmp_chan,
    #[doc = "< Capabilities to local/remote endpoints"]
    pub local_cap: capref,
    #[doc = "< Capabilities to local/remote endpoints"]
    pub remote_cap: capref,
    #[doc = "< Incoming LMP endpoint (in dispatcher)"]
    pub endpoint: *mut lmp_endpoint,
    pub connstate: lmp_chan__bindgen_ty_1,
    #[doc = "< requested LMP buffer length, in words"]
    pub buflen_words: size_t,
}
#[doc = "< Disconnected"]
pub const lmp_chan_LMP_DISCONNECTED: ::std::os::raw::c_uint = 0;
#[doc = "< Waiting for bind reply"]
pub const lmp_chan_LMP_BIND_WAIT: ::std::os::raw::c_uint = 1;
#[doc = "< Special case for monitor binding: waiting for cap"]
pub const lmp_chan_LMP_MONITOR_ACCEPT: ::std::os::raw::c_uint = 2;
#[doc = "< Connection established"]
pub const lmp_chan_LMP_CONNECTED: ::std::os::raw::c_uint = 3;
#[doc = " connection state"]
pub type lmp_chan__bindgen_ty_1 = ::std::os::raw::c_uint;
#[test]
fn bindgen_test_layout_lmp_chan() {
    assert_eq!(
        ::std::mem::size_of::<lmp_chan>(),
        168usize,
        concat!("Size of: ", stringify!(lmp_chan))
    );
    assert_eq!(
        ::std::mem::align_of::<lmp_chan>(),
        8usize,
        concat!("Alignment of ", stringify!(lmp_chan))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lmp_chan>())).send_waitset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lmp_chan),
            "::",
            stringify!(send_waitset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lmp_chan>())).next as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(lmp_chan),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lmp_chan>())).prev as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(lmp_chan),
            "::",
            stringify!(prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lmp_chan>())).local_cap as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(lmp_chan),
            "::",
            stringify!(local_cap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lmp_chan>())).remote_cap as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(lmp_chan),
            "::",
            stringify!(remote_cap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lmp_chan>())).endpoint as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(lmp_chan),
            "::",
            stringify!(endpoint)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lmp_chan>())).connstate as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(lmp_chan),
            "::",
            stringify!(connstate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lmp_chan>())).buflen_words as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(lmp_chan),
            "::",
            stringify!(buflen_words)
        )
    );
}
extern "C" {
    pub fn lmp_chan_init(lc: *mut lmp_chan);
}
extern "C" {
    pub fn lmp_chan_destroy(lc: *mut lmp_chan);
}
extern "C" {
    pub fn lmp_chan_accept(lc: *mut lmp_chan, buflen_words: size_t, endpoint: capref) -> errval_t;
}
extern "C" {
    pub fn lmp_chan_register_send(
        lc: *mut lmp_chan,
        ws: *mut waitset,
        closure: event_closure,
    ) -> errval_t;
}
extern "C" {
    pub fn lmp_chan_deregister_send(lc: *mut lmp_chan) -> errval_t;
}
extern "C" {
    pub fn lmp_chan_migrate_send(lc: *mut lmp_chan, ws: *mut waitset);
}
extern "C" {
    pub fn lmp_chan_alloc_recv_slot(lc: *mut lmp_chan) -> errval_t;
}
extern "C" {
    pub fn lmp_channels_retry_send_disabled(handle: dispatcher_handle_t);
}
extern "C" {
    pub fn messages_wait_and_handle_next();
}
extern "C" {
    pub fn messages_handler_loop();
}
pub type CONST_CAST = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ump_msg {
    pub data: ump_msg__bindgen_ty_1,
    pub flag: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ump_msg__bindgen_ty_1 {
    pub u64_: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_ump_msg__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ump_msg__bindgen_ty_1>(),
        56usize,
        concat!("Size of: ", stringify!(ump_msg__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<ump_msg__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(ump_msg__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ump_msg__bindgen_ty_1>())).u64_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ump_msg__bindgen_ty_1),
            "::",
            stringify!(u64_)
        )
    );
}
#[test]
fn bindgen_test_layout_ump_msg() {
    assert_eq!(
        ::std::mem::size_of::<ump_msg>(),
        64usize,
        concat!("Size of: ", stringify!(ump_msg))
    );
    assert_eq!(
        ::std::mem::align_of::<ump_msg>(),
        8usize,
        concat!("Alignment of ", stringify!(ump_msg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ump_msg>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ump_msg),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ump_msg>())).flag as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ump_msg),
            "::",
            stringify!(flag)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ump_chan {
    pub recv_pane: *mut ::std::os::raw::c_void,
    pub recv_pane_size: size_t,
    pub recv_buf_index: size_t,
    pub send_pane: *mut ::std::os::raw::c_void,
    pub send_pane_size: size_t,
    pub send_buf_index: size_t,
    pub waitset_state: waitset_chanstate,
}
#[test]
fn bindgen_test_layout_ump_chan() {
    assert_eq!(
        ::std::mem::size_of::<ump_chan>(),
        144usize,
        concat!("Size of: ", stringify!(ump_chan))
    );
    assert_eq!(
        ::std::mem::align_of::<ump_chan>(),
        8usize,
        concat!("Alignment of ", stringify!(ump_chan))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ump_chan>())).recv_pane as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ump_chan),
            "::",
            stringify!(recv_pane)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ump_chan>())).recv_pane_size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ump_chan),
            "::",
            stringify!(recv_pane_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ump_chan>())).recv_buf_index as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ump_chan),
            "::",
            stringify!(recv_buf_index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ump_chan>())).send_pane as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ump_chan),
            "::",
            stringify!(send_pane)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ump_chan>())).send_pane_size as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ump_chan),
            "::",
            stringify!(send_pane_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ump_chan>())).send_buf_index as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ump_chan),
            "::",
            stringify!(send_buf_index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ump_chan>())).waitset_state as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ump_chan),
            "::",
            stringify!(waitset_state)
        )
    );
}
extern "C" {
    pub fn ump_chan_init(
        chan: *mut ump_chan,
        send_buf: *mut ::std::os::raw::c_void,
        send_buf_size: size_t,
        recv_buf: *mut ::std::os::raw::c_void,
        recv_buf_size: size_t,
    ) -> errval_t;
}
extern "C" {
    pub fn ump_chan_send(chan: *mut ump_chan, send: *mut ump_msg) -> bool;
}
extern "C" {
    pub fn ump_chan_can_receive(chan: *mut ump_chan) -> bool;
}
extern "C" {
    pub fn ump_chan_poll_once(chan: *mut ump_chan, recv: *mut ump_msg) -> bool;
}
extern "C" {
    pub fn ump_chan_register_recv(
        chan: *mut ump_chan,
        ws: *mut waitset,
        closure: event_closure,
    ) -> errval_t;
}
pub type ump_msg_handler_t = ::std::option::Option<
    unsafe extern "C" fn(arg: *mut ::std::os::raw::c_void, msg: *mut ump_msg) -> errval_t,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ump_poller {
    pub channels: *mut *mut ump_chan,
    pub handlers: *mut ump_msg_handler_t,
    pub args: *mut *mut ::std::os::raw::c_void,
    pub n_channels: size_t,
    pub capacity_channels: size_t,
}
#[test]
fn bindgen_test_layout_ump_poller() {
    assert_eq!(
        ::std::mem::size_of::<ump_poller>(),
        40usize,
        concat!("Size of: ", stringify!(ump_poller))
    );
    assert_eq!(
        ::std::mem::align_of::<ump_poller>(),
        8usize,
        concat!("Alignment of ", stringify!(ump_poller))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ump_poller>())).channels as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ump_poller),
            "::",
            stringify!(channels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ump_poller>())).handlers as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ump_poller),
            "::",
            stringify!(handlers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ump_poller>())).args as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ump_poller),
            "::",
            stringify!(args)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ump_poller>())).n_channels as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ump_poller),
            "::",
            stringify!(n_channels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ump_poller>())).capacity_channels as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ump_poller),
            "::",
            stringify!(capacity_channels)
        )
    );
}
extern "C" {
    pub fn ump_chan_init_poller(poller: *mut ump_poller) -> errval_t;
}
extern "C" {
    pub fn ump_chan_register_polling(
        poller: *mut ump_poller,
        chan: *mut ump_chan,
        handler: ump_msg_handler_t,
        arg: *mut ::std::os::raw::c_void,
    ) -> errval_t;
}
extern "C" {
    pub fn ump_chan_run_poller(poller: *mut ump_poller) -> errval_t;
}
extern "C" {
    pub fn ump_chan_get_default_poller() -> *mut ump_poller;
}
pub const aos_rpc_backend_AOS_RPC_LMP: aos_rpc_backend = 0;
pub const aos_rpc_backend_AOS_RPC_UMP: aos_rpc_backend = 1;
pub type aos_rpc_backend = ::std::os::raw::c_uint;
pub const aos_rpc_msg_type_AOS_RPC_INITIATE: aos_rpc_msg_type = 0;
pub const aos_rpc_msg_type_AOS_RPC_SEND_NUMBER: aos_rpc_msg_type = 1;
pub const aos_rpc_msg_type_AOS_RPC_SEND_STRING: aos_rpc_msg_type = 2;
pub const aos_rpc_msg_type_AOS_RPC_REQUEST_RAM: aos_rpc_msg_type = 3;
pub const aos_rpc_msg_type_AOS_RPC_REQUEST_FOREIGN_RAM: aos_rpc_msg_type = 4;
pub const aos_rpc_msg_type_AOS_RPC_SETUP_PAGE: aos_rpc_msg_type = 5;
pub const aos_rpc_msg_type_AOS_RPC_PROC_SPAWN_REQUEST: aos_rpc_msg_type = 6;
pub const aos_rpc_msg_type_AOS_RPC_FOREIGN_SPAWN: aos_rpc_msg_type = 7;
pub const aos_rpc_msg_type_AOS_RPC_PUTCHAR: aos_rpc_msg_type = 8;
pub const aos_rpc_msg_type_AOS_RPC_GETCHAR: aos_rpc_msg_type = 9;
pub const aos_rpc_msg_type_AOS_RPC_SET_READ: aos_rpc_msg_type = 10;
pub const aos_rpc_msg_type_AOS_RPC_FREE_READ: aos_rpc_msg_type = 11;
#[doc = "< rpc call that does nothing, for benchmarking"]
pub const aos_rpc_msg_type_AOS_RPC_ROUNDTRIP: aos_rpc_msg_type = 12;
pub const aos_rpc_msg_type_AOS_RPC_MAX_MSG_TYPES: aos_rpc_msg_type = 13;
#[doc = " \\brief different functions to call for rpc"]
#[doc = ""]
#[doc = " \\warning current implementation only supports up to \\link AOS_RPC_MAX_MSG_TYPES"]
#[doc = "          different functions."]
#[doc = ""]
pub type aos_rpc_msg_type = ::std::os::raw::c_uint;
#[doc = " \\brief different functions to call for rpc"]
#[doc = ""]
#[doc = " \\warning current implementation only supports up to \\link AOS_RPC_MAX_MSG_TYPES"]
#[doc = "          different functions."]
#[doc = ""]
pub use self::aos_rpc_msg_type as msg_type_t;
pub const aos_rpc_argument_type_AOS_RPC_NO_TYPE: aos_rpc_argument_type = 0;
pub const aos_rpc_argument_type_AOS_RPC_WORD: aos_rpc_argument_type = 1;
#[doc = "< four word string (32 chars) (currently only over ump)"]
pub const aos_rpc_argument_type_AOS_RPC_SHORTSTR: aos_rpc_argument_type = 2;
#[doc = "< longer string (currently only over lmp)"]
pub const aos_rpc_argument_type_AOS_RPC_STR: aos_rpc_argument_type = 3;
pub const aos_rpc_argument_type_AOS_RPC_BYTES: aos_rpc_argument_type = 4;
pub const aos_rpc_argument_type_AOS_RPC_CAPABILITY: aos_rpc_argument_type = 5;
#[doc = " \\brief possible argument/return types for rpc calls"]
pub type aos_rpc_argument_type = ::std::os::raw::c_uint;
#[doc = " \\brief containing info for rpc (un)marshalling"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aos_rpc_function_binding {
    pub port: aos_rpc_msg_type,
    pub n_args: u16,
    pub n_rets: u16,
    pub buf_page: *mut ::std::os::raw::c_void,
    pub buf_page_remote: *mut ::std::os::raw::c_void,
    pub calling_simple: bool,
    pub returning_simple: bool,
    pub args: [aos_rpc_argument_type; 8usize],
    pub rets: [aos_rpc_argument_type; 8usize],
}
#[test]
fn bindgen_test_layout_aos_rpc_function_binding() {
    assert_eq!(
        ::std::mem::size_of::<aos_rpc_function_binding>(),
        96usize,
        concat!("Size of: ", stringify!(aos_rpc_function_binding))
    );
    assert_eq!(
        ::std::mem::align_of::<aos_rpc_function_binding>(),
        8usize,
        concat!("Alignment of ", stringify!(aos_rpc_function_binding))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aos_rpc_function_binding>())).port as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aos_rpc_function_binding),
            "::",
            stringify!(port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aos_rpc_function_binding>())).n_args as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(aos_rpc_function_binding),
            "::",
            stringify!(n_args)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aos_rpc_function_binding>())).n_rets as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(aos_rpc_function_binding),
            "::",
            stringify!(n_rets)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<aos_rpc_function_binding>())).buf_page as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aos_rpc_function_binding),
            "::",
            stringify!(buf_page)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<aos_rpc_function_binding>())).buf_page_remote as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aos_rpc_function_binding),
            "::",
            stringify!(buf_page_remote)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<aos_rpc_function_binding>())).calling_simple as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aos_rpc_function_binding),
            "::",
            stringify!(calling_simple)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<aos_rpc_function_binding>())).returning_simple as *const _
                as usize
        },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(aos_rpc_function_binding),
            "::",
            stringify!(returning_simple)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aos_rpc_function_binding>())).args as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(aos_rpc_function_binding),
            "::",
            stringify!(args)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aos_rpc_function_binding>())).rets as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(aos_rpc_function_binding),
            "::",
            stringify!(rets)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aos_rpc {
    pub backend: aos_rpc_backend,
    pub channel: aos_rpc_backend_channel,
    pub n_bindings: size_t,
    pub bindings: [aos_rpc_function_binding; 13usize],
    pub handlers: [*mut ::std::os::raw::c_void; 13usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union aos_rpc_backend_channel {
    pub lmp: lmp_chan,
    pub ump: ump_chan,
}
#[test]
fn bindgen_test_layout_aos_rpc_backend_channel() {
    assert_eq!(
        ::std::mem::size_of::<aos_rpc_backend_channel>(),
        168usize,
        concat!("Size of: ", stringify!(aos_rpc_backend_channel))
    );
    assert_eq!(
        ::std::mem::align_of::<aos_rpc_backend_channel>(),
        8usize,
        concat!("Alignment of ", stringify!(aos_rpc_backend_channel))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aos_rpc_backend_channel>())).lmp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aos_rpc_backend_channel),
            "::",
            stringify!(lmp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aos_rpc_backend_channel>())).ump as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aos_rpc_backend_channel),
            "::",
            stringify!(ump)
        )
    );
}
#[test]
fn bindgen_test_layout_aos_rpc() {
    assert_eq!(
        ::std::mem::size_of::<aos_rpc>(),
        1536usize,
        concat!("Size of: ", stringify!(aos_rpc))
    );
    assert_eq!(
        ::std::mem::align_of::<aos_rpc>(),
        8usize,
        concat!("Alignment of ", stringify!(aos_rpc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aos_rpc>())).backend as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aos_rpc),
            "::",
            stringify!(backend)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aos_rpc>())).channel as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aos_rpc),
            "::",
            stringify!(channel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aos_rpc>())).n_bindings as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(aos_rpc),
            "::",
            stringify!(n_bindings)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aos_rpc>())).bindings as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(aos_rpc),
            "::",
            stringify!(bindings)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<aos_rpc>())).handlers as *const _ as usize },
        1432usize,
        concat!(
            "Offset of field: ",
            stringify!(aos_rpc),
            "::",
            stringify!(handlers)
        )
    );
}
extern "C" {
    pub fn aos_rpc_init(rpc: *mut aos_rpc) -> errval_t;
}
extern "C" {
    #[doc = " \\brief Initialize an aos_rpc struct."]
    pub fn aos_rpc_init_lmp(
        rpc: *mut aos_rpc,
        self_ep: capref,
        end_ep: capref,
        lmp_ep: *mut lmp_endpoint,
    ) -> errval_t;
}
extern "C" {
    #[doc = " \\brief Initialize an aos_rpc struct running on ump backend"]
    pub fn aos_rpc_init_ump(
        rpc: *mut aos_rpc,
        shared_page: lvaddr_t,
        shared_page_size: size_t,
        first_half: bool,
    ) -> errval_t;
}
extern "C" {
    #[doc = " \\brief initialize marshalling info for an rpc function"]
    #[doc = ""]
    #[doc = " In order to use an rpc binding, it needs to be registered here."]
    #[doc = " Once registered, the function can be called by using \\link aos_rpc_call ."]
    #[doc = ""]
    #[doc = " Note that the callee domain still needs to set a handler for this function"]
    #[doc = " using \\link aos_rpc_register_handler."]
    #[doc = ""]
    #[doc = " \\param rpc the rpc struct in which to register the function"]
    #[doc = " \\param binding the function id to register"]
    #[doc = " \\param n_args number of arguments"]
    #[doc = " \\param n_rets number of return arguments"]
    #[doc = " \\param ... the remaining parameters are of type <code>enum aos_rpc_argument_type</code>"]
    #[doc = "            first the \\link n_args types of the arguments, then the \\link n_rets types"]
    #[doc = "            of the return types."]
    #[doc = ""]
    pub fn aos_rpc_initialize_binding(
        rpc: *mut aos_rpc,
        binding: aos_rpc_msg_type,
        n_args: ::std::os::raw::c_int,
        n_rets: ::std::os::raw::c_int,
        ...
    ) -> errval_t;
}
extern "C" {
    #[doc = " \\brief call a rpc function"]
    #[doc = ""]
    #[doc = " \\param binding the function to call"]
    #[doc = " \\param ... the following arguments need to be of the types expected by this"]
    #[doc = "            function."]
    #[doc = "            AOS_RPC_WORD          becomes uintptr_t"]
    #[doc = "            AOS_RPC_STR           becomes const char*"]
    #[doc = "            AOS_RPC_BYTES         currently unimplemented"]
    #[doc = "            AOS_RPC_CAPABILITY    becomes struct capref"]
    pub fn aos_rpc_call(rpc: *mut aos_rpc, binding: aos_rpc_msg_type, ...) -> errval_t;
}
extern "C" {
    #[doc = " \\brief registers a handler function to be called when this rpc is invoked"]
    #[doc = "        and should be run in our domain."]
    #[doc = ""]
    #[doc = " The handler should take arguments corresponding to the registered binding --"]
    #[doc = ""]
    #[doc = "        AOS_RPC_WORD          becomes uintptr_t"]
    #[doc = "        AOS_RPC_STR           becomes const char*"]
    #[doc = "        AOS_RPC_BYTES         currently unimplemented"]
    #[doc = "        AOS_RPC_CAPABILITY    becomes struct capref"]
    #[doc = ""]
    #[doc = " followed by the return values, that are of the corresponding pointer type."]
    #[doc = " They each point to a valid location and need to be written to in order to"]
    #[doc = " return any values."]
    pub fn aos_rpc_register_handler(
        rpc: *mut aos_rpc,
        binding: aos_rpc_msg_type,
        handler: *mut ::std::os::raw::c_void,
    ) -> errval_t;
}
extern "C" {
    #[doc = " message handler function for rpc calls via lmp"]
    pub fn aos_rpc_on_message(rpc: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " message handler function for rpc calls via ump"]
    pub fn aos_rpc_on_ump_message(arg: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " \\brief Send a number."]
    pub fn aos_rpc_send_number(chan: *mut aos_rpc, val: usize) -> errval_t;
}
extern "C" {
    #[doc = " \\brief Send a string."]
    pub fn aos_rpc_send_string(
        chan: *mut aos_rpc,
        string: *const ::std::os::raw::c_char,
    ) -> errval_t;
}
extern "C" {
    #[doc = " \\brief Request a RAM capability with >= request_bits of size over the given"]
    #[doc = " channel."]
    pub fn aos_rpc_get_ram_cap(
        chan: *mut aos_rpc,
        bytes: size_t,
        alignment: size_t,
        retcap: *mut capref,
        ret_bytes: *mut size_t,
    ) -> errval_t;
}
extern "C" {
    #[doc = " \\brief Get one character from the serial port"]
    pub fn aos_rpc_serial_getchar(
        chan: *mut aos_rpc,
        retc: *mut ::std::os::raw::c_char,
    ) -> errval_t;
}
extern "C" {
    #[doc = " \\brief Send one character to the serial port"]
    pub fn aos_rpc_serial_putchar(chan: *mut aos_rpc, c: ::std::os::raw::c_char) -> errval_t;
}
extern "C" {
    #[doc = " \\brief Request that the process manager start a new process"]
    #[doc = " \\arg cmdline the name of the process that needs to be spawned (without a"]
    #[doc = "           path prefix) and optionally any arguments to pass to it"]
    #[doc = " \\arg newpid the process id of the newly-spawned process"]
    pub fn aos_rpc_process_spawn(
        chan: *mut aos_rpc,
        cmdline: *mut ::std::os::raw::c_char,
        core: coreid_t,
        newpid: *mut domainid_t,
    ) -> errval_t;
}
extern "C" {
    #[doc = " \\brief Get name of process with the given PID."]
    #[doc = " \\arg pid the process id to lookup"]
    #[doc = " \\arg name A null-terminated character array with the name of the process"]
    #[doc = " that is allocated by the rpc implementation. Freeing is the caller's"]
    #[doc = " responsibility."]
    pub fn aos_rpc_process_get_name(
        chan: *mut aos_rpc,
        pid: domainid_t,
        name: *mut *mut ::std::os::raw::c_char,
    ) -> errval_t;
}
extern "C" {
    #[doc = " \\brief Get PIDs of all running processes."]
    #[doc = " \\arg pids An array containing the process ids of all currently active"]
    #[doc = " processes. Will be allocated by the rpc implementation. Freeing is the"]
    #[doc = " caller's  responsibility."]
    #[doc = " \\arg pid_count The number of entries in `pids' if the call was successful"]
    pub fn aos_rpc_process_get_all_pids(
        chan: *mut aos_rpc,
        pids: *mut *mut domainid_t,
        pid_count: *mut size_t,
    ) -> errval_t;
}
extern "C" {
    pub fn aos_rpc_get_terminal_input(
        chan: *mut aos_rpc,
        buf: *mut ::std::os::raw::c_char,
        le: size_t,
    ) -> errval_t;
}
extern "C" {
    #[doc = " \\brief Returns the RPC channel to init."]
    pub fn aos_rpc_get_init_channel() -> *mut aos_rpc;
}
extern "C" {
    #[doc = " \\brief Returns the channel to the memory server"]
    pub fn aos_rpc_get_memory_channel() -> *mut aos_rpc;
}
extern "C" {
    #[doc = " \\brief Returns the channel to the process manager"]
    pub fn aos_rpc_get_process_channel() -> *mut aos_rpc;
}
extern "C" {
    #[doc = " \\brief Returns the channel to the serial console"]
    pub fn aos_rpc_get_serial_channel() -> *mut aos_rpc;
}
extern "C" {
    #[doc = " \\brief Returns a new capability of fresh ram from the core defined by core_id"]
    pub fn aos_rpc_request_foreign_ram(
        rpc: *mut aos_rpc,
        size: size_t,
        ret_cap: *mut capref,
        ret_size: *mut size_t,
    ) -> errval_t;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cte {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kcb {
    pub _address: u8,
}
